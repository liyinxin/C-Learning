							9.顺序容器
内容
-----------------------------------
	9.1		顺序容器概述
	9.2		容器库概览
	9.3		顺序容器操作
	9.4		vector对象是如何增长的
	9.5		额外的string操作
	9.6		容器适配器
-----------------------------------
	本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。元素在顺序容器中的顺序
与其加入容器时的位置相相对应。标准库还定义了几种关联容器，关联容器中元素的位置由元素相关联的关键字值决定。
我们将在第11章介绍关联容器特有的操作。所有的容器类都共享公共的接口，不同容器按照不同方式对其进行扩展。这
个公共接口使容器的学习更加容易－－－－－
我们基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同性能和功能的权衡。
	一个容器就是一些特定类型对象的集合。顺序容器(sequential container)为程序员提供了控制元素存储和
访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，我么么将在第11章介
绍的有序和无序关联容器，则根据关键字的值来存储元素。标准库还提供了三种容器适配器，分别为容器操作定义了不同
的接口，来与容器类型适配。我们将在本章末尾介绍适配器。

9.1	顺序容器概述

	下表中列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面
都有不同的性能折中:
		>>>>向容器中添加或从容器中删除元素的代价
		>>>>非顺序访问容器中元素的代价

		vector			可变大小数组。支持此快速随机访问，在尾部之外的位置从
						插入或删除元素可能很慢
		deque			双端队列。支持快速随机访问，在头尾位置插入/删除速度
						很快
		list			双向链表，只支持双向顺序访问。在list中任何位置进
						行插入/删除速度很快
		forward_list	单向链表。只支持单向顺序访问。在链表任何位置进行插入
						/删除操作都很快
		array			固定大小数组。支持快速随机访问。不能添加或删除元素
		string			与vector相似的容器，但是专门用于保存字符。随机访
						问快。在尾部插入/删除速度快

	除了固定大小的array外，其它容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩
容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还
会影响特定容器是否支持特定操作。
	例如，string和vector将元素保存在连续的内存空间中。由于元素是连续存储的。由元素的下标来计算其
地址是非常快速的。但是在这两种容器的中间位置添加或删除元素就会非常耗时:在一次从插入或删除操作后，需
要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空
间。在这种情况下，每个元素都必须移动到新的存储空间中。
	list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，这
两个容器不支持元素的快递随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与vector、deque和
array相比，这两个容器的额外开销也很大。
	deque是一个更为复杂的数据树结构。与string和vector类似，deque支持快速的随机访问，与string和
vector一样，在deque的中间位置添加或删除元素的代价很高。但是，在deque的两端添加或删除元素都是很快的。
与list或forward_list添加删除元素的速度相当。
	foward_list和array是新C++标准中增加的类型。与内置数组相比，array是一种更安全、更容易使用的
数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器的大小
的操作。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容
器而言，size保证是一个快速的常量时间的操作。
注意:
	新标准库的容器比旧版本的快的多。原因我们将在13.6节解释。新标准库容器的性能几乎肯定与最精心优化过
的同类数据结构一样好（通常会更好）。现在C++程序使用标准库容器，而不是更原始的数据结构。

确定使用哪种顺序容器

	通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。以下是一些选择容器的基本原则:
		>>>>除非你有很好的理由选择其他容器，否则应该使用vector
		>>>>如果你的程序有很多小的元素，且空间的额外开销很重要，否则不要使用list或forward__list。
		>>>>如果程序要求随机访问元素，应使用vector或deque
		>>>>如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。
		>>>>如果程序需要在头尾插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。
		>>>>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则:
		---首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector
追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素。从而避免在中间位置
添加元素。
		---如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷
贝到一个vector中。
	如果程序急需要随机访问，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward_list
中访问元素与vector或deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作（执行访问操作更多
还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用性能可能就是必要的了。

9.2	容器库概览

	容器类型上的操作形成了一种层次:
		>>>>某些操作是所有容器类型都提供的
		>>>>另外一些操作仅针对顺序容器、关联容器或无序容器。
		>>>>还有一些操作只适用于一小部分容器。
在本节中，我们将要介绍对所有容器都使用的操作。本章剩余部分将聚焦于仅适用于顺序容器的操作。关联容器特有的
操作将在第11章介绍。一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。即,deque定义在deque
头文件中，list定义在list头文件中。以此类推，容器均定义为模板。例如对vector，我们必须提供额外信息来生
成特定的容器类型。对大多数，但不是所有容器，我们还需要额外提供元素类型信息。
		list<Sales_data>;	//保存Sales_data对象的list
		deque<double>;		//保存double的deque

对容器可以保存的元素类型的限制

	顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。这种
容器的定义与其他容器类型完全一样:在尖括号中指定元素类型（此种情况下，是另一种容器类型):
		vector<vector<string>> lines;	//vector的vector
此处lines是一个vector，其元素类型是string的vector。较旧的编译器可能需要在两个尖括号之间键入空格，
例如vector<vector<string> >。
	虽然我们可以在容器中保存几乎任何类型，但是某些容器操作对元素类型有其自己的特殊要求。我们可以为不
支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。
	例如，顺序容器构造函数的一个版本接受容器大小参数。它使用了元素类型的默认构造函数，但某些没有默认
构造函数。我们可以定义一个保存这种类型的对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目
参数:
		//假定noDefault是一个没有构造函数的类型
		vector<noDefault> v1(10,init);	//正确:提供了元素初始器
		vector<noDefault> v2(10);		//错误:必须提供一个元素初始化器，因为noDefault没
有默认的构造函数！！
					容器操作
	类型别名
	iterator		此容器类型的迭代器类型
	const_iterator	可以读取元素，但是不能修改元素的迭代器类型
	size_type		无符号整数类型，足够保存此种容器类型最大可能容器的大小
	difference_type	带符号整数类型，足够保存两个迭代器之间的距离
	value_type		元素类型
	reference		元素的左值类型;与value_type&含义相同；也就是引用的意思
	const_reference	元素的const左值类型（即，const value_type&)
	构造函数
	C c;			默认构造函数，构造空容器
	C c1(c2);		构造c2的拷贝
	C c(b,e);		构造c，将迭代器b和e指定的范围内元素拷贝到c（array不支持)
	C c{a,b,c,...};	列表初始化c

	赋值与swap
	c1 = c2			将c1中的元素替换为c2中的元素
	c1 = {a,b,c...}	将c1中的元素替换为列表中元素（不适用array)
	a.swap(b)		交换a和b的元素
	swap(a,b)		和a.swap(b)等价

	大小
	c.size()		c中元素的数目（不支持forward_list)
	c.max_size()	c可保存的最大元素数目
	c.empty()		若c中存储了元素，返回false,否则返回true

	添加/删除元素（不适用array)
	注：在不同容器中，这些操作的接口都不同
	c.insert(args)	将args中的元素拷贝进c
	c.emplace(inits)使用inits构造一个元素
	c.erase(args)	删除args指定的元素
	c.clear()		删除c中的所有元素，返回void

	关系运算符
	==,!=			所有容器都支持相等(不等）运算符
	<,<=,>,>=		关系运算符（无序关联容器不支持）

	获取迭代器
	c.begin(),c.end()返回指向c的首元素和尾元素之后位置的迭代器
	c.cbegin(),c.cend()返回const_iterator

	反向容器的额外成员（不支持forward_list)
	reverse_iterator 按逆序寻址元素的迭代器
	const_reverse_iterator不能修改元素的逆序迭代器
	c.rbegin(),c.rend()返回指向c的尾元素和首元素之前位置的迭代器
	c.crbegin(),c.crend()返回const_reverse_iterator

9.2.1	迭代器

	与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个
操作的实现方式都是相同的。例如，标准容器类型上的所有迭代器都允许我们访问容器中的元素，而所有迭代器都是
通过解引用运算符来实现这个操作的。类似的，标准库容器的所有迭代器都定义了递增运算符，当从前元素移动到下
一个元素。

				标准容器迭代器的运算符
		*iter			返回迭代器iter所指元素的引用
		iter->mem		解引用iter并获取该元素的名为mem的成员。等价于(*iter).mem
		++iter			令iter指示容器中的下一个元素
		--iter			令iter指示容器中的上一个元素
		iter1 == iter2	判断两个迭代器是否相等（不相等）
		iter1 != iter2	如果两个迭代器指示的是同一个元素或者它们是同一个容器尾后迭代器
						的尾后迭代器，则相等：反之，不相等
				迭代器运算
		iter + n		迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来
						相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素。
						或者指示容器尾元素的下一个位置。
		iter - n		同上，只不过是往左移动了位置
		iter1 += n		迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1
		iter1 -= n		同上
		iter1-iter2		两个迭代器相减的结果是他们之间的距离
		>,>=,<,<=		迭代器的关系运算符，和普通的一样

迭代器范围

	一个迭代器范围（iterator range)由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或
者是尾元素之后的位置。这两个迭代器通常被称为begin和end，或者是first和last(可能有些误导），它
们标记了容器中元素的一个范围。虽然第二个迭代器通常被称为last，但是这种叫法有些误导，因为第二个迭
代器从来不指向范围中的最后一个元素，而是指向尾元素之后的位置。迭代器范围中的元素包含first所表示
的元素以及从first开始直至last(但不包含last)之间的所有元素。这种元素范围被称为左闭合区间，其标准数学描述为:
		[begin,end)
表示范围自begin开始，于end之前结束。迭代器begin和end必须指向相同的容器。end可以与begin指向
相同位置，但不能指向begin之前的位置。
对构成范围的迭代器的要求
	如果满足如下条件，两个迭代器begin和end构成一个迭代器范:
		>>>>他们指向同一个容器中的元素，或者是容器最后一个元素之后的位置，且
		>>>>我们可以通过反复递增begin和end。换句话说，end不在begin之前。

使用左闭合范围蕴含的编程假定

	标准库使用左闭合范围是因为这种范围有三种方便的性质。假定begin和end构成一个合法的迭代器
范围，则
		>>>>如果begin和end相等，则范围为空
		>>>>如果begin和end不相等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。
		>>>>我们可以对begin递增若干次，使得begin==end
这些性质意味着我们可以向下面的代码一样用一个循环来处理一个元素范围，而这是安全的:
		while(begin != end){
			*begin = val;	//正确：范围非空，因此begin指向一个元素
			++begin;	//移动迭代器，获取下一个元素
		}
给定构成一个合法范围的迭代器begin和end，若begin==end，则范围为空。在此情况下，我们应该退出循
环。如果范围不为空，begin指向此非空范围的一个元素。因此，在while循环体中，可以安全地解引用
begin，因为begin必然指向一个元素。最后，由于每次循环对begin递增一次，我们确定循环最终会结束。

9.2.2	容器类型成员

	每个容器都定义多个类型，我们已经使用过其中三种:size_type,iterator和const_iterator。
除了已经使用过的迭代器类型，大多数容器还提供反向迭代器。简单说，反向迭代器就是一种反向遍历容器的
迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行++操作，会得到
上一个元素。
	剩下的就是类型别名了，通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。如果需要元
素类型，可以使用容器的value_type。如果需要元素类型的一个引用，可以使用reference或
const_reference。这些元素相关的类型别名在泛型编程中非常有用，我们将在16章中介绍相关内容。
	为了使用这些类型，我们必须显示使用其类名:
		//iter是通过list<string>定义的一个迭代器类型
		list<string>::iterator	iter;
		//count是通过vector<int>定义的一个difference_type
		vector<int>::difference_type count
这些声明语句使用了作用域运算符来说明我们希望使用list<string>类的iterator成员以及vector<int>
类定义的difference_type。

9.2.3	begin和end成员

	begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成
一个包含容器中是所有元素的迭代器范围。begin和end有多个版本:带r的版本返回反向迭代器；以c开头的版本
返回const迭代器:
		list<string> a = {"Milton","Shakespeare","Austen"};
		auto it1 = a.begin();	//it1的类型是list<string>::iterator
		auto it2 = a.rbegin();	//it2的类型是list<string>::reverse_iterator
		auto it3 = a.cbegin();	//it3的类型是list<string>::const_iterator
		auto it4 = a.crbegin();	//it4的类型是list<string>::const_reverse_iterator
不以c开头的函数都是被重载过的。也就是说，实际上有两个名为begin的成员。一个是const成员，返回容器的
const_iterator类型。另一个是非常量成员，返回容器的iterator类型。rbegin、end和rend的情况类似。
当我们对一个非常量对象调用这些成员时，得到的是返回iterator的版本，只有在对一个constt对象调用这些
函数时，才会得到一个const版本。与const指针和引用类似，可以将一个普通的iterator转换为对应的
const_iterator，但反之不行。
	以c开头的版本是C++新标准引入的，用以支持auto与begin和end函数结合使用。过去，没有其他选择，只
能显示声明希望使用哪种类型的迭代器:
		//显示指定类型
		list<string>::iterator it5 = a.begin();
		list<string>::const_iterator it6 = a.begin();
		//是iterator还是const_iterator依赖于a的类型
		auto it7 = a.begin();//仅当a是const时,it7是const_iterator
		auto it7 = a.cbegin();//it8是const_iterator
注意:
	上面的例子很好的阐述了为什么要引进c开头的版本！！
当auto与begin或end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。
但以c开头的版本还是可以获得const_iterator的。而不管容器的类型是什么。当不需要写访问时，应该使
用cbegin和cend！！

9.2.4	容器定义和初始化

	每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型
的空容器，且都可以接受指定容器大小和元素初始值的参数。

		C c;			默认构造函数。如果C是一个array，则c中元素按默认方式初始化；否则为空
		C c1(c2);		c1初始化为c2的拷贝，c1和c2必须是相同类型（即他们必须是相同的容器
						类型，且保存的是相同的元素类型；对于array类型，两者还必须具有相同大小）
		C c1 = c2;		同上
		C c{a,b,c...}	c初始化为列表初始中元素的拷贝。列表中元素的类型必须与C的元素类型相
						容。对于array类型，列表中元素数目必须等于或小于array的大小，任
						何遗漏的元素都进行值初始化
		C c={a,b,c...}	同上
		C c(b,e)		c初始化为迭代器b和e指定范围中的元素的拷贝，范围中元素的类型必须
						与c的元素类型相容。

只有顺序容器(不包括array)的构造函数才能接受大小参数
		C seq(n)		seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的（string不适用）
		C seq(n,tt)		seq包含n个初始化为值t的元素

将一个容器初始化为另一个容器的拷贝

	将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者(array)拷贝由一个
迭代器对指定的元素范围。为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。
不过，当传递迭代器参数来拷贝一个范围时，就不要求容器容器类型是相同的了。而且新容器和原容器中的元素
类型也可以　不同，只要能将拷贝的元素转换为要初始化的容器的元素类型即可。
		//每个容器有三个元素，用给定的初始化器进行初始化
		list<string>authors = {"Milton","Ali","Austen"};
		vector<const char*> articles = {"a","an","the"};
		deque<string>list2(authors);//正确，类型匹配
		deque<string>authList(authors);//错误：容器类型不匹配！！
		vector<string>words(articles);//错误：容器类型必须匹配
		//正确：可以将const char*元素转换为string
		forward_list<string>words(article.begin(),articles.end());
注意:
	当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同！！！
	接受两个迭代器参数的构造函数使用这两个迭代器表示我们想要拷贝的一个元素范围，与以往一样，两个迭
代器表示我们想要拷贝一个元素范围。与以往一样，两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的
位置。新容器的大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素值进行初始化。
	由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列。例如，假定迭代器
it表示authors中的一个元素，我们可以编写如下代码:
		//拷贝元素，直到（但不包括）it指向的元素
		deque<string>authList(authors.begin(),it);

列表初始化

	在新标准中，我们可以对一个容器进行列表初始化:
		//每个容器都有三个元素，用给定的初始化器进行初始化
		list<string>authors = {"Li","Ali","Adam"};
		vector<const char *>articles = {"a","an","the"};
当这样做时，我们就显示指定了容器中每个元素的值，对于除array之外的容器来下，初始化列表还隐含指定了
容器当前的大小:容器将包含与初始值一样多的元素。

与顺序容器大小相关的构造函数

	除了与关联容器相同的构造函数外，顺序容器(array除外)还提供另一个构造函数，它接受一个容器大小和一个
（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器:
		vector<int>ivec(10,-1);		//10个int元素，每个都初始化为-1
		list<string>svec(10,"hi");	//10个string对象，每个都初始化为"hi"
		forward_list<int> ivec(10);	//10个元素，每个都初始化为0
		deque<string> sve(10);		//10个元素，每个都是空string
如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类
型没有设置为默认构造函数，除了大小参数外，还必须指定一个显示的元素初始值。
注意:
		只有顺序容器的构造函数才接受大小参数，关联容器并不支持！

标准库array具有固定大小

	与内置数组一样，标准库array的大小也是类型的一部分！当定义一个array时，删除了指定元素类型，还要指定
容器大小:
		array<int,42>	//类型为:保存42个int的数组
		array<string,10>//类型为:保存10个string的数组
为了使用array类型，我们必须同时指定元素类型和大小:
		array<int,10>::size_type i;		//数组类型包括元素类型和大小
		array<int>::size_type j;		//错误:array<int>不是一个类型
由于大小是类型的一部分，array不支持普通容器的构造函数。这些构造函数都会确定容器的大小，要么隐式的，要么
显示地。而允许用户向一个array构造函数传递大小参数，最好情况下也是多余的，而且容易出错。
	array大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，一个默认构造的array是非空的：
它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组中的元素那样。如果我们对array进行
列表初始化，初始值的数目必须等于或小于array的大小。如果初始化数目小于array进行列表初始化，初始值的数目
必去必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所
有剩余元素都会进行值初始化　。在这两种情况下，如果元素类型是一个类类型，那么该类型必须有一个默认构造函数，
以使值初始化能够进行:
		array<int,10> ial;	//10个默认初始化的int
		array<int,10> ia2 = {0,1,2,3,4,5,6,7,8,9};//列表初始化
		array<int,10> ia3 = {42};	//ia3[0]为42
值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但是array并无此限制:
		int digs[10] = {0,1,2,3,4,5,6,7,8,9};
		int cpy[10] = digs;	//错误：内置数组不支持拷贝或赋值
		array<int,10>digts = {0,1,2,3,4,5,6,7,8,9};
		array<int,10>copy = digits;//正确：只要数组类型匹配即合法
与其他容器一样，array也要求初始值的类型必须与要创建的容器类型相同。此外array还要求元素类型和大小也
都一样，因为大小是array类型的一部分。

9.2.5	赋值和swap

	表9.4中列出的与赋值相关的运算符可用于所有容器。赋值运算符将其左边容器中的全部元素替换为右边容器
中元素的拷贝:
		c1 = c2;	//将c1的内容替换为c2中元素的拷贝
		c1 = {a,b,c};	//赋值后，c1的大小为3
第一个赋值运算后，左边容器将与右边容器相同。如果两个容器原来大小不同，赋值运算后面两者的大小都与右边容
器的原大小相同。第二个赋值运算后，c1的size变为3，即花括号中列表中值的数目。（不论c1以前的大小是多少)。
	与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型:
		array<int,10>a1 = {0,1,2,3,4,5,6,7,8,9};
		array<int,10>a2 = {0};
		a1 = a2;	//替换a1中的元素
		a2 = {0};	//错误：不能将一个花括号列表赋予数组！！！
由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的
值列表进行赋值。
				表9.4:	容器赋值运算
		c1=c2			将c1中的元素替换为c2中元素的拷贝，c1和c2必须具有相同的类型
		c={a,b,c,....}	将c1中元素替换为初始化列表中元素的拷贝（array除外!!)
		swap(c1,c2)		交换c1和c2中的元素，c1和c2必须具有相同的类型，swap通常比
						c2向c1拷贝元素快的多
		c1.swap(c2)		同上
			assign	操作不适用于关联容器和array
		seq.assign(b,e)	将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b
						和e不能指向seq中的元素
		seq.assign(i1)	将seq中的元素替换为初始化列表i1中的元素
		seq.assign(n,t)	将seq中的元素替换为n个值为t的元素
注意:
	赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致
指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）。
这里笔者认为，之所以赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效，是因为，赋值的时候，
系统有可能会把原来的左边的容器完全删除掉，然后再进行赋值操作，所以原先的容器的内存空间发生了变化，那
么所有的指针，引用以及迭代器就会失效。但是swap也许不会去动内存空间，所以不会失效。

使用assign(仅顺序容器)

	赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。
顺序容器（array除外)还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的
一个子序列赋值。assign操作用参数所指定的元素(的拷贝)替换左边容器中的所有元素。例如，我们可以用
assign实现讲一个vector中的一段char *赋予一个list中的string:
		list<string> names;
		vector<const_char *>oldstyle;
		names = oldstyle;	//错误:容器类型不匹配
		//正确:可以将const_char*转换为string
		names.assgin(oldstyle.cbegin(),oldstyle.cend());
这段代码中对assign的调用将names中的元素替换为迭代器指定的范围中的元素的拷贝。assign的参数决定了
容器中将有多少个元素以及它们的值是什么。
注意:
	由于其旧的元素被替换，因此传递给assign的迭代器不能调用assign的容器。
	assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有
的元素:
		//等价于slits1.clear()
		//后跟slist1.insert(slist1.begin(),10,"Hiya!");
		list<string> slist1(1);	//1个元素，为空string
		slist1.assig(10,"Hiya!");//10个元素，每个都是Hiya!
都是将原先的数据替换成新的数据！

使用swap

	swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换:
		vector<string> svec1(10);	//10个元素的vector
		vector<string> svec2(24);	//24个元素的vector
		swap(svec1,svec2);
调用swap后，sve1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内
容的操作保证会很快－－－元素本身并未交换，swap只是交换了两个容器的内部数结构。
除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间完成。
	元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后，都不会失
效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。如，
假定iter在swap之前指向svec[3]的string，那么在swap之后它指向svec1[3]的string，那么在swap之
后指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。
	与其它容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中
元素的数目成正比。在新标准库中，容器既提供成员函数版本的swap，也提供非成员版本的swap。而早起的标准
库版本只提供成员函数版本的swap。非成员库版本的swap在泛型编程中是非常重要的，统一使用非成员版本的
swap是一个好习惯。

9.2.6	容器大小操作

	除了一个例外，每个容器迭代器都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty
当size为0的时候返回布尔值true，否则返回flase；max_size返回一个大于或等于该类型容器所能容纳的最
大元素数的值。forward_list支持max_size和empty，但不支持size，原因我们将在下一节解释。

9.2.7	关系运算符

	每个容器类型都支持相等运算符(==和!=)；除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)
关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。即，我们只能将一个vector
<int>与另一个vector<int>进行比较，而不能将一个vector<int>与一个list<int>或一个vector<double>
进行比较。
	比较两个容器实际上是进行元素的逐对比较。这些元素符的工作方式与string的关系运算符类似:
		>>>>如果两个容器具有相同大小且所有元素都两两对应相等；否则两个容器不等
		>>>>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应的元素，则较小容器小于
较大容器
		>>>>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比
较结果

9.3	顺序容器操作

	顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、
添加以及删除。上一节介绍了所有容器都支持的操作。本章剩余部分将介绍顺序容器特有的操作。

9.3.1	向顺序容器添加元素

	除array外，所有标准库容器都提供灵活的内存管理。在运行　时可以动态添加琥或删除元素来改变容器大小。
				表9.5:向顺序容器添加元素的操作
这些操作会改变容器的大小:array不支持这些操作
	forward_list有自己专有版本的insert和emplace;
	forward_list不支持push_back和emplace_back。
	vector和string不支持push_front和emplace_front
	c.push_back(t)		 在c的尾部创建一个值为t或args创建
	c.emplace(args)		　的元素，返回void

	c.push_front(t)		　在c的头部创建一个值为t或args创建
	c.emplace_front(args)的元素，返回void

	c.insert(p,t)		 在迭代器p指向的元素之前创建一个值
	c.emplace(p,args)	 为t或由args创建的元素，返回指向新
						　添加的元素的迭代器
	c.insert(p,n,t)		 在迭代器p指向的元素之前插入n个值
						 为t的元素。返回指向新添加的第一个
						　元素的迭代器:若n为0，则返会p
	c.insert(p,b,e)		　将迭代器b和e指定的范围内的元素插
						　入到迭代器p指向的元素之前。b和e
						 不能指向c中的元素。返回指向新添加
						　的第一个元素的迭代器；若范围为空
						　则返回p
	c.insert(p,i1)		 i1是一个花括号包围的元素值列表。
						　将这些给定值插入到迭代器p指向的元
						　素之前。返回指向新添加的第一个元
						　素的迭代器，若列表为空，则返回p.
注意
	向一个vector，string或deque插入元素会使所有指向容器的迭代器，引用和指针失效！！因为插入会导致
内存空间发生变化了！
	当我们使用这些操作时，必须记得不同容器使用不同的策略来分配元素空间，而这些策略直接影响性能。在一个
vector或string的尾随之外的任何位置，或是一个deque的首尾之外的任何位置添加元素，都需要移动元素。而且
向一个vector或string添加元素可能引起存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，
并将元素从旧的空间移动到新的空间中。

使用push_back

	我们看到push_back将一个元素追加到一个vector的尾部。除array和front_list之外，每个顺序容器
（包括string类型）都支持push_back。例如下面的循环每次读取一个string到word中，然后追加到容器尾部:
		//从标准输入中读取数据，将每个单词放到容器末尾
		string word;
		while(cin>>word)
			container.push_back(word);
对push_back的调用在container尾部创建了一个新的元素，将container的size增加了1。该元素的值
为word的一个拷贝。container的类型可以是list、verctor或deque。由于string是一个字符容器，我
们也可以使用push_back在string末尾添加字符:
		void pluralize(size_t cnt,string &word)
		{
			if (cnt > 1)
				word.push_back('s');//等价于word+='s';
		}
关键概念:容器元素是拷贝
	当我们用一个对象来初始化容器时，或将一个对象插入到容器时，实际上放到容器中的是对象值的一个拷贝，而
不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后
对容器中元素的任何改变都不会影响到原始对象，反之亦然。

使用push_front

	除了push_back,list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素
插入到容器头部:
		list<int>ilist;
		//将元素添加到ilist开头
		for(size_t ix = 0;ix != 4;++ix)
			ilist.push_front(ix);
此循环将元素0,1,2,3添加到ilist头部。每个元素都插入到list新的开始位置(new beginning)。即当我们插
入1的时候，它会被放置在0之前，2被放置到1之前，依次类推。因此，在循环中以这种方式将元素添加到容器中，最
终会形成逆序。在循环执行完毕后，ilist保存在序列3,2,1,0。
	注意，deque像vector一样提供了是随机访问元素的能力，但它提供了vector所不支持的push_front。
deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首尾之外的位置
插入元素会很耗时。

在容器中的特定位置添加元素

	push_back和push_front操作提供了一种方便在顺序容器尾部或头部插入单个元素的方法。insert成员提
供了更一般的添加功能，它允许我们容器中任意位置插入0个或多个元素。vector、deque、list和string都
支持insert成员。forward_list提供了特殊版本的insert成员。我们将在后边介绍。
	每个insert函数都接受一个迭代器作为其第一个从参数。迭代器指出了在容器中什么位置放置新元素。它可以
指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而
且在容器开始位置插入元素是很有用的功能，所以insert函数将元素插入到迭代器所指定的位置之前，例如，下面的语句
		slist.insert((iter,"Hello");
将一个值为"Hello"的string插入到iter指向的元素之前的位置。虽然某些容器不支持push_front操作，但他们对于
insert操作并无类似的限制（插入开始位置）。因此我们可以将元素从插入到容器开始位置，而不必担心容器是否支持
push_front:
		vector<string> svec;
		list<string> slist;
		//等价于调用slist.push_front("Hello!");
		slist.insert(slist.begin(),"Hello");
		//vector不支持push_front，但我们可以插入到begin()之前
		//警告：输入到vector末尾之外的任何位置都可能很强
		svec.insert(svec.begin(),"Hello");
注意:
	将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。

插入范围内元素

	除了第一个迭代器参数之外，insert函数还可以接受更多的参数，这与容器构造函数类似。其中一个版本接受
一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化:
		svec.insert(svec.end(),10,"Anna");
这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string"Anna"。接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前:
		vector<string>	v = {"quasi","simba","frollo"};
		//将v的最后两个元素添加到slist的开始位置
		slist.insert(slist.begin(),v.end()-2,v.end());
		slist.insert(slist.end(),{"these","words","will","go","at","the","end"};
		//运行时错误:迭代器表示要拷贝的范围，不能指向与目前位置相同的容器!!!!
		slist.insert(slist.begin(),slist.begin(),slist.end());
注意:
	如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器！！
	在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。（在旧版本的标准库中，
这些操作返回void）如果范围为空，不插入任何元素，insert操作将会将第一个参数返回。

使用insert的返回值

	通过使用insert的返回值，可以在容器中一个特定位置反复插入元素:
		list<string> lst;
		auto iter = lst.begin();
		while(cin>>word)
			iter = lst.insert(iter,word);//等价于调用push_front
在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所
指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter并重复循环，读取下
一个单词。只要继续有单词读入，每步while循环就会将一个新元素插入到iter之前，并将iter改变为新加入元素的
位置。此元素为（新的）首元素。因此，每步循环讲一个新元素插入到list首元素之前的位置。

使用emplace操作

	新标准引入了三个新成员---emplae_front,emplace和emplace_back，这些操作构造而不是拷贝
元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前
或容器尾部。当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当
我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的
内存空间中直接构造元素。例如，假定c保存Sales_data元素:
		//在c的末尾构造一个Sales_data对象
		//使用三个参数的Sales_data构造函数
		c.emplace_back("934-44532",2,34.3);
		//错误:没有接受三个参数的push_back版本
		c.push_back("9993-323",2,34.3);
		//正确:创建一个临时的Sales_data对象传递给push_back
		c.push_back(Sales_data("423",2,34.3));
其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象，在调用emplae_back时，
会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。
	emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配:
		//iter指向c中一个元素，其中保存了Sales_data元素
		c.emplace_back();//使用Sales_data的默认构造函数
		c.emplace(iter,"999-99999");//使用的是Sales_data(string的构造函数
		c.emplace_front("999999-33",32,323.3);//使用的是Sales_data的完整的构造函数
注意:
	emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。

9.3.2	访问元素

	表9.6列出了我们可以用来在顺序容器中访问元素的操作。如果容器中没有元素，访问操作的结果是未定义的。
包括array在内的每一个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有
一个back成员函数。这两个操作分别返回首元素和尾元素的！！引用:
		//在解引用一个迭代器或调用front或back之前检查是否有元素
		if(!c.empty()){
			//val和val2是c中第一个元素值的拷贝
			auto val = *c.begin(),val2 = c.front();
			//val3和val4是c中最后一个元素值的拷贝
			auto last = c.end();
			auto val3 = *(--last);//不能递减forward_list迭代器
			auto val4 = c.back();//forward_list不支持
		}
注意:front和back都是返回引用！！
这个程序需要值得注意的是:迭代器end指向的是容器尾元素之后的（不存在的）元素。为了获取尾元素，必须首先递
减此迭代器。另一个重要之处是，在调用front和back(或解引用begin和end返回的迭代器）之前，要确保c非空。
如果容器为空，if中操作的行为将是未定义的。
			表9.6		在顺序容器中访问元素的操作
		at和下标操作只适用于string、vector、deque和array
		back不适用于forward_list
		c.back()			返回c中尾元素的引用，若c为空，函数行为未定义
		c.front()			返回c中首元素的引用，若c为空，函数行为未定义
		c[n]				返回c中下标为n的元素的引用，n是一个无符号整数。若
							n>=c.size()，则函数的行为未定义
		c.at(n)				返回下标为n的元素的引用。如果下标越界，则抛出一
							out_of_range异常
注意:
	对一个空容器调用frontt和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。

访问成员函数返回的是引用

	在容器中访问元素的成员函数(即，front,back,下标和at)返回的都是引用。如果容器是一个const对象，
则返回值是const的引用。如果容器不是const的，则返回的值是普通引用，我们可以用来改变元素的值:
		if(!c.empty()){
			c.front() = 42;		//将42赋予c中的第一个元素
			auto &v = c.back();	//获得指向最后一个元素的引用
			v = 1024;			//改变c中的元素
			auto v2 = c.back();	//v2不是一个引用，它是c.back()的一个拷贝
			v2 = 0;				//没有改变c中的元素
		}
与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将
变量定义为引用类型。

下标操作和安全的随机访问

	提供快速随机访问的容器(string、vector、deque和array)也都提供下标运算符。就像我们已经看到过
的那样，下标运算符接受一个下标参数，返回容器中该位置的元素的引用，给定下标必须“在范围内”。
	如果我们希望确保下标是合法的，可以使用at成员函数，at成员函数类似下标运算符，但如果下标越界，at
就会抛出一个out_of_range异常:
		vector<string> svec;
		cout<<svec[0];	//运行时错误，svec中没有元素
		cout<<svec.at(0);//抛出一个out_of_range异常

9.3.3	删除元素

	与添加元素的多种方式类似，(非array)容器也有多种删除元素的方式
				表9.7:	顺序容器的删除操作
		这些迭代操作会改变容器的大小，所以不适用于array!!!!
		forward_list有特殊版本的erase
		forward_list不支持pop_back;vector和string不支持pop_front

		c.pop_back()		删除c中尾元素。若c为空，则函数行为未定义，函数返回void
		c.pop_front()		删除c中首元素，若c为空，则函数行为未定义，函数返回void
		c.erase(p)			删除迭代器p所指定的元素，返回一个指向被删除元素之后元素
							的迭代器，若p指向尾元素，则返回尾后迭代器，若p是尾后迭
							代器，则函数行为未定义
		c.erase(b,e)		删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被
							删除元素之后迭代器，若e本身就是尾后迭代器，则函数也返回
							尾后迭代器
		c.clear()			删除c中所有的元素，返回void
注意:
	删除deque中除首尾位置之外的任何元素都会使用所有迭代器、引用和指针失效。指向vector或string中删
除点之后位置的迭代器、引用和指针都会失效。
	之所以会失效，是因为删除操作会导致内存空间发生变化，那么以前保存的地址都会发生变化，也就会失效
注意:
	删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保他们是存在的。

pop_front和pop_back成员函数

	pop_front和pop_back成员函数分别删除首元素和尾元素。与vector和string不支持push_front一样，
这些类型也不支持pop_front。类似的，forward_list不支持pop_back。与元素访问成员函数类似不能
对一个空容器执行弹出操作。
	这些操作返回void。如果你需要弹出的元素的值，就必须在执行弹出之前保存它。

从容器内部删除一个元素

	成员函数erase从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素；也可以删除由一对迭
代器指定范围内所有的元素。两种形式的erase都返回指向删除的(最后一个)元素之后位置的迭代器。即，若j是i之后的元素，那么erase(i)将返回指向j的迭代器。
例如，下面的循环删除一个list中所有的奇数元素:
		list<int> lst = {0,1,2,3,4,5,6,7,8,9};
		auto it = lst.begin();
		while(it != lst.end()){
			if(*it % 2)
				it = lst.erase(it);
			else
				++it;
		}

删除多个元素

	接受一对迭代器的erase版本允许我们删除一个范围内的元素:
		//删除两个迭代器表示的范围内的元素
		//返回指向最后一个被删除元素之后位置的迭代器
		elem1 = slist.erase(elem1,elem2);
迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置！！！
	为了删除一个容器中的所有元素，我们既可以调用clear，也可以使用begin和end获得迭代器作为从参数使用erase
		slist.clear();		//删除容器中所有的元素
		slist.erase(slist.begin(),slist.end());

9.3.4	特殊的forward_list操作

	为了理解forward_list为什么有特殊版本的添加和删除操作，考虑当我们从一个单向链表中删除一个元素
时会发生什么。如图9.1所示，删除一个元素会改变序列中的链接。在此情况下，删除elem3,会改变elem2，
elem2原来指向elem3，但删除elem3后，elem2指向了elem4。
		elem1-->elem2-->elem3-->elem4
		elem1-->elem2---------->elem4
当添加或删除一个元素时，删除或添加的元素之前的那个元素的后会发生改变。为了添加或删除一个元素，我们需
要访问其前驱，以便改变前驱的链接。但是forward_list使用一个单向链表。在一个单向链表中，没有简单的方
法来获取一个元素的前驱。出于这个原因，在一个forward_list中添加或删除元素的从操作是通过改变给定元素
之后的元素来完成的。这样我们总是可以访问到被添加或删除操作所影响的元素。
	由于这些操作与其他容器上的操作的实现方式不同，forward_list并未定义insert、emplace和erase，
而是定义了名为insert_after、emplace_after和erase_after的操作。例如，在我们的例子中，为了删
除elem3，应该
用指向elem2的迭代器调用erase_after。为了支持这些操作，forwrd_list也定义了before_again，
它返回一个首前迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素之后添加或删除元素（也就是在链表
首元素之前添加或删除元素）。
			表9.8:	在forward_list插入或删除元素的操作
		lst.before_begin()		返回指向链表首元素之前不存在的元素的迭代器。此迭代器
								不能解引用。
		lst.cbefore_begin()		返回一个const_iterator

		lst.insert_after(p,t)	在迭代器p之后的位置插入元素。t是一个对象，n是
		lst.insert_after(p,n,t) 数量，b和e是表示范围的一对迭代器(b和e不能指向
		lst.insert_after(p,b,e)	lst内），il是一个花括号列表，返回一个指向最后
		lst.insert_after(p,il)	一个插入元素的迭代器。如果范围为空，则返回p。若
								p为尾后迭代器，则函数行为未定义。

		emplace_after(p,args)	使用args在p指定的位置之后创建一个元素。返回一
								个指向这个新元素的迭代器。若p为尾后迭代器，
								则函数行为未定义
		lst.erase_after(p)		删除p指向的位置之后的元素，或删除从b之后直
		lst.erase_after(b,e)	到（但不包含）e之间的元素。返回一个指向被删
								元素之后元素的迭代器，若不存在这样的元素，则
								返回尾后迭代器，如果p指lst的尾元素或者是一
								个尾后迭代器，则函数行为未定义

	当在forward_list中添或删除元时，我们必须关注两个迭代器--一个指向我们需要处理的元素，另一个指向
其前驱。例如，可以改写312页中从list中删除奇数元素的循环程序，将其改为从forward_list中删除元素:
		forward_list<int>flst = {0,1,2,3,4,5,6,7,8,9};
		auto prev = flst.befor_begin();
		auto curr = flst.begin();
		while(curr != flst.end()){
			if(*curr % 2)
				curr = flst.erase_after(prev);
			else{
				prev = curr;
				++curr;
			}
		}
此例中，curr表示我们要处理的元素，prev表示curr的前驱。调用begin来初始化curr，这样第一步循环
就会检查第一个元素是否是奇数。我们使用befor_begin来初始化prev，它返回指向curr之前不存在的元
素迭代器。当找到奇数元素之后，我们将prev传递给erase_after。此调用将prev之后的元素的元素删除，即
删除curr指向的元素。然后我们将curr重置为erase_after的返回值，使得curr指向序列中下一个元素，
prev保持不变，仍指向新curr之前的元素。如果curr指向的元素不是奇数，在else中我们将两个迭代器都向
前移动。
小结:
	before_begin()其实就是链表中的header部分；删除的方式其实就是链表的方式，可以画图来描述一下！

改变容器大小

	如表9.9所描述，我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小
大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部:
		list<int>ilist(10,42);		//10个int，每个值都是42
		ilist.resize(15);			//将5个值为0的元素添加到ilist的末尾
		ilist.resize(25,-1);		//将10个值为-1的元素添加到ilisttt的末尾
		ilist.resize(5);			//从ilist末尾删除20个元素
resize操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。新元素进行值初始化。如果容器保存的
是类类型元素，且resize向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数。
			表9.9	顺序容器大小操作
		resize不适用于array
		c.resize(n)		调整c的大小为n个元素。若n<c.size()，则多出的元素被丢弃若必须
					添加新元素，对新元素进行值初始化
		c.resize(n,t)	调整c的大小为n个元素。任何新添加的元素都初始化为值t
注意
	如果resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对vector、string或deque进行
resize可能会导致迭代器、指针和引用失效。

9.3.6	容器操作可能会使迭代器失效

	向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、
引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未
初始化指针一样的问题:
	在向容器中添加元素后:
		>>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器，指针和引用都会失效。
如果存储空间未重新分配，指向插入位置之前的元素迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、
指针和引用将会失效。
		>>对于deque，插入到除首尾元素之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添
加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
		>>对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍然有效。
当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟这些元
素都已经被销毁了。当我们能删除一个元素后:
		>>对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器首前迭代器）、引用和指
针仍有效
		>>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除出元素外其他元素的迭代器、引用
或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果
是删除首元素，这些也不会受影响。
		>>对于vector和strinng，指向被删元素之前的迭代器、引用和指针仍有效。注意:当我们删除元素时，
尾后迭代器总会是失效的。

编写改变容器的循环程序

	添加/删除vector、strin或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须
保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容易。
这些操作都返回迭代器，我们可以用来更新:
		//删除偶数元素，复制奇数元素
		vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
		auto iter = vi.begin();
		while(iter != vi.end()){
			if(*iter % 2){
				iter = vi.insert(iter,*iter);	//复制当前元素
				iter += 2;//因为insert返回的迭代器是插入元素的位置，而insert表示在iter
之前插入元素。所以得往后走两个位置
			}else
				iter = vi.erase(iter);	//删除当前位置，然后返回删除元素之后的元素。
		}
注意:此程序在调用insert和erase后，都更新了迭代器，因为两者都会使迭代器失效。

不要保存end返回的迭代器

	当我们添加或/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end
返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代
器，一直当作容器末尾使用。通常C++标准库的实现中end()从操作很快，部分就是因为这个原因。
	例如，考虑这样一个循环，它处理容器中的每一个元素，在其后添加一个新元素。只处理原有的元素，在每步循环之
后，我们呢将定位迭代器，使其指向下一个原有元素。如果我们试图“优化”这个循环，在循环之前呢保存end()返回的
迭代器，一直用作容器末尾，就会导致一场灾难:
		auto begin = vi.begin();
		auto end = vi.end();
		while(begin != end){
			//做一些处理
			//插入新值，对begin重新赋值，否则的话它就会失效
			++begin;
			begin = vi.insert(begin,42);
			++begin;
		}
此代码的行为是未定义的。在很多标准库实现上，此代码会导致无限循环呢。问题在于我们将end操作返回的迭代
器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭
迭代器失效了。这个迭代器不再指向v中任何元素，或是v中尾元素之后的位置。
注意:
	如果在一个循环中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器。
必须在每次插入操作后重新调用end()，而不能在循环开始前保存它返回的迭代器:
		//更安全的方法:在每个循环步添加/删除元素后都重新计算end
		while(begin != vi.end()){
			//做一些处理
			++begin;
			begin = vi.insert(begin,42);
			++begin;
		}

9.4	vector对象是如何增长的

	为了支持快速随机访问，vector将元素连续存储－－每个元素紧挨着前一个元素存储。通常情况下，我们不必
关心一个标准库类型是如何实现的，而只需关心它如何使用。然而，对于vector和string，其部分实现渗透到了接
口中。假定容器中元素是连续存储的，且容器大小是可变的。考虑向vector或string中添加元素会发生什么:
如果没有空间容纳新的元素，容器不可能简单地将它添加到内存中其他位置－－因为元素必须是连续存储。容器必须
分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空
间。如果我们每添加一个新元素，vector就执行一次这样的内存分配和释放操作，性能会慢到不可接受。
	为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新内存空间时，
vector和string的实现通常会分配比新空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多
新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。这种分配策略比每次添加新元素都重新分
配容器内存空间的策略要高效很多，其实际性能也表现的足够好－－虽然vector在每次重新分配空间时都要移动
所有元素，但使用此策略后，其扩张操作通常比list和deque还要快。

管理容量的成员函数

	如表9.10所示，vector和string类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动。
capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素。reserve操作允许我们通知容器它
应该保存多少个元素。
			表9.10	容器大小管理操作
		shrink_to_fit		只适用于vector、strinng和deque
		capacity和reserve只适用于vector和string
		c.shrink_to_fit()	请将capacity()减少为size()相同大小
		c.capacity()		不重新分配内存空间的话，c可以保存多少元素。
		c.reserve(n)		分配至少能容纳n个元素的内存空间。
reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。
	只有当需要的内寸空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前
容量，reserve至少分配与需求一样大的内存空间（可能更大）。如果需求大小小于或等于当前容量，reserve
什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，
capacity将会大于或等于传递给reserve的参数。这样，调用reserve永远也不会减少容器占用的内
存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来
减少容器预留的内存空间。
	在新标准库中，我们可以使用shrink_to_fit来要求deque、vector或string退回不需要的内存空
间。此函数指出我们不需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求，也就是说，调用
shrink_to_fit也并不保证一定退回内存空间。

capacity和size
	理解capacity和size的区别很重要。容器的size是指它已经保存的元素的数目；而capacity则是在不分配
新内存空间的前提下它最多可以保存多少元素。下面的代码展示了size和capacity之间的相互作用:
		vector<int>	ivec;
		//size应该为0；capacity的值依赖于具体实现
		cout<<"ivec: size :"<<ivec.size()
			<<"capacity: "<<ivec.capacity()<<endl;
		//向ivec添加24个元素
		for(vector<int>::size_type ix = 0;ix != 24;++ix)
			ivec.push_back(ix);
		//size应该为24;capacity的值应该大于等于24
		cout<<"ivec : size :"<<ivec.size()
			<<"capacity: " <<ivec.capacity()<<endl;
		size :0capacity:0
		size :24capacity:32
这里的capacity的大小是系统的标准库分配的！！
注意:
	每个vector实现都可以选择自己的内存分配策略，但所有实现都应该遵循一个原则:只有当迫不得已的时候
才可以分配新的内存空间。
	只有在执行insert操作时size与capacity相等，或者调用resize或reserve时给定大小超过当前
capacity，vector才能重新分配内存空间。分配多少超过给定容量的额外空间，取决于具体实现。虽然不同的
实现可以采用不同的分配策略，但所有实现都应该遵循一个原则:确保用push_back向vector添加元素的操作有
高效率。从技术角度来说，就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector，
所花费的时间不能超过n的常量数倍。

9.5	额外的string操作
9.5.1	构造string的其他方法
	除了我们在3.2.1节中已经介绍过的构造函数，以及与其他顺序容器相同的构造函数外，string类型还支持另外
三个构造函数:
			表9.11:	构造string的其他方法
	n、len2和pos2都是无符号值
	string(cp,n)			s是cp指向数组中前n个字符的拷贝。此数组至少应该包含n个字符。
	string(s2,pos2)			s是string s2从下标pos2开始的字符的拷贝。若pos2>s2.size()
							构造函数的行为未定义
	string(s2,pos2,len2)	s是strinng　s2从下标pos2开始len2个字符的拷贝。若pos2>
							s2.size(),构造函数的行为没有定义。不管len2的值多少，构造
							函数至多拷贝s2.size()-pos2个字符
这些构造函数接受一个string或一个const char*参数，还接受(可选的)指定拷贝多少个字符的参数。当我们
传递给他们的是一个string时，还可以给定一个下标来指出从哪里开始拷贝:
		const char *cp = "Hello World";	//以空字符结束的数组
		char noNull[] = {'H','i'};		//不是以空字符结束
		string s1(cp);	//拷贝cp中的字符直到遇到空字符:s1=="Hello World"
		string s2(noNull,2);	//从noNull拷贝两个字符:s2=="Hi"
		string s3(noNull);	//未定义:noNull不是以空字符结束
		string s4(cp+6,5);	//从cp[6]开始拷贝5字符：s4=="World"
		string s5(s1,6,5);	//从s1的第7个元素开始拷贝，也就是s1[6]:s5=="World"
		string s6(s1,6);	//从s1[6]开始拷贝，直至末尾
		string s7(s1,6,20);	//只拷贝到s1的末尾:s7=="World"
		string s8(s1,16);	//错误，抛出一个out_of_range异常。
当我们从一个const char*创建string时，指针指向的数组必须以空字符结束，拷贝操作遇到空字符时停止。
如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未以空字符
结尾，或者给定的计数值大于数组大小，则构造函数的行为未定义。
注意是未定义的:如果你在编程的时候，计数值超过了数组的大小，但是没有出现问题，那也不要庆幸，因为这
个是编译器的问题。所以我们还是要记住这个操作是未定义的！
	当从一个string拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开始值必须小于或等于给
定的string的大小。如果位置大于size，则构造函数抛出一个out_of_range异常。如果我们传递了
一个计数值，则从给定位置开始拷贝这么多个字符。不管我们要求拷贝多少个字符，标准库最多拷贝到string的
结尾，不会更多。

substr操作

	substr操作返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substring一个可
选的开始位置和计数值:
		string s("Hello world");
		string s2 = s.substr(0,5);	//s2 = hello
		string s3 = s.substr(6);	//s3 = world
		string s4 = s.substr(6,11);	//s4 = world;
		string s5 = s.substr(12);	//抛出一个out_of_range异常
如果开始位置超过了string的大小，则substr函数抛出一个out_of_range异常。如果开始位置加上
计数值大于string的大小，则substr会调整计数值，只拷贝到string的末尾。
		s.substr(pos,n)		返回一个string，包含s中从pos开始的n个字符的拷贝，pos
							的默认值为0。n的默认值是s.size()-pos,即拷贝从
							pos开始的所有字符

9.5.2	改变string的其他方法

	string类型支持顺序容器的赋值运算符以及assign、insert和erase操作。除此之外，它还定义了额外
的insert和erase版本。除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标
指出了开始删除的位置，或是insert到给定值之前的位置"
		s.insert(s.size(),5,'!');	//在s的末尾插入5个感叹号
		s.erase(s.size()-5,5);		//从s删除最后5个字符
注意:
	这个是除数字下标的insert，不跟以前的那种带有迭代器的insert一样。第一个位置的数字代表的
是下标位置。
标准库strinng类型还提供了接受C风格字符数组的insert和assign版本。例如，我们可以将以空字符结尾的字
符数组insert到或assign给一个string:
		const char *cp = "stately, plump Buck";
		s.assign(cp,7);			//s == "Stately"
		s.insert(s.size(),cp+7);//s == "Stately,plump Buck"
此处我们首先通过调用assign替换s的内容。我们赋予s的是从cp指向的地址开始的7个字符。要求赋值的字符数必
须小于或等于cp所指向的数组中的字符数（不包括结尾的空字符）。接下来在s上调用insert，我们的意图是将字
符插入到s[size()]处（不存在的）元素之前的位置。在此例中，我们将cp开始的7个字符（至多到结尾空字符之前）
拷贝到s中。
	我们也可以指定将来自其他strinnng或子字符串的字符插入到当前string中或赋予当前string:
		string s = "Some string",s2 = "some other string";
		s.insert(0,s2);//在s中位置0之前插入s2的拷贝。
		s.insert(0,s2,0,s2.size());//这个就是将其他string的子字符串插入给别的string

append和replace函数

	string类定义了两个额外的成员函数:append和replace，这两个函数可以改变string内容。表9.13
描述了这两个函数的功能。append操作是在string末尾进行插入操作的一种简写形式:
		string s("C++ Primer"),s2 = s;
		s.insert(s.size()," 4th Ed.");//	s == "C++ Primer 4th Ed."
		s2.append(" 4th Ed");//等价的方法
replace操作是调用erase和insert的一种简写形式:
		//将"4th"替换为"5th"的等价方法
		s.erase(11,3);		//s="C++ Primer Ed."
		s.insert(11,"5th");	//s="C++ Primer 5th Ed."
		//从位置11开始，删除3个字符并插入"5th"
		s2.replace(11,3,"5th");
此例中调用replace时，插入的文本恰好与删除的文本一样长。这不是必须的，可以插入一个更长/短的string：
		s.replace(11,3,"Fifth");//s=="C++ Primer Fifth Ed."
在此例中，11表示的是你想要替换的初始位置,3表示的是你要替换几个字符，最后一个表示的是，你用什么字符来
替换。
			表9.13		修改string操作
	s.insert(pos,args)		在pos之前!!插入args指定的字符。pos可以是一个下标
							或一个迭代器。接受下标的版本返回一个指向s的引用；
							接受迭代器的版本返回指向的第一个插入字符的迭代器
	s.erase(pos,len)		删除从位置pos开始的len个字符，如果len被省略，则
							删除从pos开始直至s末尾的所有字符。返回一个指向s的引用
	s.assign(args)			将s中的字符替换为args指定的字符。返回一个指向s的引用
	s.replace(range,args)	删除s中范围range内的字符，替换为args指定的字符。
							range或者是一个下标和一个长度，或者是一对指向s的
							迭代器。返回一个指向s的引用。

args可以是下列形式之一;append和assign可以使用所有形式
str不能与s相同，迭代器b和e不能指向s。
	str						字符串
	str,pos,len				str中从pos开始最多len个字
	cp,len					从cp所指向的字符数组前（最多）len个字符
	cp						cp指向的一空字符结尾的字符数组
	n,c						n个字符c
	b,e						迭代器b和e指定的范围内的字符
	初始化列表				花括号包围的，以逗号分割的字符列表

replace和insert所允许的args形式依赖于range和pos是如何指定的
replace			replace			insert			insert		args可以是
(pos,len,args)	(b,e,args)		(pos,args)		(iter,args)

是				是				是				否			str
是				否				是				否			str,pos,len
是				是				是				否			cp,len
是				是				否				否			cp
是				是				是				是			n,c
否				是				否				是			b2,c2
否				是				否				是			初始化列表
注意:此表的右边args是用来替换相应的args的

改变string的多种重载函数

	表9.13列出了append、assign、insert和replace函数有多个重载版本。根据我们如何指定要添加的字符
和string中被替换的部分，这些函数的参数有多个不同版本。幸运的是，这些函数有共同的接口。append和assign
函数无须指定要替换string中哪个部分；assign总是替换string中所有的内容，append总是将新字符追加到string
末尾。
	replace函数提供了两种指定删除元素范围的方式。可以通过一个位置和一个长度来指定位置范围，也可以通过一
个迭代器范围来指定。insert函数允许我们用两种方式指定插入点:用一个下标或一个迭代器。在这两种情况下，新元
素都会插入到给定下标（或迭代器）之前的位置。
	可以用好几种方式来指定要添加到string中的字符。新字符可以来自另一个string，来自于一个字符指针（指
向字符数组），来自于一个花括号包围的字符列表，或者是一个字符和一个计数值。当字符来自于一个string或一个
字符指针时，我们可以传递一个额外的参数来控制是拷贝部分还是全部字符。

9.5.3	string搜索操作

	string类提供了6个不同的搜索函数，每个函数都有四个重载版本。表9.14描述了这些搜索成员函数及其参
数。每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名
为string::npos的static成员。标准库将npos定义成一个const string::size_type类型，并初始值为
-1。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小。（因为无符号类
型，所以-1直接变成最大正整数了）
注意:
	string搜索函数返回string::size_type值，该类型是一个unsigned类型。因此，用一个int或其他
带符号类型来保存这些函数的返回值不是一个好注意。
find函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个匹配位置的下标，否则返回npos:
		string names("AnnaBelle");
		auto pos1 = name.find("Anna");		//pos1 == 0
这段程序返回0，即子字符串"Anna"在"AnnaBelle"中第一次出现的下标。搜索（以及其他string操作）是大
小写敏感的。当在string中查找字符串时，要注意大小写:
		string lowercase("annabelle");
		pos1 = lowercase.find("Anna");	//pos1==npos
这段代码会将pos1置位npos，因为Anna与anna不匹配。
	一个更复杂一些的问题是查找与给定字符串中！！任何一个字符匹配！！的位置。例如，下面代码定位name
中的第一个数字:
		string numbers("0123456789"),names("r2d2");
		auto pos = name.find_first_of(numbers);
如果是要所搜第一个不在参数中的字符，我应该调用find_first_not_of。例如，为了搜索一个string中第
一个非数字字符，可以这样做:
		string dept("03714p3");
		//返回5---字符'p'的下标
		auto pos = dept.find_first_not_of(numbers);
		表9.14		string搜索操作
	搜索操作返回指定字符出现的下标，如果未找到则返回npos
	s.find(args)			查找s中args第一次出现的位置
	s.rfind(args)			查找s中args最后一次出现的位置
	s.find_first_of(args)	在s中查找args中任一个字符第一次出现的位置
	s.find_last_of(args)	在s中查找args中任一个字符最后一次出现的位置
	s.find_first_not_of(args)在s中查找第一个在args中的字符
	s.find_last_not_of(args)在s中查找最后一个不在args中的字符

args必须是以下形式之一:
	c,pos		从s中位置pos开始查找字符c，pos默认为0
	s2,pos		从s中位置pos开始查找字符串s2,pos默认为0
	cp,pos		从s中位置pos开始查找指针cp所指向的以空字符结尾的C风格字符串。pos默认为0
	cp,pos,n	从s中位置pos开始查找指针cp指向的数组的前n个字符,pos和n无默认

指定在哪里开始搜索

	我们可以传递给find操作一个可选的开始位置，这个可选的参数指出从哪个位置开始进行搜索。默认情况下，此
位置被置为0。一种常见的程序设计模式是用这个可选的参数在字符串中循环地搜索子字符串出现的所有的位置:
		string::size_type pos = 0;
		while((pos = name.find_first_of(numbers,pos)) != string::npos){
			cout<< "found number at index :"<<pos
				<< "element is "<<name[pos]<<endl;
			++pos;//移动到下一个字符
		}
while的循环条件将pos重置为从pos开始遇到的第一个数字的下标。只要find_first_of返回一个合法下标，我
们就打印当前结果并递增pos。如果我们忽略了递增pos，循环就永远也不会终止。为了搞清楚原因，考虑如果不做
递增会发生什么。在第二步循环中，我们从pos指向的字符开始搜索，这个字符是一个数字，以你find_first_of
会重复的返回pos!
注意:
	find中的第二个参数都是pos，表示的是从该位置出发去搜索相应的内容。

逆向搜索

	到现在为止，我们已经用过的find操作都是由左至右搜索。标准库还提供了类似的，但由右往左搜索的操作，
rfind成员函数搜索最后一个匹配，即字符串中最靠右的出现位置:
		string river("Mississippi");
		auto first_pos = river.find("is");	//返回1
		auto last_pos = river.find("is");	//返回4
find返回下标1，表示第一个"is"的位置，而rfind返回下标4表示最后一个"is"的位置。
	类似的，find_last函数的功能与find_first函数类似，只是它们返回最后一个而不是第一个匹配:
		find_last_of搜索与给定string中任何一个字符匹配的最后一个字符(其实就是从右往左找到第一个）
		find_last_not_of搜索最后一个不出现在给定string中的字符。
每个操作都接受一个可选的第二参数，可用来指出从什么位置开始搜索。

9.5.4	compare函数

	除了关系运算符外，标准库string类型还提供了一组compare函数，这些函数与C标准库的strcmp函数很
相似。类似strcmp，根据s是等于、大于还是小于参数指定的字符串，s.compare返回0、正数或负数。
	如表9.15所示,compare有6个版本，根据我们是要比较两个string还是一个string与一个字符数组，
参数各有不同。在这两种情况下，都可以比较整个或一部分字符串。
		表9.15		compare的几种参数形式
	s2					比较s和s2的内容
	pos1,n1,s2			将s中从pos1开始的n1个字符与s2进行比较
	pos1,n1,s2,pos2,n2	将s中从pos1开始的n1个字符与s2从pos2开始的n2个字符进行比较
	cp					比较s与cp指向的以空字符结尾的字符数组
	pos1,n1,cp			将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组
						进行比较
	pos1,n1,cp,n2		将s中从pos1位置开始的n1个字符与co指向的地址开始的n2个字符
						进行比较。

9.5.5	数值转换

	字符串中常常包含表示数值的字符。例如，我们用两个字符的string表示数值15--字符'1'后跟字符'5'。
一般情况，一个数的字符表示不同于其他数值。数值15如果保存为两个Latin-1编码的char，二进制位模式为0000 
0000 0000 1111，第一个字节表示字符'1'，其八进制值为061，第二个字节表示'5'，其Latin-1编码为八进制
065(ASIIC中对应的'5'的)。新标准中引入了多个函数，可以实现数值数据与标准库string之间的转换:
		int i = 42;
		string s = to_string(i);	//将整数i转换为字符表示形式
		double d = stod(s);			//将字符串转换为浮点数:stod --> string to double
此例中我们调用to_string将42转换为其对应的string表示，然后调用stod将此string转换为浮点数。
	要转换为数值的string中!!第一个非空白符!!必须是数值中可能出现的字符:
		string s2 = "pi = 3.14";
		//转换s中以数字开始的第一个子串，结果d=3.14
		d = stod(s2.substr(s2.find_first_of("+-.0123456789")));
在这个stod调用中，我们调用了find_first_of来获得s中第一个可能是数值的一部分的字符的位置。我们将
s中从此位置开始的子串传递给stod。stod函数读取此参数，处理其中的字符，直至遇到不可能是数值的一部分
的字符。然后它就找到的这个数值的字符串表示形式转换为对应双精度浮点值。string参数中第一个非空白字
符必须是符号(+或-)或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，
string参数也可以以小数点开头，并可以包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，
根据基数不同，string参数可以包含字母字符，对应大于数字9的数。
注意:
	如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值
无法用任何类型来表示，则抛出一个out_of_range异常。
		表9.16:	string和数值之间的转换
	to_string(val)		一组重载函数，返回数值val的string表示。val可以是
						任何算术类型。对每个浮点类型和int或更大的整型，都有相应版
						本的to_string。与往常一样，小整型会被提升。

	stoi(s,p,b)			返回s的起始子串（表示整数内容）的数值，返回类型分别是int
	stol(s,p,b)			、long、unsigned long、long　long、unsigned long
	stoul(s,p,b)		long。b表示转换所用的基数。默认的值为10。p是size_t指针
	stoll(s,p,b)		，用来保存s中第一个非数值字符的下标，p默认为0，即，函数
	stoull(s,p,b)		不保存下标。

	stof(s,p)			返回s的起始子串(表示浮点数内容的）的数值，返回类型是
	stod(s,p)			float、double或long double。参数p的作用与整型转换函
	stold(s,p)			数中一样

9.6容器适配器

	除了顺序容器外，标准库还定义了三个顺序容器适配器:stack、queue和priority_queue。适配器(adaptor)
是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器就是一种机制。能使某种事物的
行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如,
stack适配器接受一个顺序容器（除array或forward_list外），并使其操作起来像一个stack一样。表9.17列出了
所有容器适配器都支持的操作和类型。
		表9.17	所有容器适配器都支持的操作和类型
	size_type			一种类型，足以保存当前类型的最大对象的大小
	value_type			元素类型
	container_type		实现适配器的底层容器类型
	A a;				创建一个名为a的空适配器
	A a(c);				创建一个名为a的适配器，带有容器c的一个拷贝
	关系运算符			每个适配器都支持所有关系运算符:==、!=、<、<=、>和>=
	a.empty()			若a包含任何元素，返回false，否则返回true
	a.size()			返回a中的元素数目
	swap(a,b)			交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须
	a.swap(b)			相同

定义一个适配器

	每个适配器都定义两个构造函数，默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化
适配器。例如，假定deq是一个deque<int>，我们可以用deq来初始化一个新的stack，如下所示:
		stack<int>stk(deq);//	从deq拷贝元素到stk
默认情况下，stack和queue是基于deque实现的；priority_queue是在vector之上实现的，我们可以在创建一
个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型:
		//在vector上实现的空栈
		stack<string,vector<string>> str_stk;
		//str_stk2在vector上实现，初始化时保存svec的拷贝
		stack<string,vector<string>>str_stk2(svec);
对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，
适配器不能构造在array之上，类似的，我们也不能用forward_list来构造适配器，因为所有适配器都要求容器
具有添加、删除以及访问尾元素的能力。stack只要求push_back,pop_back和back操作，因
此可以使用除array和forward_listt之外的任何容器类型来构造stack。queue适配器要求back、
push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。
priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于
vector或deque之上，但不能基于list构造。

栈适配器

	stack类型定义在stack头文件中，表9.18列出了stack所支持的操作。下面的程序展示了如何使用stack:
		stack<int> intStack;//空栈
		//填满栈
		for(size_t ix = 0;ix != 10;++ix)
			intStack.push(ix);		//intStack保存0到9十个数
		while(intStack.empty()){
			int value = intStack.top();
			//使用栈顶值的代码
			intStack.pop();	//弹出栈顶元素，继续循环
		}
其中，声明语句
		stack<int> intStack;	//空栈
定义了一个保存整型元素的栈intStack，初始时为空。for循环将10个元素添加到栈中，这些元素被初始化为从
0开始连续的整数。while循环遍历整个stack，获取top值，将其从栈中弹出，直至栈空。
			表9.18	表9.17未列出的栈操作
栈默认基于deque实现，也可以在list或vector之上实现
	s.pop()			删除栈顶元素，但不返回该元素值
	s.push(item)	创建一个新元素压入栈顶，该元素通过拷
	s.push(args)	贝或移动item而来，或者由args构造
	s.top()			返回栈顶元素，但不讲其弹出栈
每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层
容器类型的操作。例如:
		intStack.push(ix);	//intStack保存0到9十个数
此语句试图在intStack底层的deque对象上
调用push_back。虽然stack是基于deque实现的，但是我们不能直接使用deque操作。不能在一个stack上调用
push_back，而必须使用stack自己的操作---push。

队列适配器

	queue和priority_queue适配器定义在queue头文件中。表9.19列出了它们所支持的操作。
		表9.19	表9.17未列出的queue和priority_queue操作
queue默认基于deque实现，priority_queque默认基于vector实现
queue也可以用list或vector实现，priority_queue也可以用deque实现
	q.pop()			返回queue的首元素或priority_queue的最高优先级的元素，但不删除此元素

	q.front()		返回首元素或尾元素，但不删除此元素
	q.back()		只适用于queue

	q.top()			但会最高优先级元素，但不删除该元素。只适用于priority_queue

	q.push(item)	在queue末尾或priority_queue中恰当的位置创建一个元素
	q.emplace(args)	其值为item或者args构造

	标准库queue使用一种先进先出(first-in,first-out,FIFO)的存储和访问策略。进入队列
的对象被放置到队尾。而离开队列的对象则从队首删除。饭店按客人到达的顺序来为它们安排座位，就是一个先进
先出队列的例子。
	priority_queue允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素
前。饭店按照客人预定时间而不是到来时间的早晚来为他们安排座位，就是一个优先队列的例子。默认情况下，在
标准库在元素类型是使用<运算符来确定相对优先级。
