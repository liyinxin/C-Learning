				第七章	类
内容
	7.1	定义抽象数据类型
	7.2	访问控制与封装
	7.3	类的其他特性
	7.4	类的作用域
	7.5	构造函数再探
	7.6	类的静态成员
  在C++中，我们使用类定义自己的数据类型，通过定义新的类型来反映待解决处理的各种概念。（这一点很重要，在C中，我们最复杂的数据类型就是结构体了，但是结构体中是不能包含函数的，所以就会有一定的限制。而在C++中，结构体就和类一样了，它可以具有相应的函数（行为），它可以使得数据表示的更加的完整，所以类就是一种更加完善的数据类型，这样就可以通过构造不同的类，来实现对不同问题的建模了）
  类的基本思想是 数据抽象（data abstraction) 和 封装（encapsulation)。数据抽象是一种依赖于 接口（interface）和 实现（implementation） 分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员，负责接口实现的函数体以及定义所需的各种私有函数。
  封装实现了类的 接口 和 实现 的分离，封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用 接口 而无法访问 实现 部分。（这里就像是，我们平常开发的时候，只是需要知道对方的API，我们却不知道对方的这个API的具体的实现一样。数据抽象是将你想要解决的问题进行一定的抽象成一定的数据模型，然后实现就是写一些具体的函数，变量成员来进行相应的问题的解决。而封装就是将 接口 和 实现 进行分离，使得类的用户只能使用相应的接口，却不能查看相应的 实现）


7.2	定义改进的Sales_data类
	struct Sales_data
	{
		std::string isbn() const { return bookNo; }
		Sales_data & combine(const Sales_data&);
		double avg_price() const;
		std::string bookNo;
		unsigned units_old = 0;
		double revenu = 0.0;
	}
	Sales_data add(const Sales_data&,const Sales_data&);
	std::ostream &print(std::ostream &,const Sales_data &);
	std::istream &read(std::istream &,const Sales_data &);
	如果一个函数成员并不是通用的，那么它应该属于类的实现的一部分，而不是接口，也就是说明如果是接口的话，那么接口一定是大家都通用的，也就是最基本的实现，其他的实现你根据自己的需求自己去重新定义相关的函数实现。
	定义和声明成员函数的方法与普通的函数差不多。不过注意：
		成员函数的声明必须得在类内部；而函数的实现可以在类内实现，也可以在类外边实现。但是作为接口组成部分的非成员函数，它们的声明和定义就必须在类的外部实现。
引入this
	std::string isbn() const {	return bookNo;	}
让我们再一次观察对isbn()成员函数的调用：
	totol.isbn();
当我们调用成员函数时，实际是在替某个对象调用它。如果isbn关联了Sales_data的成员（例如bookNo），则它隐式地指向调用该函数对象的成员。在上面的调用中，当isbn返回bookNo时，实际上它隐式的返回total.bookNo。
	成员函数通过一个名为this的额外 隐式参数 来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this，如果调用
		total.isbn();
则编译器负责把total的地址传递给isbn的隐式参数this（也就是让this指向total）可以等价的认为编译器将该调用重写成了如下的形式：
		//伪代码，用于说明调用成员函数的实际执行过程
		Sales_data::isbn(&total)
也就是说明，this指向的是一个调用该成员函数的一个对象，而且在类内的成员函数都是可以直接通过this隐式的访问到其成员函数变量的。
	在成员函数内部，我们可以直接使用调用该函数的 对象 的成员，而无需通过成员访问符来做到这一点，因为this所指的正是这个对象。任何类成员的直接访问都被看做this的隐式引用，也就是说，当isbn使用bookNo的时候，它隐式的使用this指向的成员，就像我们书写了this->bookNo一样。
	对于我们来说，this隐式形参是隐式定义定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，尽管没有必要，但我们还是能把isbn定义成如下形式：
			std::string isbn() const { return this->isbn};
因为this的目的总是指向“这个对象”，所以this是一个常量指针。我们不允许改变this中报存的地址。
引入const成员函数
	isbn函数的另一个关键之处是紧随参数列表之后的const关键字。这里，const的作用是修改隐式this指针的类型。
	默认情况下，this的类型是指向 类 类型（这个类类型不是常量）的常量指针。例如再Sales_data成员函数中，this的类型是Sales_data * const。也就是this的值是不能改变的。尽管this是隐式的，但是它还是要遵循初始化规则的，意味着（在默认情况下）我们不能在一个常量对象（因为常量的指针是不可以改变自己本身的值的，但是可以改变指向的对象的数值。所以，如果常量指针指向了常量对象，那么常量对象有可能被修改了。所以在C++，这样是错误的，不允许操作的。但是在C中，这样是非法的，但可以赋值）这一情况就使得我们不能在一个常量对象上调用普通的成员函数。
	如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data * const。毕竟,在isbn的函数体内不会改变this所指向的对象，所以把this设置成为指向常量的指针有助于提高函数的灵活性。
	然而，this是隐式的并且不会出现在参数列表中，所以在哪将this声明指向成指向常量的指针就成为我们必须面临的问题。C++语言的做法是允许把关键字放在成员函数的参数列表之后，此时，紧跟在参数列表之后的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为常量成员函数。
	可以把isbn函数体想象成如下的形式：
	//伪代码，说明隐式的this指针是如何使用的
	//下面的代码是非法的：因为我们不能显示的定义自己的this指针
	//谨记此处的this是一个指向常量的指针，因为isbn是一个常量成员
	std::string Sales_data::isbn(const Sales_data * const this)
	{
		return this->bookNo;
	}
注意，之所以要这样做的目的是为了能使用该函数去调用那些常量对象，因为常量对象是不能赋值给this的。所以产生了一种改变this类型的方法，就是 常量函数 。
	注意：
			常量对象，以及常量对象的引用或指针都只能调用常量成员函数。
	因为如果常量对象可以调用非常量的函数，那么就违反了this不能赋值常量对象的规则，所以常量对象，常量对象的指针或引用必须得只能调用常量成员函数。但是普通的成员函数就可以使用普通的成员函数或者是常量成员函数了。
类作用域和成员函数
	类的成员函数的定义嵌套在类作用域之内，因此，isbn中用到的名字bookNo其实就是定义在Sales_data内的数据成员。
	值得注意的是，即使bookNo定义在isbn之后，isbn也还是能够使用bookNo。这是因为，编译器分两步处理类：首先编编译成员的声明，然后才轮到成员函数体（如果有的话）。因此成员函数体内可随意使用类中的其他成员而不用在意这些成员函数出现的次序。
	注意：
			也就是说在C++编译类的时候，分两步完成的。首先编译类中的变量成员；然后再去编译相应的成员函数体。
在类外部定义成员函数
	像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表之后明确制定const属性，同时，对外部定义的成员的名字必须包含它的   所属的类名：
		double Sales_data::avg_price const
		{
			if(units_sold)
			{
				return revenue/units_sold;
			}
			else
			{
				return 0;
			}
		}
函数名Sales_data::avg_price使用作用域运算符来说明如下的事实：我们定义了一个名为avg_price的函数，并且该函数被声明在类Sales_data的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的。因此，当avg_price使用revenue和units_sold时，实际上它隐式的使用了Sales_data的成员。
	注意：
		其实，这也说明了类的作用域。首先你是类的成员函数，所以必须在类的作用域内定义。现在你在类的外部定义，如果不加类的限制符的话，那么就有可能被认为是普通的函数，所以必须加上类名限定符来表明这是一个类的内部成员函数。这样，我在成员函数中也可以使用相应的成员变量了。
定义一个返回this对象的函数
	函数combine的设计初衷类似于复合赋值运算符+=，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显示的实参被传入函数：
		Sales_data & Sales_data::combine(const Sales_data &rhs)
		{
			units_sold += rhs.units_sold;
			revenue += rhs.revenue;
			return *this;
		}
当我们的交易处理程序调用如下的函数时，
		total.combine(trans);
total的地址被隐式的绑定到this参数上，而rhs绑定到trans上。因此，当combine执行下面的语句时，
		units_sold += rhs.units_sold;
效果等同于
		total.units_sold += rhs.units_sold;
该函数一个值得关注的部分是它的返回类型和返回语句。一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，因此为了与它保持一致，combine函数必须
