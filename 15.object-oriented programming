					第15章		面向对象程序设计
内容
---------------------------------
	15.1	OOP:概述
	15.2	定义基类和派生类
	15.3	虚函数
	15.4	抽象基类
	15.5	访问控制与继承
	15.6	继承中的类作用域
	15.7	构造函数与拷贝控制
	15.8	容器与继承
	15.9	文本查询程序再探
--------------------------------
	面向对象程序设计基于三个基本概念:数据抽象、继承和动态绑定。第七章以及介绍了数据抽象的知识，本章将介绍
继承和动态绑定。
	继承和动态绑定对象的编写有两方面的影响:一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在
使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。
	在很多程序中都存在一些相互关联但是有细微差别的概念。例如，书店中不同书籍的定价策略可能不同:有的书籍按
原价销售，有的则打折销售。有时，我们给那些购买书籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的
书籍打折，之后就调用原价，等等。面向对象的程序设计(OOP)适用于这类应用。

15.1	OOP:概述
	面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。通过使用数
据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在
一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

继承:
	通过继承(inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，
其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类(derived class)。基类负责定义在层次关系中
所有共同拥有的成员，而每个派生类定义了各自特有的成员。
	为了对之前提到的不同定价策略建模，我们首先定义一个名为Quote的类，并将它作为层次关系中的基类。Quote
的对象表示按原价销售的书籍。Quote派生出另一个名为Bulk_quote的类，它表示可以打折销售的书籍。
	这些类将包含下面的两个成员函数:
		>>>	isbn()，返回书籍的ISBN编号。该操作不涉及派生类的特殊性，因此只定义在Quote类中。
		>>>	net_price(size_t)，返回书籍的实际销售价格，前提是用户购买该书的数量达到一定标准。这个操
作显然是类型相关的，Quote和Bulk_quote都应该包含该函数。
在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类
各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)。因此，我们可以将Quote类编
写成:
		class Quote{
		public:
			std::string isbn() const;
			virtual double net_price(std::size_t n)const;
		};
派生类必须通过使用派生列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表
的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:
		class Bulk_quote : public Quote{	//Bulk_quote继承了Quote
		public:
			double net_price(std::size_t) const override;
		};
因为Bulk_quote在它的派生列表中使用了public关键字，因此我们完全可以把Bulk_quote的对象当成Quote的对象
来使用。派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但
是并不是非得这么做。出于15.3节将要解释的原因，C++11新标准允许派生类显示地注明它将使用哪个成员函数改写其基
类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。

动态绑定
	通过使用动态绑定(dynamic binding)，我们能用同一段代码分别处理Quote和Bulk_quote的对象。例如，当
要购买的书籍和购买的数量都已知时，下面的函数负责打印总费用:
		//计算并打印销售给定数量的某种书籍所得的费用
		double print_total(ostream &os,const Quote &item,size_t n)
		{
			//根据传入item形参的对象类型调用Quote::net_price
			//或者Bulk_quote::net_price
			double ret = item.net_price(n);
			os<<"ISBN: "<<item.isbn()<<" # sold: "<<n<<"total due: "<<ret<<endl;
			return ret;
		}
该函数非常简单，它返回调用net_price()的结果，并将该结果连同调用isbn()的结果一起打印出来。
	关于上面的函数有两个有意思的结论:因为函数print_total的item是基类Quote的一个引用，所以出于15.2.3
节将要解释的原因，我们既能使用基类Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它；又因为
print_tota是使用引用类型调用net_price函数的，所以出于15.2.1节将要解释的原因，实际传入print_total的
对象类型将决到底执行net_price的哪个版本:
		//basic的类型是Quote；bulk的类型是Bulk_quote
		print_total(cout,basic,20);			//调用Quote的net_price
		print_total(cout,bulk,20);			//调用Bulk_quote的net_price
第一条调用语句将Quote对象传入print_total，因此当print_total调用net_price时，执行的是Quote的版本；在
第二条调用语句中，实参的类型是Bulk_quote，因此执行的是Bulk_quote的版本(打算打折信息)。因为在上
述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为运行时绑定
(run-time binding)
注意:
	在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定！！！

15.2	定义基类和派生类
	定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也有有一些不同之处。本节将介绍
在定义有继承关系的类时可能用到的基本特性。

15.2.1	定义基类
	我们首先完成Quote类的定义:
		class Quote{
		public:
			Quote() = default;		//关于default请参见7.1.4
			Quote(const std::string &book,double Sales_price):
					bookNo(book),price(Sales_price){}
			std::string isbn() const { return bookNo;}
			//返回给定数量的书籍的销售总额
			//派生类负责改写并使用不同的折扣计算算法
			virtual double net_price(std::size_t n)const
			{
				return n * price;
			}
			virtual ~Quote() = default;		//对析构函数进行动态绑定
		private:
			std::string bookNo;		//书籍的ISBN编号
		protected:
			double price = 0.0;		//代表普通状态下不打折的价格
对于上面这个类来说，新增的部分是在net_price函数和析构函数之前增加的virtual关键字以及最后的protected访问
说明符。我们将在15.7.1节详细介绍虚析构函数的知识，现在只需记住作为继承关系中根节点的类通常都会定义一个虚析
构函数。
注意:
	基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

成员函数与继承
	派生类可以继承其基类的成员，然而当遇到如net_price这样与类型相关的操作时，派生类必须对其重新定义。换句
话说，派生类需要对这些操作提供自己的新定义以方法覆盖(override)从基类继承而来的旧定义。
	在C++语言中，基类必须将它的两种成员函数区分开来；一种是基类希望其派生类进行覆盖的函数；另一种是基类希
望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为虚函数(virtual)。当我们使用指针或引用调用函
数时，该调用将被动态绑定。根据引用或指针搜所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生
类的版本。
	基类在通过其他成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态
函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函
数声明成虚函数，则该函数在派生类中隐式地也是虚函数。我们将在15.3节介绍更多关于虚函数的知识。
	成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。对于isbn成员来说这正是我们希望看到
的结果。isbn函数的执行与派生类的细节无关，不管作用于Quote对象还是Bulk_quote对象，isbn函数的行为都一样。
在我们的继承层次关系中只有一个isbn函数，因此也就不存在调用isbn()时到底执行哪个版本的疑问。

访问控制与继承
	派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类
的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员基类希望它的派生类有
权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符来说明这样的成员。
	我们的Quote类希望它的派生类定义各自的net_price函数，因此派生类需要访问Quote的price成员。与之相反，
派生类访问bookNo成员的方式与其他用户是一样的，都是通过调用isbn函数，因此bookNo被定义成私有的，即使是Quote
派生出来的类也不能直接访问它。我们将在15.5节介绍更多关于受保护成员的知识。
注意:
	protected　的成员是可以被派生类访问的，但是不能被基类的对象或者派生类的对象访问的。private　的成员是
只能被基类内部访问的，派生类的对象是不可以直接访问的，同样基类的对象也不能直接访问。

15.2.2	定义派生类
	派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生
列表的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种说明符中的一个:
public、protected或者private。
	派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此我们的Bulk_quote类必须包含以一个
net_price成员:
		class Bulk_quote : public Quote{
		public:
			Bulk_quote() = default;
			Bulk_quote(const std::string &,double,std::size_t,double);
			//覆盖基类的函数版本以实现基于大量购买的折扣政策
			double net_price(std::size_t)const override;//这个是虚函数，被继承过来所
														//以必须得重新声明!!
		private:
			std::size_t min_qty = 0;
			double discount = 0.0;
		};
我们的Bulk_quote类从它的基类Quote那里继承了isbn函数和bookNo、price等数据成员。此外，它还定义了
net_price的新版本，同时拥有两个新增加的数据成员min_qty和discount。这两个成员分别用于说明享受折扣所
需购买的最低数量以及一旦该数量达到之后具体的折扣信息。
	我们将在15.5节详细介绍派生列表中用到的访问说明符。现在，我们只需知道访问说明符的作用是控制派生类从基类
继承而来的成员是否对派生类的用户可见。如果有一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，
我们能将以公有派生类型的对象绑定到基类的引用或指针上。因为我在派生列表中使用了public，所以Bulk_quote的接
口隐式地含有isbn函数，同时在任何需要Quote的引用或指针的地方我们都能使用Bulk_quote的对象。
	大多数类都只继承自一个类，这种形式的继承被称作"单继承"，它构成了本章的主题。关于派生列表中含有多于一个
基类的情况将在18.3节中介绍。

派生类中的虚函数
	派生类经常(但不总是)覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似
于其他的普通成员，派生类会直接继承其在基类中的版本。派生类可以在它覆盖的函数前使用virtual关键字，但不是非
得这么做。我们将在15.3介绍其原因。C++11新标准允许派生类显示地注明它使用某个成员函数覆盖了它继承的虚函数。
具体做法是在形参列表后面，或者在const成员函数的const关键字后面、或者在有引用成员函数的引用限定符后面添加
一个关键字override。

派生类对象及派生类向基类的类型转换
	一个派生类对象包含多个组成部分：一个含有派生类自己定义的(非静态)成员的子对象，以及一个与该派生类继承
的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个Bulk_quote对象将包含四个数据元素:
它从Quote继承而来的bookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount成员。
	C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为Bulk_quote的对象包含如图15.1所
示的两部分。
					Bulk_quote对象
	从Quote继承而来的成员		bookNo,price
	Bulk_quote自定义的成员		min_qty,discount
在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。上述只是表示类工作机理的概念模型，而非
物理模型因为在派生类对象中含有与基类对应的组成部分，所以我们能把派生类的对象当成其类对象来使用，而且我们也能
将基类的指针或引用绑定到派生类对象中的基类部分上。
		Quote item;		//基类对象
		Bulk_quote bulk;	//派生类对象
		Quote *p = &item;	//p指向Quote对象
		p = &bulk;			//p指向bulk的Quote部分
		Quote &r = bulk;	//r绑定到bulk的Quote部分
这种转换通常称为派生类到基类(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基
类的转换。
这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生
类对象的指针用在需要基类指针的地方。也就是说可以使用基类的指针或引用去绑定派生类。
注意：
	在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键。

派生类构造函数
	尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的
代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。
注意:
	每个类控制它自己的成员初始化过程
派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化截断执行初始化操作的。类似于我们初始化
成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的
Bulk_quote构造函数如下
所示:
		Bulk_quote(const std::string &book,double p,std::size_t qty,double disc):
						Quote(book,p),min_qty(qty),discount(disc){}
		///与之前一致
		};
该函数将它的前两个参数(分别表示ISBN和价格)传递给Quote的构造函数，由Quote的构造函数负责初始化Bulk_quote
基类部分(即bookNo成员和price成员)。当(空的)Quote构造函数体结束后，我们构建对象的基类部分也就完成初始化
了。接下来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote构造函数的(空的)函数体。
	除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，
我们需要以类名加圆括号的内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构
造函数来初始化派生类对象的基类部分。
注意:
	首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

派生类使用基类的成员
	派生类可以访问基类的公有成员和受保护成员:
		//如果到达了购买书籍的某个最低限量值，就可以享受折扣价格了
		double Bulk_quote::net_price(size_t cnt)const
		{
			if(cnt >= min_qty)
				return cnt * (1-discount) * price;
			else
				return cnt * price;
		}
该函数产生一个打折后的价格：如果给定的数量超过了min_qty，则将discount(一个小于1大于0的数)作用于price。
	我们将在15.6节进一步讨论作用域，目前只需要了解派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的
一个成员来说，它使用派生类成员(例如min_qty和discount)的方式和使用基类成员(例如price)的方式没有什么不同。
关键概念:遵循基类的接口
	必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类
部分也是如此。
	因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护
的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构
造函数来初始化那些从基类中继承而来的成员。与就是通过构造函数来进行初始化每个类的成员，千万别越级操作。

继承与静态成员
	如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对
于每个静态成员来说都只存在唯一的实例:
		class Base{
		public:
			static void statmem();
		};
		class Derived : public Base{
			void f(const Derived &);
		};
静态成员遵循通用的访问控制规模，如果基类中的成员是private的，则派生类无权访问。假设某静态成员是可访问的，则
我们既能通过基类使用它也能通过派生类使用它:
		void Derived::f(const Derived & derived_obj)
		{
			Base::statmem();		//正确:Base定义了statmem
			Derived::statmem();		//正确:Derived继承了statmem
			//正确:派生类的对象能访问类的静态成员
			derived_obj.statmem();	//正确:通过Drived对象访问
			statmem();				//正确:通过this访问，也就是在类的定义的函数中使用

		}

派生类的声明
	派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生类列表:
		class Bulk_quote : public Quote;	//错误：派生列表不能出现在声明语句中
		class Bulk_quote;		//正确:声明派生类的正确方式
一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、有一个函数或是一个变量
等。派生列表以及与定义有关的其它细节必须与类的主体一起出现。

被用作基类的类
	如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明:
		class Quote;	//声明但未定义
		//错误:Quote必须被定义
		class Bulk_quote : public Quote{...};
这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它
们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。
	一个类是基类，同时它也可以是一个派生类:
		class Base { /* .....*/};
		class D1 : public Base {/*....*/};
		class D2 : public D1 {/*.....*/};
在这个继承关系中，Base是D1的直接基类(direct base)，同时是D2的间接基类(indirect base)。直接基类出现在
派生列表中，而间接派生类通过其直接基类继承而来。
	每个类都会继承直接基类的所有成员，对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又
含有其基类的成员；依次类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子
对象。

防止继承的发生
	有时我们会定义这样以一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，
C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final:
		class NoDerived final {/* ...... */};		//NoDerived不能作为基类
		class Base{/* ..*/};
		//Last是final的；我们不能继承Last
		class Last final : Base { /*....*/};	//Last不能作为基类
		class Bad : NoDerived{/*.....*/};//错误，NoDerived是final的
		class Bad2 : Last{/*....*/};	//错误:Last是final的

15.2.3	类型转换与继承
Wanrning	理解基类和和派生类之间的类型转化是理解C++语言面向对象编程的关键所在。
	通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应该与对象的类型一致。或者对象的
类型含有一个可接受的const的类型转换规则。存在继承关系的类是有一重要的例外:我们可以将基类的指针或引用绑定
到派生类对象上。例如，我们可以用Quote&指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给
一个Quote *。
	可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时，实际上我们
并不清楚该引用(或指针)所绑定的对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。
注意:
	和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一
个基类的智能指针内。

静态类型与动态类型
	当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与表示该对象的动态类型区分开来。表
达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内
存中的对象的类型。动态类型直到运行时才可知。
	例如，当print_total调用net_price时:
		double ret = item.net_price(n);
我们知道item的静态类型是Quote &，它的动态类型则依赖于item绑定的实参，动态类型直到在运行时调用该函数时才
会知道。如果我们传递一个Bulk_quote对象给print_total，则item的静态类型将与它的动态类型不一致。如前所述
item的静态类型是Quote &，而在此例中它的动态类型则是Bulk_quote。
	如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。例如，Quote类型的变量将永远是一个
Quote对象，我们无论如何都不能改变该变量对应的对象的类型。
注意:
	基类的指针或引用的静态类型可能与其动态的类型不一致，读者一定要理解其中的原因。主要是为了面向对象而来
的。

不存在从基类向派生类的隐式类型转换.....
	之所以存在派生类向基类的类型转换是因为每个派生类对象都包含有一个基类部分，而基类的引用或指针可以绑定
到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是
派生对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。
	因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换:
		Quote base;
		Bulk_quote *bulkp = &base;		//错误:不能将基类转换成派生类
		Bulk_quote &bulkPef = base;		//错误:不能将基类转换成派生类
小结下关于基类和派生类的类型转换：
	首先，基类必定是作为派生类的一部分的。也就是说，在派生类对象中必定有基类对象。所以普通的基类对象可以
指向派生类（其实指向的是派生类中的基类的对象），同理，引用也是一样的。但是反过来看，一个普通的基类对象可
能仅仅是作为一个基类的对象，而不是被包含在一个派生类对象中。也有可能是作为一个派生类对象的一部分的基类对
象。所以将一个派生类对象指向基类对象是可以的，因为你不知道这个基类对象是不是独立的。比方说，你的派生类想
调用一部分派生类自己的成员，但是你指向的基类成员只是一个单纯的独立的基类，那么它就不会含有派生类的对象。
所以不可以将派生类指向基类。那么为什么基类就可以指向派生类了。因为基类指向的派生类中的基类！所以是没有问
题的。但是这个时候却不能使用派生类的自己定义的新的成员。所以我们的虚函数才是一种非常重要的作用，因为虚函
数在基类中也有，派生类中也有，但是是不一样的，所以才会有指向派生类的基类，这样就可以使用派生类中的不同作
用的虚函数了。

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派
生类的转换:
		Bulk_quote bulk;
		Quote *itemp = &bulk;		//正确:动态类型是Bulk_quote
		Bulk_quote *bulkP = itemp;	//错误:不能将基类转换成派生类！！！
编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推
断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换，该转换的
安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来强
制覆盖掉编译器的检查工作。
......在对象之间不存在类型转换
	派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和其他类类型之间不存在这样的转换。很多时
候我们确实希望将派生类对象转成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。
	请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数；
而当执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用。
	因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象。
这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然
该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算
符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。
	例如，我们的书店类使用了合成版本的拷贝和赋值操作。关于拷贝控制与继承的知识将在15.7.2节做更详细的介绍，
现在我们只需要知道合成版本会像其他类一样逐成员地进行拷贝或赋值操作:
		Bulk_quote bulk;		//派生类对象
		Quote item(bulk);		//使用Quote::Quote(const Quote&)构造函数
		item = bulk;			//使用Quote::operator=(const Quote&);
当构造item时，运行Quote的拷贝构造函数。该函数只能处理bookNo和price两个成员，它负责拷贝bulk中Quote部
分的成员，同时忽略掉bulk和Bulk_quote部分的成员，类似的，对于将bulk赋值给item的操作哦来说，只有bulk
和Quote部分的成员被赋值item。
	因为在上述过程中会忽略掉Bulk_quote部分，所以我们可以说bulk的Bulk_quote部分被切掉了(slice down)。
注意:
	当我们用有一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，
它的派生类部分将被忽略掉。

关键概念:存在继承关系的类型之间的转换规则
	要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要:
		>>>	从派生类向基类的类型转换只对指针或引用类型有效
		>>>	基类向派生类不存在隐式类型转换!!!!
		>>>	和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节
介绍可访问性的问题
尽管自动类型转换只针对指针或引用类型有效，但是继承体系中的大多数类仍然(显示或隐式地)定义了拷贝控制成员。
因此我们通常能够将有一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派
生类对象的基类部分。

15.3	虚函数
	如前所述，在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运
行时才能知道到底用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，
则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也
无法确定到底会使用哪个虚函数。

对虚函数的调用可能在运行时才被解析
	当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的
函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。举个例子，考虑15.1节中的print_total函数，该
函数通过其名为item的参数来进一步调用net_price，其中item的类型是Quote&。因为item是引用而且net_price
是虚函数，所以到底调用net_price的哪个版本完全依赖于运行时绑定到item的实参的实际(动态)类型:
		Quote base("0-201-82470-1",50);
		print_totoal(cout,base,10);		//调用Quote::net_price
		Bulk_quote derived("0-201-82470-1",50,5,.19);
		print_total(cout,derived,10);	//调用Bulk_quote::net_price
在第一条调用语句中，item绑定到Quote类型的对象上，因此当print_total调用net_price时，运行在
Quote中定义的版本。在第二条调用语句中，item绑定到Bulk_quote类型的对象上，因此print_total调用
Bulk_quote定义的net_price。
	必须要搞清楚的一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生!!!
		base = derived;		//把derived的Quote部分拷贝到base，这个里base已经有拷贝控制成员
		base.net_price(20);	//调用Quote::net_price
当我们调用一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来。例如，
如果我们使用base调用net_price，则应该运行net_price的哪个版本是显而易见的。我们可以改变base表示的
对象的值(即内容)。但是不会改变该对象的类型。因此，在编译时该调用会被解析成Quote的net_price。

关键概念:C++的多态性
	OOP的核心思想是多态性(polymorphism)。多态性这个词源自希腊语，其含义是"多种形式"。我们把具有继承
关系的多个类型称为多态类型，因为我们能使用这些类型的"多种形式"而无须在意它们的差异。引用或指针的静态类型
与动态类型不同这一事实正是C++语言支持多态性的根本所在。
	当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因
为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版
本，判断的依据是引用或指针所绑定的对象的真实类型。
	另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或非虚函数)调用也在编译
时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行
的函数调用将在编译时绑定到该对象所属类的函数版本上。当且仅当通过指针或引用调用虚函数时，才会在运行时解析
该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

派生类中的虚函数
	当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必
须的，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。
	一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与它覆盖的基类函数完全一致。同样，
派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针
或引用时，上述规则无效。也就是说，如果D由B派生得到的，则基类的虚函数可以返回B*而派生类的对应函数可以返
回D*，只不过这样的返回类型要求从D到B的类型转换是可以访问的。15.5节将介绍如何确定一个基类的可访问性，
在15.8.1节中我们将看到这种虚函数的一个实际例子。
注意:
	基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须
与派生类中的形参严格匹配。

final和override说明符
	如我们将要在15.6节介绍的，派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然
是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉
基类中的版本。就实际的编程习惯而言，这种声明方式往往意味着发生错误，因为我们可能原本希望派生类能覆盖掉基
类中的虚函数，但是一不小心把形参列表弄错了。
	要想调试并发现这样的错误显然非常困难。在C++11新标准中我们可以使用override关键字来说明派生类中的虚
函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得
更加重要。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错:
		struct B{
			virtual void f1(int)const;
			virtual void f2();
			virtual f3();
		};
		struct D1 : B{
			void f1(int)const override;		//正确:f1与基类中的f1匹配
			void f2(int)override;		//错误:B没有形如f2(int)的函数
			void f3()override;			//错误:f3不是虚函数
			void f4()override;			//错误:B没有名为f4的函数
		};
在D1中，f1的override说明符是正确的，因为基类和派生类中的f1都是const成员，并且它们都接受一个int返回
的void，所以D1中的f1正确的覆盖了它从B中继承而来的虚函数。
	D1中的f2声明与B中f2的声明不匹配，所以D1的f2不能覆盖B的f2，它是一个新函数，仅仅是名字恰好与原来
的函数一样而已。因为我们使用override所表达的意思是我们希望能覆盖掉基类中的虚函数而实际上并未做到，所以
编译器会报错。
	因为只有虚函数才能被覆盖，所以编译器会拒绝D1的f3。该函数不是B中的虚函数，因此它不能被覆盖。类似的，
f4的声明也会发生错误，因为B中根本就没有名为f4的函数。我们还能把某个函数指定为final，如果我们已经把函数
定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误:
		struct D2 : B{
			///从B继承f2()和f3()，覆盖f1(int)const
		void f1(int)const final;		//不允许后续的其他类覆盖f1(int)
		};
		struct D3 : D2{
			void f2();		//正确:覆盖从间接基类B继承而来的f2
			void f1(int)const;		//错误:D2已经将f2声明成final
		};
final和override说明符出现在形参列表(包括任何const或引用修饰符)以及尾置返回类型之后。


虚函数与默认实参
	和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态
类型决定。换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中的默认实参，即使实际运行的是派生类
中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则
程序结果将与我们的预期不符。这个的意思也就是说，虚函数的默认实参的使用是根据静态类型来决定的而不是动态类
型决定！！所以即使你的基类指向的是派生类，但是在使用默认实参的时候也是使用基类的默认实参，而不是派生类中
定义的默认实参！！！
注意:
	如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

回避虚函数的机制
	在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域
运算符可以实现这一目的，例如下面的代码:
		//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
		double undiscounted = baseP->Quote::net_price(42);
改代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解
析。
注意:
	通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制。
什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况
下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切
相关的操作。
注意:
	如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类
版本自身的调用，从而导致无限递归。

15.4	抽象基类
	假设我们希望扩展书店程序并令其支持几种不同的折扣策略。除了购买数量超过一定数量享受折扣外，我们也可以提
供另外一种策略，即购买数量不超过某个限额时可以享受折扣，但是一旦超过限制额就要按原价支付。或者折扣策略还可
能是购买数量超过一定数量后购买的全部书籍都享受折扣，否则全都不打折。
	上面的每个策略都要求一个购买量的值和一个折扣值。我们可以定义一个新的名为Disc_quote的类来支持不同的折
扣策略，其中Disc_quote负责保存购买量的值和折扣值。其他的表示某种特定策略的类(如Bulk_quote)将分别继承自
Disc_quote，每个派生类通过定义自己的net_price函数来实现各自的折扣策略。
	在定义Disc_quote类之前，首先要确定他的net_price函数完成什么工作。显然我们的Disc_quote类与任何特
定的折扣策略都无关，因此Disc_quote类中的net_price函数是没有实际含义的。
	我们可以在Disc_quote类中不定义新的net_price，此时，Disc_quote将继承Quote的net_price函数，
然而这样的设计可能导致用户编写出一些无意义的代码。用户可能会创建一个Disc_quote对象并为其提供购买量和折扣
值，如果将该对象传给一个像print_total这样的函数，则程序将调用Quote版本的net_price。显然，最终计算出
的销售价格并没有考虑我们在创建对象时提供的折扣值，因此上述操毫无意义。

纯虚构函数
	认真考虑上面描述的情形我们可以发现，关键问题并不仅仅是不知道应该如何定义net_price，而是我们根本就不希
望用户创建一个Disc_price对象。Disc_quote类表示的是一本打折书籍的通用概念，而非某种具体的折扣策略。
	我们可以将net_price定义成纯虚函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个
net_price函数是没有实际意义的。和普通函数的虚构函数不一样，一个纯虚构函数无须定义。我们通过在函数体的位置
(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处:
		//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略
		class Disc_quote:public Quote{
		public:
			Disc_quote() = default;
			Disc_quote(const std::string &book,double price,std::size_t qty,double disc):
						Quote(book,price),quantity(qty),discount(disc){}
			double net_price(std::size_t)const =0;
		protected:
			std::size_t quantity = 0;		//折扣适用的购买的数量
			double discount = 0.0;
		};
和我们之前定义的Bulk_quote类一样，Disc_quote也分别定义了一个默认构造函数和一个接受四个参数的构造函数。
尽管我们不能直接定义这个类的对象，但是Disc_quote的派生类构造函数将会使用Disc_quote的构造函数来构建各
个派生类对象的Disc_quote部分。其中接受四个参数的构造函数将前两个参数传递给Quote的构造函数，然后直接初
始化自己的成员discount和quantity。默认构造函数则对这些成员进行默认初始化。
	值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内
部为一个=0的函数提供函数体。

含有纯虚函数的类是抽象基类
	含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接
口。我们不能(直接)创建一个抽象基类的对象。因为Disc_quote将net_price定义成了纯虚函数，所以我们不能
定义Disc_quote的对象。我们可以定义Disc_quote的派生类对象，前提是这些类覆盖了net_price函数:
		//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数
		Disc_quote discounted;		//错误:不能定义Disc_count的对象
		Bulk_quote bulk;			//正确:Bulk_quote中没有纯虚函数
Disc_quote的派生类必须给出自己的net_price定义，否则它们仍将是抽象基类。
注意:
	我们不能创建抽象基类的对象！！！

派生类构造函数只初始化它的直接基类
	接下来可以重新实现Bulk_quote了，这一次我们让他继承Disc_quote而非直接继承Quote:
		//当同一本书籍的销售量超过某个值时启用折扣
		//折扣的值是一个小于1的正的小数值，依次来降低正常销售价格
		class Bulk_quote : public Disc_quote{
		public:
			Bulk_quote() = default;
			Bulk_quote(const std::string &book,double price,std::size_t qty,
					  double disc):Disc_quote(book,price,qty,disc){}
			double net_price(std::size_t)const override;
		};
这个版本的Bulk_quote的直接基类是Disc_quote，间接基类是Quote。每个Bulk_quote对象包含三个子
对象：一个空的Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。
	如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，它也仍
然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给Disc_quote的构造函数，随后
Disc_qoute的构造函数继续调用Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price成员，
当Quote的构造函数结束后，开始运行Disc_quote的构造函数并初始化quantity和discount成员，最后运行
Bulk_quote的构造函数，该函数无须执行实际的初始化或其他工作。
关键概念:重构
	在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。重构负责
重新设计类的体系以便操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很
普通的现象。
	值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何
改动。不过一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。

15.5	访问控制与继承
	每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问(asscessible)

受保护的成员
	如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。
protected说明符可以看做是public和private中和后的产物:
		>>>	和私有成员类似，受保护的成员对于类的用户来说是不可访问的。(这里类的用户也就是对象)
		>>>	和公有成员类似，受保护的成员对于派生类的成员和有友元来说是可以访问的
		>>>	派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保
护成员没有任何访问特权。也就是说可以访问类的成员，但是不能访问基类对象的成员。
为了理解最后一条规则，请考虑如下的例子:
		class Base{
		protected:
			int prot_mem;
		};
		class Sneaky : public Base{
			friend void clobber(Sneaky &);	//可访问Sneaky::prot_mem;
			friend void clobber(Base &);	//不能访问Base::prot_item;
			int j;		//j默认是private;
		};
		//正确:clobber能访问Sneaky对象的private和protected成员
		void clobber(Sneaky &s){
			s.j = s.prot_item = 0;
		}
		//错误:clobber不能访问Base的protected成员
		void clobber(Base &b){
			b.prot_mem = 0;
		}
如果派生类(及其友元)能访问基类对象的受保护成员，则上面的第二个clobber(接受一个Base &)将是合法的。
该函数不是Base的友元，但是它仍然能够改变一个Base对象的内容。如果按照这样的思路，则我们只要定义一个
形如Sneaky的新类就能非常简单地规避掉protected提供的访问保护了。
	要想阻止以上的用法，我们就要做出如下规定，即派生类的成员和友元只能访问派生类对象中的基类部分的受
保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。也就是说，派生类的成员和友元只能通过派生类
对象去访问基类中的受保护的成员，而不是直接通过基类对象就能访问基类中的受保护的成员。也就是成员函数或
友元函数只能通过该类的对象去访问其基类的成员，而不是直接通过基类对象直接访问基类的受保护成员！！

公有、私有和受保护继承
	某个类对其继承而来的成员访问权限受到两个因素影响：一个是基类中该成员的访问说明符，二是在派生类列
表中的访问说明符。举个例子，考虑如下的继承关系:
		class Base{
		public:
			void pub_mem();
		protected:
			int prot_mem();
		private:
			char priv_mem();
		};
		struct Pub_Derv : public Base{
			//正确:派生类能访问protected成员
			int f(){return prot_mem();}
			//错误:private成员对于派生类来说是不可访问的
			char g(){return priv_mem();}
		};
		struct Priv_Derv : private Base{
			//private不影响派生类的访问权限
			int f() const {return prot_mem();}
		};
派生类访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没有什么影响。对基类成员的访问权限只与
基类中的的访问说明符有关。Pub_Dev和Priv_Derv都能访问受保护的成员prot_mem，同时它们都不能访问私有
成员priv_mem。
	派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限:
		Pub_Derv d1;		//继承自Base的成员是public的
		Priv_Derv d2;		//继承自Base的成员是private的
		d1.pub_mem();		//正确:pub_mem在派生类中是public的
		d2.pub_mem();		//错误:pub_mem在派生类中是private的
Pub_Derv和Priv_Derv都继承了pub_mem函数。如果继承是公有的，则成员将遵循其原有的访问说明符，此时
d1可以调用pub_mem。在Priv_Derv中，Base的成员是私有的，因此类的用户不能调用pub_mem(类的用户，
也就是我们程序员创建的类的对象)。
	派生类访问说明符还可以控制继承自派生类的新类的访问权限:
		struct Derived_from_Public : public Pub_Derv{
		//正确:Base::prot_mem在Pub_Derv中仍然是protected的
		int use_base() { return prot_mem;}
		};
		struct Derived_from_Private: private Priv_Derv{
			//错误:Base::prot_mem在Priv_Derv中的是private的
			int use_base() { return prot_mem;}
		};
Pub_Derv的派生类之所以能访问Base的prot_mem成员是因为该成员在Pub_Derv中仍然是受保护的。相反，Priv_Derv
的派生类无法执行类的访问，对于它们来说，Priv_Derv继承自Base的所有成员都是私有的。
	假设我们之前还定义了一个名为Prot_Derv的类，它采用受保护继承，则Base的所有公有成员在新定义的类中
都是受保护的。Prot_Derv的用户不能访问pub_mem，但是Prot_Derv的成员和友元可以访问那些继承而来的成员。
小结下:
	派生类访问说明符(也就是派生列表中的那些)，不限制派生类的成员函数和友元函数去访问基类的中的成员(
也就是派生类中的成员函数和友元函数可以访问直接基类的public和protected成员)。派生类访问说明符只是
用来给派生类的用户(也就是对象)的。如果派生类使用public继承，那么派生类中的继承过来的基类的成员保持与
基类本身的成员的访问权限一致，保持不变。但是如果是private继承的，那么派生类中的基类的访问权限在派生
类的对象中就全是private的了。所以对派生类对象就不可访问的了。
所以:派生类访问符对于派生类本身访问基类
的成员是不变的，但是对于派生类的对象(用户)来说就是不一样的了。
对于派生类的派生类来说是同样的道理，就
可以把派生类产生的派生类看做是一个派生来对象来看待。

派生类向基类转换的可访问性
	派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承
自B:
		>>>	只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者
私有的，则用户代码不能使用该转换。
		>>>	不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类
型转换对于派生类的成员和友元来说永远是可访问的。
		>>>	如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，
如果D继承B的方式是私有的，则不能使用。(注意这个和第二条的区别，这里说的是D的派生类的成员函数或友元，而第
二条说的是D的成员函数或友元)
注意:
	对于代码中的某个给节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之
不行。
关键概念:类的设计与受保的成员
	不考虑继承的话，我们可以认为以一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码
使用类的对象，这部分代码只能访问类的公有(接口)成员；实现者则负责编写类的成员函数和友元的代码，成员函数和
友元既能访问类的公有部分，也能访问类的私有(实现)部分。
	如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普
通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。(但是在基类中的成员函数和友元是可以访
问的)。
	和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组:一组可供派生类访问，另
一组只能由基类及基类的友元访问。对于前者应该声明成为受保护的，这样派生类就能在实现自己的功能时使用基类的这
些数据和操作；对于后者应该声明为私有的。
也就是说:
	基类的成员函数和友元函数是对基类的所有的公有、私有、受保护成员都是可访问的；但是用户对于基类的公有的
成员才可访问，基类的私有、受保护成员是不可被基类的用户所访问的。
	基类的派生类的成员函数和友元函数对于基类的公有成员和受保护的成员是可访问的，但是对于基类的私有成员是
不可访问的。派生类的用户对基类的访问得看派生类继承说明符，如果是公有继承的话，那么只能访问原先基类中的公
有成员，如果是私有继承和保护继承则派生类的用户是不可以访问的！

友元与继承
	就像友元关系不能传递一样，友元关系同时也不能继承。基类的友元在访问派生类的成员时不具有特殊性，类似的，
派生类的友元也不能随意的访问基类的成员:
		class Base{
			//添加friend声明，其他成员与之前的版本一致
			friend class Pal;		//Pal在访问Base的派生类时不具有特殊性
		};
		class Pal{
		public:
			int f(Base b){return b.prot_mem;}		//正确:Pal是Base的友元
			int f2(Sneaky s){return s.j;}		//错误:Pal不是Sneaky的友元
			//对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
			int f3(Sneaky s){return s.prot_mem;}		//正确:Pal是Base的友元
		};
如前所述，每个类负责控制自己的成员的访问权限，因此尽管看起来有点奇怪，但f3确实是正确的。Pal是Base的友元，
所以Pal能够访问Base对象的成员，这种可访问性包括了Base对象内嵌套在其派生类对象中的情况。
	当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者
派生类不具有特殊的访问能力:
		//D2对Base的protected和private成员不具有特殊的访问能力
		class D2 : public Pal{
		public:
				int mem(Base b){
					return b.prot_mem;}//错误:友元关系不能继承
		};
注意:
	不能继承友元关系，每个类负责控制各自成员的访问权限
小结下：
	关于友元的，首先友元不能继承，也就是说，如果一个基类是另一个类的友元类，那么该基类的派生类是不能够继承
过来这种友元关系的。但是如果一个类A是另一个类B的友元，但是这个类A却可以访问另一个类B的派生类C中的关于B的成
员！！但是A也仅仅访问C中的B的成员，却不能访问C中自己的成员。

改变个别成员的可访问性
	有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明可以达到这一目的:
		class Base{
		public:
			std::size_t size() const { return n;}
		protected:
			std::size_t n;
		};
		class Dervied : private Base{
		public:
			//保持对象尺寸相关的成员的访问级别
			using Base::size;
		protected:
			using Base::n;
		};
因为Derived使用了私有继承，所以继承而来的成员size和n(在默认情况下)是Derived的私有成员。然而，我们使用
using声明语句改变了这些成员的可访问性。改变之后，Dervied的用户将可以使用size成员，而Derived的派生类将
能使用n。
	通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员(例如，非私有成员)标
记出来。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。也就是说，如果一条using声
明语句出现在类的private部分，则该名字只能被类的成员和友元访问；如果using声明语句位于protected部分，则
该名字对于成员、友元和派生类是可访问的。
注意:
	这里的using只能改变的是可访问的成员。也就是在派生类中可以访问的对象就只有public和protected。所以
使用using可以去访问它。比方说，你的基类中的public，protected都可以在派生类成员函数和友元函数中使用。
如果你的派生类的继承方式是private的话，那么所有的基类成员函数对于派生类的用户来说都是私有的了。但是派生
类的成员函数和友元函数来说，基类的成员的访问权限不变。所以在这种情况下，使用using可以改变派生类对象对于
继承过来的基类的成员的访问权限。比如说,A类继承B类，是通过private继承过来的，那么A类的对象就不能
访问B中原先的公有的成员。但是如果在A类的public中使用using声明，这样A的对象就可以使用B中原先的public
成员了。同理如果在private部分声明using，那么该基类中的成员函数只能被派生类使用了(这个成员函数是A可访问的)。
如果你的可访问的成员函数在protected部分被声明，那么这些原先被访问的成员只能被派生类的成员函数，友元以及
派生类使用了。

注意:
	派生类只能为那些它可以访问的名字提供using声明

默认的继承保护级别
	在7.2节中我们曾经介绍过使用struct和class关键字定义的类具有不同的默认访问说明符。类似的，默认派生类运
算符也由定义派生类用的关键字来决定。默认情况下，使用class关键字是定义的派生类私有继承的；而使用struct关
键字定义的派生类是公有继承的:
		class Base{/*....*/};
		struct D1 : Base {/*....*/};	//默认public继承
		class D2 : Base{/*....*/};		//默认private继承
人们常有一种错觉，认为在使用struct关键字和class关键字定义的类之间还有更深层次的差别。事实上，唯一的差别
就是默认成员访问说明符以及默认派生类访问说明符。除此之外，再无其他不同之处。
注意:
	一个私有派生的类最好显示地将private声明出来，而不要仅仅依赖于默认的设置。显示声明的好处是可以令私有
继承关系清晰明了，不至于产生误会。

15.6	继承中的类的作用域
	每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用嵌套在其基类的作
用域中。如果有一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。
	派生类的作用域位于基类作用域之内这一事实可能有点出乎意外，毕竟在我们的程序文本中派生类和基类的定义是
相互分离开来的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的
成员。例如，当我们编写下面的代码时:
		Bulk_quote bulk;
		cout<<bulk.isbn();
名字isbn的解析将按照下述过程所示:
		>>>	因为我们是通过Bulk_quote的对象调用isbn的，所以首先在Bulk_quote中查找，这一步没找到名
字ibsn。
		>>>	因为Bulk_quote是Disc_quote的派生类，所以接下来在Disc_quote中查找，仍然找不到。
		>>>	因为Disc_quote是Quote的派生类，所以接着查找Quote；此时找到了名字isbn，所以我们使用
的isbn最终被解析为Quote中的isbn。

在编译时进行名字查找
	一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致(
当使用基类的引用或指针时会发生这种情况)，但是我们能使用哪些成员仍然是由静态决定的。举个例子，我们可以
给Disc_quote添加一个新成员，该成员返回一个存有最小(或最大)数量及折扣价格的pair:
		class Disc_quote:public Quote{
		public:
			std::pair<size_t,double>discoutnt_policy()const
			{
				return {quantity,discount};
			}
			//其他成员与之前的版本一致。
		};
我们只能通过Disc_quote及其派生类的对象、引用或指针使用discount_policy:
		Bulk_quote bulk;
		Bulk_quote *bulkP = &bulk;		//静态类型与动态类型一致
		Quote *itemP = &bulk;		//静态类型与动态类型不一致
		bulkP->discount_policy();	//正确:bulkP的类型是Bulk_quote *
		itemP->discount_policy();	//错误:itemP的类型是Quote *，不能调用派生类中非基类的成员
尽管在bulk中确实含有一个名为discount_policy的成员，但是该成员对于itemP却是不可见的。itemP的类型是
Quote的指针，意味着对discount_policy的搜索将从Quote开始。显然Quote不含名为discount_policy的成员。
所以我们无法通过Quote的对象，引用或指针调用discount_policy。

名字冲突与继承
	和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字。此时定义在内层作用域中(即派生类)
的名字将隐藏定义在外层作用域(即基类)的名字:
		struct Base{
			Base():mem(0){}
		protected:
			int mem;
		};
		struct Derived : Base{
			Derived(int i):mem(i){}
			int get_mem(){return mem;}		//
		protected:
			int mem;		//隐藏基类中的mem
		};
get_mem中mem引用的解析结果是定义在Dervied中的名字，下面的代码:
		Derived d(42);
		cout<<d.get_mem() <<endl;		//打印42
的输出结果将是42
注意:
	派生类的成员将隐藏同名的基类成员

通过作用域运算符来使用隐藏的成员
	我们可以通过作用域运算符来使用一个被隐藏的基类成员:
		struct Dervied : Base{
			int get_base_mem(){return Base::mem;}
			//....
		};
作用域运算符将覆盖掉原有的查找规则，并指示编译器从Base类的作用域内开始查找mem。如果使用最新的Derived版本
运行上面的代码，则d.get_base_mem()的输出结果将是0。
注意:
	除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

关键概念:名字查找由与继承
	理解函数调用的解析过程对于理解C++的继承至关重要，假定我们调用p->mem()(或者obj.mem())，则依次执行
以下4个步骤:
		>>>	首先确定p(或obj)的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型
		>>>	在p(或obj)的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承
链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错
		>>>	一旦找到了mem，就进行常规的类型检查以确认对应于当前找到的mem，本次调用是否合法
		>>>	假设合法，则　编译器将根据调用的是否是虚函数而产生不同的代码:
			---如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在进行时确定到底
进行该虚函数的那个版本，依据是对象的动态类型
			---反之，如果mem不是虚函数或者我们是通过对象(而非指针或引用)进行的调用，则编译器将产生一
个常规函数调用。

一如往常，名字查找优先于类型检查
	如前所述，声明在内层作用域的函数不会重载声明在外层作用域的函数(只要不一样就当做是派生类中的新成员)。
因此,定义派生类中的函数也不会重载其基类中的成员。和其他作域一样，如果派生类(即内层作用域)的成员与基类
(即外层作用域某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使派生类成员和基类成员的形参列表不
一致，基类成员也仍然会被隐藏掉:
		struct Base{
			int memfcn();
		};
		struct Dervied : Base{
			int memfcn(int);		//隐藏基类的memfcn
		};
		Derived d;Base b;
		b.memfcn();		//调用Base::memfcn
		d.memfcn(10)	//调用Derived::memfcn
		d.memfcn();		//错误:参数列表为空的memfcn被隐藏了
		d.Base::memfcn();//正确:调用Base::memfcn
Derived中的memfcn声明隐藏了Base中的memfcn声明。在上面的代码中前两条调用语句容易理解，第一个通过Base
对象b进行调用执行基类的版本；类似的，第二个通过d进行的调用执行Derived的版本；第三条调用语句有点特殊，
d.memfcn()是非法的。因为Derived中的memfcn和Base中的memfcn重名了，所以被Derived中的memfcn()给
覆盖掉了。
	为了解析这条语句,编译器首先在Dervied中查找名字memfcn；因为Derived确实定义了一个名为memfcn的成
员，所以查找过程终止。一旦名字找到，编译器就不再继续查找了。Derived中的memfcn版本需要一个int实参，
而当前的调用语句无法提供任何实参，所以该调用语句是错误的。

虚函数与作用域
	我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。假如基类与派生类的虚函数接受的实
参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。例如:
		class Base{
		public:
			virtual int fcn();
		};
		class D1 : public Base{
		public:
			//隐藏基类的fcn，这个fcn不是虚函数
			//D1继承了Base::fcn()的定义
			int fcn(int);		//形参列表与Base中的fcn不一致
			virtual void f2();	//是一个新的虚函数，在Base中不存在
		};
		class D2 : public D1{
		public:
			int fcn(int);		//是一个非虚函数，隐藏了D1::fcn(int)
			int fcn();			//覆盖了Base的虚函数fcn
			void f2();			//覆盖了D1的虚函数f2
		};
D1的fcn函数并没有覆盖Base的虚函数fcn，原因是它们的形参列表不同。实际上，D1的fcn将隐藏Base的fcn。
此时拥有了两个名为fcn的函数:一个是D1从Base继承而来的虚函数，另一个是D1自己定义的接受一个int参数非
虚函数fcn。

通过基类调用隐藏的虚函数
	给定上面定义的这些类后，我们来看几种使用其他函数的方法:
		Base bobj;D1 d1obj;D2 d2obj;
		Base *bp1 = &bobj,*bp2 = &d1obj,*bp3=&d2obj;
		bp1->fcn();			//虚调用，将在运行时调用Base::fcn()
		bp2->fcn();			//虚调用，将在运行时调用Base::fcn()
		bp3->fcn();			//虚调用，将在运行时调用D2::fcn()
		D1 *d1p = &d1obj;D2 *d2p = &d2obj;
		bp2->f2();			//错误，Base没有名为f2的成员
		d1p->f2();			//虚调用，将在运行时调用D1::f2()
		d2p->f2();			//虚调用，将在运行时调用D2::f2()
前三条调用语句是通过基类的指针进行的，因为fcn是虚函数，所以编译器产生的代码将在运行时确定使用虚函数的
哪个版本。判断的依据是该指针所绑定对象的真实类型。在bp2的例子中，实际绑定的对象是D1类型，而D1并没有
覆盖那个不接受实参的fcn，所以通过bp2进行的调用将在运行时解析为Base定义的版本。
	接下来的三条调用语句是通过不同类的的指针进行的，每个指针分别指向继承体系中的一个类型。因为Base类中
没有f2()，所以第一条语句是非法的，即使当前的指针碰巧指向了一个派生类对象也无济于事。
	为了完整地阐明上述问题，我们不妨再观察一些对于非虚函数fcn(int)的调用语句:
		Base *p1 = &d2obj;D1 *p2 = &d2obj;D2 *p3 = &d2obj;
		p1->fcn(42);		//错误:Base中没有接受一个int的fcn
		p2->fcn(42);		//静态绑定:调用D1::fcn(int)
		p3->fcn(42);		//静态绑定:调用D2::fcn(int)
在上面的每条调用语句中，指针都指向了D2类型的对象，但是由于我们调用的是非虚函数，所以不会发生动态绑定。
实际调用的函数版本由指针是静态类型决定的。
注意:
	其实如果在派生类中没有写上与基类的虚函数一模一样的形参的话，那么基类的虚函数就被屏蔽了，但是派生
类中的相对应的那个函数，就是一个普通的函数了，而不是一个虚函数！！！

覆盖重载的函数
	和其他函数一样，成员函数无论是否是虚函数能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生
类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。
	有时一个类仅需要覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，
显然操作就极其繁琐。
	一种好的解决方法是为重载的成员提供一条using声明语句，这样我们就无须覆盖基类中的每一个重载版本了。
using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的是所有
重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重
新定义。
	类内using声明的一般规则同样适用于重载函数的名字:基类函数的每个实例在派生类中都必须是可访问的。对
派生类没有重新定义的重载版本的访问实际上是对using声明点的访问。

15.7.1	虚析构函数
	继承关系对基类拷贝最直接的影响是基类通常应该定义一个虚析构函数。这样我们就能动态分配继承体系中的
对象了。
	如前所述，当我们delete一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类
型，则有可能出现指针的静态类型与被删除的动态类型不符的情况。例如，如果我们delete一个Quote *类型的
指针，则该指针有可能实际指向了一个Bulk_quote类型的对象。如果这样的话，编译器就必须清楚它应该执行的是
Bulk_quote的析构函数，和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数
版本。
		class Quote{
		public:
			//如果我们删除的是一个指向派生类对象的基类指针，则需要析构函数
			virtual ~Quote() = default;	//动态绑定析构函数　
		};
和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论Quote的派生类使用合成的析构函数还是定义自己的
析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保当我们delete基类指针时运行正确的析构
函数版本:
		Quote *itemP = new Quote;	//将静态类型与动态类型一致
		delete itemP;			//调用Quote的析构函数
		itemP = new Bulk_quote;	//静态类型和动态类型不一致
		delete itemP;		//调用Bulk_quote的析构函数
注意:
	如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。
之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。基类的析构函数
并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。此时，
该析构函数为了虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算符或拷贝构造函数。

虚析构函数将阻止合成移动操作
	基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析
构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

15.7.2	合成拷贝控制与继承
	基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身
的成员依次进行初始化、赋值或销毁操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直
接基类部分进行初始化、赋值或销毁的操作。例如:
		>>>	合成的Bulk_quote默认的构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认
构造函数
		>>>	Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值将price初始化
为0。
		>>>	Quote的构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初值初始化qty和discount
		>>>	Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它什么具体
工作也不做。
类似的，合成的Bulk_quote拷贝构造函数使用(合成的)Disc_quote拷贝构造函数，后者又使用(合成的)Quote
拷贝构造函数。其中，Quote拷贝构造函数拷贝bookNo和price成员；Disc_quote拷贝构造函数拷贝qty和discount
成员
	值得注意的是，无论基类成员还是合成的版本(如Quote继承体系的例子)还是自己定义的版本都没有太大的影响。
唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。在我们的Quote继承体系中，所有类都使用合成的析
构函数。其中，派生类隐式地使用而基类通过将其虚析构函数定义成=default而显示地使用。一如既往，合成的
析构函数体是空的，其隐式的析构部分负责销毁类的成员。对于派生类的析构函数来说，他除了销毁派生类自己的成员
外，还负责销毁派生类的直接基类，该直接基类又销毁了它自己的直接基类，依次类推直至继承链的顶端。
	如前所述，Quote因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动Quote对象时实际使用的
是合成的拷贝操作。如我们即将看到的那样，Quote没有移动操作意味着它的派生类也没有。

派生类中删除的拷贝控制与基类的关系
	就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制
成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数:
		>>>	如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访
问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或
销毁操作
		>>>	如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删
除的，因为编译器无法销毁派生类对象的基类部分。
		>>>	和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作
时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分
不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删的。
举个例子，对应于下面的基类B来说:
		class B{
		public:
			B();
			B(const B&) = default;
			//其他成员，不含有移动构造函数
		};
		class D : public B{
			//没有声明任何构造函数
		};
		D d;		//正确:D的合成默认构造函数使用B的默认构造函数
		D d2(d);	//错误:D的合成拷贝构造函数是被删除的
		D d3(std::move(d));	//错误:隐式地使用D的被删除的拷贝构造函数
基类B含有一个可访问的默认构造函数和一个显示删除的拷贝构造函数。因为我们定义了拷贝构造函数，所以编译器将
不会为B合成一个移动构造函数。因此我们既不能移动也不能拷贝B的对象。如果B的派生类希望它自己的对象能被移动
和拷贝，则派生类需要自定义相应版本的构造函数。当然，在这一过程中派生类还必须考虑如何移动或拷贝基类的部分
成员。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。

移动操作与继承
	如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它
的派生类中也没有合成的移动操作。
	因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基
类中进行定义。我们的Quote可以使用合成的版本，不过前提是必须显示地定义这些成员。一旦Quote定义了自己的移
动操作，那么它必须同时显示地定义拷贝操作。
		class Quote{
		public:
			Quote() = default;	//队成员依次进行默认初始化
			Quote(const Quote&) = default;//对成员依次拷贝
			Quote(Quote &&) = default;//对成员依次移动
			Quote &operator=(const Quote&)=default;//对成员拷贝赋值
			Quote &operator=(Quote &&)=default;//对成员移动赋值
			virtual ~Quote()=default;
			//其他成员与之前的版本一致
		};
通过上面的定义，我们就能对Quote的对象逐成员地分别进行拷贝、移动、赋值和销毁操作了。而且除非Quote的派生
类中含有排斥移动的成员，否则他将自动获得合成的移动操作。

15.7.3	派生类的拷贝控制成员
	如我们在15.2.2节介绍过的，派生类构造函数在其初始化阶段中不但要初始化类自己的成员，还负责初始化派生
类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类的部分成
员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。
	和构造函数以及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源，如前所述，对象的成员是被隐
式销毁的：类似的，派生类对象的基类部分也是自动销毁的。
注意:
	当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

定义派生类的拷贝或移动构造函数
	当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分:
		class Base {/*...*/};
		class D : public Base{
		public:
			//默认情况下，基类的默认构造函数初始化对象的基类部分
			//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中
			//显示地调用该构造函数
			D(const D	&d):Base(d)	//拷贝基类成员
					/*D的成员的初始值*/{/*...*/}
			D(D  &&d):Base(std::move(d))//移动基类成员
					/*D的成员的初始值*/{/*...*/}
		};
初始值Base(d)将一个D对象传递给基类的构造函数。尽管从道理上来说，Base可以包含一个参数类型为D的构造
函数，但是在实际编程过程中通常不会这么做。相反，Base(d)一般会匹配Base的拷贝构造函数。D类型的对象b
将被绑定到该构造函数的Base &形参上。Base的拷贝构造函数负责将d的基类部分拷贝到要创建的对象。假如我们
没有提供基类的初始值的话:
		//D的这个拷贝构造函数可能是不正确的定义
		//基类部分被默认初始化，而非拷贝
		D(const D &d)/*成员初始值，但是没有提供基类初始值*/
		{/*....*/}
在上面的例子中，Base的默认构造函数将被用来初始化D对象的基类部分，假定D的构造函数从d中拷贝了派生类
成员，则这个新构建的对象的配置将非常奇怪：它的Base成员被赋予了默认值，而D成员的值则是从其他对象拷贝
得来的。
注意:
	在默认情况下，基类默认的构造函数初始化派生类对象的基类部分。如果我们想拷贝(或移动)基类部分，
则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝(或移动)构造函数。

派生类赋值运算符
	与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示地为其基类部分赋值:
		//Base::operator=(const Base &)不会被自动调用
		D &D::operator=(const D  &rhs)
		{
			Base::operator=(rhs);	//为基类部分赋值
			//按照过去的方式为派生类的成员赋值
			//酌情处理自赋值及释放已有资源等情况
			return *this;
		}
上面的运算符首先显示地调用基类赋值运算符，令其为派生类对象的基类部分赋值。基类的运算符(应该可以)正确
地处理自赋值的情况，如果赋值命令是正确的，则基类运算符将释放掉其左侧运算对象的基类部分的旧值。然后利
用rhs为其赋值一个新值。随后，我们继续进行其他为派生类成员赋值的工作。
	值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使
用它们。例如，对于Base::operator=调用语句将执行Base的拷贝赋值运算符，至于该运算符是由Base显示定义
还是由编译器合成的无关紧要。

派生类析构函数
	如前所述，在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。
因此和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源:
		class D : public Base{
		public:
			//Base::~Base被自动调用执行
			~D(){/*该处由用户定义清除派生类成员的操作*/}
		};
对象销毁的顺序正好与其创建的顺序相反:派生类析构函数首先执行，然后是基类的析构函数，依次类推，沿着继
承体系的反方向直至最后。

在构造函数和析构函数中调用虚函数
	如我们所知，派生类对象的基类部分将首先被创建。当执行基类的构造函数时，该对象的派生类部分是未被初
始化的状态。类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁了。
由此可知，当我们执行上述基类成员的时候，该对象处于未完成的状态。
	为了能够正确地处理这种未完成状态。编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就
是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把
对象的类和构造函数的类看成同一个的要求；对于析构函数也是同样的道理。上述的绑定不但对直接调用虚函数有效，
对间接调用也有效的，这里的间接调用是指通过构造函数(或析构函数)调用另一个函数。
	为了理解上述的行为，不妨考虑当基类构造函数调用虚函数的派生类版本时会发生什么情况。这个虚函数可能会
访问派生类的成员，毕竟，如果它不需要访问派生类成员的话，则派生类直接使用基类的虚函数版本就可以了。然而，
当执行基类构造函数时，它要用到的派生类成员尚未初始化，如果我们允许这样也的话，则程序很可能会崩溃。
注意:
	如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型对应的虚函数
版本。
也就是说，在构造函数或析构函数中调用的虚函数应该是该构造函数/析构函数对应的类的虚函数，而不是其他派
生类的虚函数。这个时候应该讲究的是静态类型和动态类型是一样的。

15.7.4	继承的构造函数
	在C++11新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常
规的方式继承而来的。但是为了方便，我们不妨姑且称其为"继承"的。一个类只初始化它的直接基类，出于同样
的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接
定义这些构造函数，则编译器将为派生类合成它们。
	派生类继承基类的构造函数的方式是提供了一条注明了(直接)基类名的using声明语句。举个例子，我们可
以重新定义Bulk_quote类，令其继承Disc_quote类的构造函数:
		class Bulk_quote : public Disc_quote{
		public:
			using Disc_quote::Disc_quote;	//继承Disc_quote的构造函数
			double net_price(std::size_t)const;
		};
通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将
令编译器产生代码。对于基类的每个构造函数，编译器都生成有一个与之对应的派生类构造函数。换句话说，对
于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。
	这些编译器生成的构造函数形如:
		derived(parms) : base(args){}
其中，derived是派生类的名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的
形参传递给基类的构造函数。在我们的Bulk_quote类中，继承的构造函数等价于:
		Bulk_quote(const std::string &book,double price,std::size_t qty,
					double disc):Disc_qoute(book,price,qty,disc){}
如果派生类含有自己的数据成员，则这些成员将被默认初始化。
小结下:
	这里的继承的构造函数，其实我现在目前的理解是，可以不用去在派生类定义一个构造函数来显示的使用基类的
构造函数去初始化基类的成员。直接继承过来，编译器自动给你生成派生类的构造函数，然后去显示调用该基类被继
承过来的构造函数。但是派生类的自己的成员则被默认初始化。

继承的构造函数的特点
	和普通成员using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using
声明出现在哪，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同
样的规则。
	而且，一个using声明语句不能指定explicit或constexpr。如果基类的构造函数是explicit或constexpr，
则继承的构造函数也拥有相同的属性。
	当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中
每个构造函数分别省略掉一个含有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中的第二个
形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参(没有默认实参)，另一个构造函数只
接受一个形参，它对应于基类中最左侧的没有默认值的形参。
	如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。第一个例外是
派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数
具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。
	第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按正常规则被合成。继承的构造函数不会被
作为用户定义的构造函数来使用，因此，如果以一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。
注意:
	类不会继承默认、拷贝和移动构造函数，编译器会为派生类合成他们。

15.8	容器与继承
	当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元
素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。
	举个例子，假定我们想定义了一个vector，令其保存用户准备购买的几种书籍。显然，我们不应该用vector保存
Bulk_quote对象。因为我们不能将Quote对象转换为Bulk_quote，所以我们将无法把Quote对象放置在该vector中。
	其实，我们也不应该使用vector保存Quote对象。此时，虽然我们可以把Bulk_quote对象放置在容器中，但是
这些对象再也不是Bulk_quote对象了:
		vector<Quote> basket;
		basket.push_back(Quote("0-201-82470-1",50);
		//正确:但是只能把对象的Quote部分拷贝给basket
		basket.push_back(Bulk_quote("0-201-54848-8",50,10,.25);
		//调用Quote定义的版本，打印750,即15*$50
		cout<<basket.back().net_price(15)<<endl;
basket的元素是Quote对象，因此当我们向该vector中添加一个Bulk_quote对象时，它的派生类部分将被忽
略掉。
注意:
	当派生类对象被赋值给基类对象时，其中的派生类部分将被"切掉"，因此容器和存在继承关系的类型无法兼容。

在容器中放置(智能)指针而非对象
	当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针(更好的选择是智能指针)。
和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型:
		vector<shared_ptr<Quote>> basket;
		basket.push_back(make_shared<Quote>("0-201-82470-1",50);
		basket.push_back(make_shared<Bulk_quote>("0-201-54848-8",50,10,.25);
		//调用Quote定义的版本:打印562.5即在15*50中扣除掉折扣金额
		cout<<basket.back()->net_price(15)<<endl;
因为basket存放着shared_ptr，所以我们必须解引用basket.back()的返回值以获得运行net_price的对象。
我们通过在net_price的调用中使用->以达到这个目的。如我们所知，实际调用的net_price版本依赖于指针所指
对象的动态类型。
	值得注意的是，我们将在basket定义成shared_ptr<Quote>，但是在第二个push_back中传入的是一个
Bulk_quote对象的shared_ptr，正如我们可以将一个派生类指针转换成基类指针一样，我们也能把一个派生类
的智能指针转换成基类的智能指针。在此例中，make_shared<Bulk_quote>返回一个shared_ptr<Bulk_quote>对象，当我们调用push_back时该对象被转换
为shared_ptr<Quote>。因此尽管形式上有所差别，但实际上basket的所有元素的类型都是相同的。

15.8.1	编写Basket类
	对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和
引用。因为指针会增加程序的复杂性，所以我们经常定义一些辅助的类来处理这种复杂情况。首先，我们定义一个表示
购物的篮子的类:
		class Basket{
		public:
			//Basket使用合成的默认构造函数和拷贝控制成员
			void add_item(const std::shared_ptr<Quote> &sale)
			{
				item.insert(sale);
			}
			//打印每本书的总价和购物篮中所有数的总价
			double total_recipe(std::ostream &)const;
		private:
			//该函数用于比较shared_ptr,multiset成员会使用到它
			static bool compare(const std::shared_ptr<Quote> &lhs,
								const std::shared_ptr<Quote> &rhs)
			{
				return lhs->isbn() < rhs->isbn();
			}
			//multiset保存多个报价，按照compare成员排序
			std::multiset<std::shared_ptr<Quote>,decltype(compare)*>items(compare);
		};
我们的类使用一个multiset来存放交易信息，这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，
它的所有交易信息都保存在一起。
	multiset的元素是shared_ptr，因为shared_ptr没有定义小于运算符，所以为了对元素排序我们必须提供
自己的比较运算符。在此例中，我们定义了一个名为compare的私有静态成员，该成员负责比较shared_ptr所指对
象的isbn，我们初始化multiset，通过类内初始值比较函数:
		//multiset保存多个报价，按照compare成员排序
		std::multiset<std::shared_ptr<Quote>,decltype(compare)*>items(compare);
这个声明看起来不太容易理解，但是从左到右读的话，我们就能明白它其实定义了一个指向Quote对象的shared_ptr
的multiset。这个multiset将使用一个与compare成员类型相同的函数来对其中的元素进行排序。multiset成
员的名字是items，我们初始化items并令其使用我们的compare函数。

定义Basket的成员
	Basket类只定义两个操作，第一个成员是我们在类的内部定义的add_item成员，该成员接受一个指向动态分
配的Quote的shared_ptr，然后将这个shared_ptr放置在multiset中，第二个成员的名字是total_recipt,
它负责将购物蓝的内容逐项打印成清单，然后返回购物蓝中所有物品的总价格:
		double Basket::total_recipt(ostream &os)const
		{
			double sum = 0.0;	//保存实时计算出的总价格
			//iter指向ISBN相同的一批元素中的第一个
			//upper_bound返回一个迭代器，该迭代器的是通过大于当前这个元素的初始位置
			for(auto iter = items.cbegin();iter != items.cend();
					iter = items.upper_bound(*iter)){
				//我们知道在当前的Basket中至少有一个该关键字的元素
				//打印该书籍对应的项目
				sum += print_total(os,**iter,items.count(*iter));
			}
			os<<"Total Sale : "<<sum<<endl;
			return sum;
			/*该函数的作用是:它在multiset中存放相应的书籍，但是这个书籍是按照你的
			isbn来排序的，所以假设multiset中的书籍有book1,book2,book2,book3,book3
			book3,book4,book4。那么首先介绍一下upper_bound，这个的返回结果是
			大于你的形参的第一个元素,比方说，你的第一个输入的是book1,那么根据你的
			定义的compare函数，也就是给multiset定义的大于号。那么返回的结果就是book2
			的迭代器，同理输入的是book2，那么返回的是book3。这样for循环就可以进行了。
			那么sum的时候，直接使用count函数来计算有多少book2或者book3之类的
			*/
		}
我们的for循环首先定义并初始化iterr，令其指向multiset的第一个元素。条件部分检查iter是否等于items.cend()；
如果相等，表明我们已经处理完了所有购买记录，接下来就应该跳出for循环；否则，如果不相等，则继续处理下一本书籍。
	比较有趣的是，for循环的递增方式。与通常的循环语句依次读取每个元素不同，我们直接令iter指向下一个关键字，
调用upper_bound函数可以令我们跳过与当前关键字相同的所有元素。对于upper_bound函数来说，它返回的是一个迭
代器，该迭代器指向所有与iter关键字相等的元素中最后一个元素的下一位置。因此，我们得到的迭代器或者指向集合的
尾末，或者指向下一本书籍。
	在for循环内部，我们通过调用print_total来打印购物篮中每本书籍的细节:
		sum += print_total(os,**iter,items.count(*iter));
print_total的实参包括一个用于写入数据的ostream、一个待处理的Quote对象和一个计数值。当我们解引用iter
后将得到一个指向准备打印的对象的shared_ptr。为了得到这个对象，必须解引用该shared_ptr。因此，**iter
是一个Quote对象(或者Quote的派生的对象)。我们使用multiset的count成员来统计在multiset中有多少元素的
键值相同(即ISBN相同)。
	如我们所知,print_total调用了虚函数net_price，因此最终的结算结果依赖于**iter的动态类型。print_total
函数打印并返回给定书籍的总价格，我们把这个
结果添加到sum当中，最后当前循环结束后打印sum。

隐藏指针
	Basket的用户仍然必须处理动态内存，原因是add_item需要接受一个shared_ptr参数。因此，用户不得不
按照如下形式编写代码:
		Basket bsk;
		bsk.add_item(make_shared<Quote>("123",45));
		bsk.add_item(make_shared<Bulk_quote>("345",45,3,.15));
我们的下一步是重新定义add_item，使得它接受一个Quote对象而非shared_ptr。新版本的add_item将负责
处理内存分配，这样它的用户将不必再受困于此了。我们将定义两个版本，一个拷贝它给定的对象，另一个则采取
移动操作:
		void add_item(const Quote &sale);	//拷贝给定对象
		void add_item(Quote &sale);		//移动给定的对象
唯一的问题是add_item不知道要分配的类型，当add_item进行内存分配时，它将拷贝(或移动)它的sale参数。
在某处可能会有一条如下形式的new表达式:
		new Quote(sale);
不幸的是，这条表达式所做的工作可能是不正确的:new为我们请求的类型分配内存，因此这条表达式将分配一个Quote
类型的镀锡并且拷贝sale的Quote部分，然而，sale实际指向的可能是Bulk_quote对象，此时，该对象被迫切
掉一部分。

模拟虚拷贝
	为了解决上述的问题，我们给Quote类添加一个虚函数，该函数将申请一份当前对象的拷贝:
		class Quote{
		public:
			//该虚函数返回当前对象的一份动态分配的拷贝
			//这些成员使用的引用限定符参见
			virtual Quote *clone()const &{return new Quote(*this);}
			virtual Quote *clone() &&{return new Quote(std::move(*this));}
			//其他成员与之前的版本一致
		};
		class Bulk_quote : public Quote{
			Bulk_quote *clone()const &{return new Bulk_quote(*this);}
			Bulk_quote *clone() && {return new Bulk_quote(std::move(*this));}
			//其他成员与之前的版本一致
		};
因为我们拥有add_item的拷贝和移动版本，所以我们分别定义了clone的左值和右值版本。每个clone函
数分配当前类型的一个新对象，其中，const左值引用成员将它自己拷贝给新分配的对象；右值引用成员则将自
己移动到新数据中。
	我们可以使用clone很容易地写出新版本的add_item:
		class Basket{
		public:
			void add_item(const Quote &sale)//拷贝给定的对象
			{
				items.insert(std::shared_ptr<Quote>(sale.clone()));
			}
			void add_item(Quote &&sale){
				items.insert(std::shared_ptr<Quote>(std::move(sale).clone()));
			}
			//其它成员与之前的版本一致
		};
和add_item本身一样，clone函数也根据作用于左值还是右值而分为不同的重载版本。在此例中，第一个add_item
函数调用clone的const左值版本，第二个函数调用clone的右值引用版本。在右值版本中，尽管sale的类型是右值
引用类型，但实际上sale本身(和任何其他变量一样)是个左值，因此，我们调用move把一个右值引用绑定到sale上。
	我们的clone函数也是一个虚函数。sale的动态类型(通常)绝定了到底运行Quote的函数还是Bulk_quote的
函数。无论我们是拷贝还是移动数据。clone都返回一个新分配对象的指针，该对象与clone所属的类型一致。我们把
一个shared_ptr绑定到这个对象上，然后调用insert将这个新分配的对象添加到items中。注意，因为shared_ptr
支持派生类向基类的类型转换，所以我们能把shared_ptr<Quote>绑定到Bulk_quote *上。

15.9	文本查询程序再探
	接下来，我们扩展12.3节的文本查询程序，用它作为说明继承的最后一个例子。在上一版的程序中，我们可以查询
在文件中某个指定单词的出现情况。我们将在本节扩展该程序使其支持更多更复杂的查询操作。在后面的例子中，我们
将针对下面这个小故事展开查询:
		Alice Emma has long flowing red hair
		Her Daddy says when the wind blows
		through herrr hair,it looks almost alive
		like a fiery bird in flight
		A beatutiful fiery bird,he tells her
		magical but untamed
		"Daddy , shush, there is no such thing,"
		she tells him,at the same time wanting
		him to tell herrr more.
		Shyly,she asks,"I mean, Daddy,is there?"
我们的系统将支持如下查询形式:
		>>>	单词查询，用于的到匹配某个给定string的所有行
			Executing Query for : Daddy
			Daddy occurs 3 times
			(line 2) Her Daddy says when the wind blows
			(line 7) "Daddy , shush, there is no such thing,"
			(line 10) Shyly,she asks,"I mean, Daddy,is there?"
		>>>	逻辑非查询，使用~运算符的到不匹配查询条件的所有行:
			Executing Query for : ~(Alice)
			~(Alice) occurs 9 times
			(line 2) Her Daddy says when the wind blows
			(line 3) through herrr hair,it looks almost alive
			(line 4) like a fiery bird in flight
			.......
		>>>	逻辑或查询，使用 | 运算符返回匹配两个条件中任意一个的行:
			Executing Query for : (hair | Alice)
			(hair | Alice) occurs 2 times
			(line 1) Alice Emma has long flowing red hair
			(line 3) through herrr hair,it looks almost alive
		>>>	逻辑与查询，使用&运算符返回匹配两个条件的行:
			Executing Query for : (hair & Alice)
			(hair& Alice) occurs 1 time
			(line 1) Alice Emma has long flowing red hair
此外，我们还希望能够混合使用这些运算符，比如:
			fiery & bird | wind
在类似这样的例子中，我们将使用C++通用的优先级规则复杂表达式求值。因此，这条查询语句所得行应该是人如下
二者之一；在该行中或者fiery和bird同时出现或者出现了wind:
			Executing Query for : ((fiery & bird) | wind)
			((fiery & bird) | wind) ouccurs 3 times
			(line 1) Her Daddy says when the wind blows 
			(line 4) like a fiery bird in flight
			(line 5) A beatutiful fiery bird,he tells her
在输出内容中手偶县是那条查询语句，我们使用圆括号来表示查询被解释和执行的次序。与之前实现的版本一致，
接下来系统将按照查询结果中的行号升序显示结果并且每一行只显示一次。

15.9.1	面向对象的解决方案
	我们可能会认为使用12.3.2节的TextQuery类表示单词查询，然后从该类中派生出其他查询是一种可行的方案。
	然而，这样的实际实际上存在缺陷，为了理解其中的原因，我们不妨考虑逻辑非的查询。单词查询查找一个指定
的单词，为了让逻辑非查询按照单词的查询方式执行，我们将不得不定义逻辑非查询所要查找的单词。但是在一般情
况下，我们无法想得到这样的单词。相反，一个逻辑非查询中含有一个结果值需要取反的查询语句(单词查询或任何
其他查询):类似的，一个逻辑与查询和一个逻辑或查询包含两个结果值需要合并的查询语句。
	由上述观察结果可知，我们应该将几种不同的查询建模成相互独立的类，这些类共享一个基类:
		WordQuery	//Daddy
		NotQuery	//~Alice
		QrQuery		// hair | Alice
		AndQuery	// hair & Alice
这些类只包含两个操作:
		>>>	eval,接受一个TextQuery对象并返回一个QueryResult，eval函数使用给定的TextQuery
对象查找与之匹配的行。
		>>>	rep,返回基础查询的string表示的形式，eval函数使用rep创建一个表示匹配结果的QueryResult，
输出运算符使用rep打印查询表达式。

关键概念:继承与组合
	继承体系的设计本身是一个非常复杂的问题，已超出了本书的范围。然而，有一条设计准则非常重要也非常
基础，每个程序员都应该熟悉它。
	当我们令一个类公有地继承另一个类时，派生类应当反映与基类的"是一种(Is A)"关系。在设计良好的类
体系当中，公有派生类的对象应该可以用在任何需要基类对象的地方。
	类型之间的另一种常见的关系是"有一个(Has A)"关系，局哟偶偶这种关系的类暗含成员的意思。在我们的
书店示例中，基类表示的是按规定价格销售的书籍的报价。Bulk_quote"是一种"报价结果，只不过它
使用的价格策略不同。我们的书店类都"有一个"价格成员和ISBN成员。

抽象基类
	如我们所知，在这四种查询之间并不存在彼此继承的关系，从概念上来说它们互为兄弟。因为所有这些类都共享
同一个接口，所以我们需要定义一个抽象基类来表示该接口。我们将所需的抽象基类命名为Query_base，依次来表
示它的角色是整个查询继承体系的根节点。
	我们的Query_base类把eval和rep定义成纯虚构函数。其他代表某种特定查询类型的类必须覆盖这两个函数。
我们将从Query_base直接派生出WordQuery和NotQuery。AndQuerry和OrQuery都具有系统中其他类
所不具备的一个特殊属性：他们各自包含两个运算对象。为了对这种属性建模，我们定义另外一个名为BinaryQuery
的抽象基类，该抽象基类用于表示含有两个运算对象的查询。AndQuery和OrQuery继承自BinaryQuery，而BinaryQuery
继承自Query_base。由这些分析我们将得到如图15.2所示的类设计结果:
					Query_base
				/       |        \
			   /        |         \
			  /         |          \
		   WordQuery  NotQuery   BinaryQuery
							　　　　　　　/       \
								  /         \
								 /           \
							　 AndQuery     OrQuery
将层次关系隐藏于接口类中
	我们的程序将致力于计算查询结果，而非仅仅构建查询的体系。为了使程序能正常运行，我们必须首先创建查询
命令，最简单的方法是编写C++表达式。例如，可以编写下面的代码来生成之前描述的复合查询:
		Query q = Query("fiery") & Query("bird") | Query("wind");
	如上所述，其隐含的意思是用户层代码将不会直接使用这些继承的类；相反，我们将定义一个名为Query的接口
类，由它负责隐藏整个继承体系。Query类将保存一个Query_base指针，该指针绑定到Query_base的派生类对象
上。Query类与Query_base类提供的操作是相同的；eval用于求查询的结果，rep用于生成查询的string版本，同
时Query也会定义一个重载的输出运算符用于显示查询。
	用户将通过Query对象的操作间接地创建并处理Query_base对象。我们定义Query对象的三个重载运算符以
及一个接受string参数的Query构造函数，这些函数动态分配一个新的Query_base派生类的对象:
		>>>	&运算符生成一个绑定到新的AndQuery对象上的Query对象
		>>>	|运算符生成一个绑定到新的OrQuery对象上的Query对象
		>>>	~运算符生成一个绑定到新的NotQuery对象上的Query对象
		>>>	接受string参数的Query构造函数生成一个新的WordQuery对象。


									WordQuery
									 [fiery]
                            AndQuery /
						       [  ] /
                               [  ]/
                               [  ]\
					  OrQuery /     \
		    Query      [   ] /       \
		q =  [  ]----->[   ]/        [bird]
                       [   ]\       WordQuery
							 \
							  \
							  [wind]
							 WordQuery
		由表达式创建的对象
		Query q = Query("fiery") & Query("bird") | Query("wind");
				图15.3	使用Query表达式创建的对象

理解这些类的工作机理
	在这个应用程序中，很大一部分工作是构建代表用户查询的对象，对于读者来说认识到这一点重要。例如，像上面
这样的表达式将生成如图15.3所示的一系列相关对象的集合。
	一旦对象树构建完成后，对某一条查询语句的求值(或生成表示形式的)过程基本上就转换为沿着箭头方向依次对
每个对象求值(或显示)的过程(由编译器为我们组织管理)。例如，如果我们对q(即树的根节点)调用eval函数，则该
函数语句将令q所指的OrQuery对象eval它自己。对该OrQuery求值实际上对它的两个运算对象执行eval操作。一个
运算对象是AndQuery，另一个是查找单词wind和WordQuery。接下来，对AndQuery求值转换为对它的两个WordQuery
求值，分别生成单词fiery和bird的查询结果。
	对于面向对象编程的新手来说，要想理解一个程序，最困难的部分往往是理解程序的设计思路。一旦你掌握了程序
的设计思路，接下来的实现也就水到渠成了。为了帮助读者理解程序设计的过程，我们在表15.1中整理了之前那个例子
用到的类，并对其进行了简要的描述:
				15.1	概述:Query程序设计
	Query程序接口类和操作
						该类读入一个给定的文件并构建以一个查找图。这个类包含一个
		TextQury		query操作，它接受以一个string实参，返回一个QueryResult
						对象；该QueryResult对象表示string出现的行
		QueryResult		该类保存一个query操作的结果
		Query			是一个接口类，指向Query_base派生类的对象
		Query q(s)		将Query对象q绑定到一个存放着string s的新WordQuery
						对象上
		q1 & q2			返回一个Query对象，该Query绑定到一个存放q1和q2的新
						AndQuery对象上
		q1 | q2			返回一个Query对象，该Query绑定到一个存放q1和q2的新
						OrQuery对象上
		~q				返回有一个Query对象，该Query绑定到一个存放q的新NotQuery
						对象上
	Query程序实现类
		Query_base		查询类的抽象基类
		WordQuery		Query_base的派生类，用于查找一个给定的单词
		NotQuery		Query_base的派生类，查询结果是Query运算对象没有出现
						的行的集合
		BinaryQuery		Query_base派生出来的另一个抽象基类，表示有两个运算对
						象的查询
		OrQuery			BinaryQuery的派生类，返回它的两个运算对象分别出现的行
						的并集
		AndQuery		BinaryQuery的派生类，返回它的两个运算对象分别出现的行
						的交集

15.9.2	Query_base 和 Query类
	下面我们开始程序的实现过程，首先定义Query_base类:
		//这是一个抽象基类，具体的查询类型从中派生，所有成员都是private的
		class Query_base{
			friend class Query;
		protected:
			using line_noo = TextQuery::line_no;	//用于eval函数
			virtual ~Query_base() = default;
		private:
			//eval返回与当前Query匹配的QueryResult
			virtual QueryResult eval(const TextQuery &)const = 0;
			virtual std::string rep() const = 0;
		};
eval和rep都是纯虚函数，因此Query_base是一个抽象基类。因为我们不希望用户或者派生类直接使用Query_base，
所以它没有public成员。所有对Query_base的使用都需要通过Query对象，因为Query需要调用Query_base
的虚函数，所以我们将Query声明成Query_base的友元。
	受保护的成员line_no将在eval函数内部使用。类似的，析构函数也是受保护的，因为它将(隐式地)在派生类
析构函数中使用。

Query类
	Query类对外提供接口，同时隐藏了Query_base的继承体系。每个Query对象都含有一个指向Query_base对
象的shared_ptr。因为Query是Query_base的唯一接口，所以Query必须定义自己的eval和rep版本。
	接受一个string参数的Query构造函数将创建一个新的WordQuery对象，然后将它的shared_ptr成
员绑定到这个新创建的对象上。&、|和~运算符分别创建AndQuery,OrQuery和NotQuery对象，这些
运算符将返回一个绑定到新创建的对象上的Query对象。为了支持这些运算符，Queery还需要另外一个构造函数，它
接受指向Query_base的shared_ptr并且存储给定的指针。我们将这个构造函数声明为私有的。原因是因为我们不希
望一般的用户代码能随便定义Query_base对象。因为这个构造函数是私有的，所以我们需要将三个运算符声明为友元:
	在形成了上述设计思路后，Query类本身就比较简单了:
		//这是一个管理Query_base继承体系的接口类
		class Query{
			//这些运算符需要访问接受shared_ptr的构造函数，而该函数是私有的
			friend Query operator~(const Query &);
			friend Query operator|(const Query &,const Query &);
			friend Query operator&(const Query &,const Query &);
		public:
			Query(const std::string &);	//构建一个新的WordQuery
			QueryResult eval(const TextQuery &t)const { return q->eval(t);}
			std::string rep()const { return q->rep();}
		private:
			Query(std::shared_ptr<Query_base> query):q(query){}
			std::shared_ptr<Query_base> q;
		};
我们首先将创建Query对象的运算符声明为友元，之所以这么做是因为这些运算符需要访问那个私有构造函数。
	在Query的公有接口部分，我们声明了接受string的构造函数，不过没有对其进行定义。因为这个构造函数
将要创建一个WordQuery对象，所以我们应该首先定义WordQuery类，随后才能定义string的Query构造函
数。
	另外两个公有成员是Query_base的接口，其中，Query操作使用它的Query_base指针来调用各自的Query_base
虚函数。实际调用哪个虚函数版本将由q所
指对象类型决定，并且直到运行时才最终确定下来。

Query的输出运算符
	输出运算符可以很好的解释我们的整个查询系统是如何工作的:
		std::ostream &operator<<(std::ostream &os,const Query &query)
		{
			//Query::rep通过它的Query_base指针对rep()进行了虚调用
			return os << query.rep();
		}
当我们打印一个Query时，输出运算符调用Query类的公有rep成员。运算符函数通过指针成员虚调用当前Query
所指对象的rep成员，也就是说，当我们编写如下代码时，
		Query andq = Query(sought1) & Query(sought2);
		cout<<andq<<endl;
输出运算符将调用andq的Query::rep，而Query::rep通过它的Query_base指针虚调用Query_base版本
的rep函数。因为andq指向的是一个AndQuery对象，所以本次的调用将运行AndQuery::rep。

15.9.3	派生类
	对于Query_base的派生类来说，最有趣的部分是这些派生类如何表示一个真实的查询。其中WordQuery类最
直接，它的任务就是保存要查找的单词。
	其他类分别操作一个或两个运算对象。NotQuery有一个运算对象，AndQuery和OrQuery有两个。在这些类
中，运算对象可以是Query_base的任
意一个派生类的对象:一个NotQuery对象可以被用在WordQuery、AndQuery、OrQuery或另一个NotQuery中，
为了支持这种灵活性，运算对象必须以Query_base指针的形式存储。
这样我们就能把该指针绑定到任何我们需要的
具体类上。
	然而实际上我们的类并存储Query_base指针，而是直接使用一个Query对象。就像用户代码可以通过接口类得
到简化一样，我们也可以使用接口类来简化我们自己的类。
	至此我们已经清楚了所有类的设计思路，接下来依次实现它们。

WordQuery类
	一个WordQuery查找一个给定的string，它是在给定的TextQuery对象上实际执行查询唯一一操作:
		class WordQuery : public Query_base{
			friend class Query;
			WordQuery(const std::string &s) : query_word(s){}
			//具体的类:WordQuery将定义所有继承而来的纯虚函数
			QueryResult eval(const TextQuery &t)const {return t.query(query_wirrd);}
			std::string rep() const {return query_word;}
			std::string query_word;//要查找的单词
		};
和Query_base一样，WordQuery没有公有成员。同时，Query必须作为WordQuery的友元，这样Query才能访问
WordQuery的构造函数。
	每个表示具体查询的类都必须定义继承而来的纯虚函数eval和rep。我们在WordQuery类的内部定义这两个
操作；eval调用其TextQuery参数的query成员，由query成员在文件中实际进行查找；rep返回这个WordQuery
表示的string(即query_word)。
	定义了WordQuery类之后，我们就能定义接受string的Query构造函数了:
		inline Query::Query(const std::string &s):q(new WordQuery(s)){}
这个构造函数分配一个WordQuery，然后令其指针成员指向新分配的对象。

NotQuery类及~运算符
	~运算符生成一个NotQuery，其中保存着一个需要对其取反的Query:
		class NotQuery:public Query_base{
			friend Query operator~(const Query &);
			NotQuery(const Query &q):query(q){}
			//具体的类:NotQuery将定义所有继承而来的纯虚函数
			//rep的返回的就是你的输出的格式
			std::string rep()const {return "~("+query.rep() + ")";}
			QueryResult eval(const TexQuery &)const;
			Query query;
		};
		inline Query operator~(const Query &operand)
		{
			return std::shared_ptr<Query_base>(new NotQuery(operand));
		}
因为NotQuery的所有成员都是私有的，所以我们一开始就要把~运算符设定了友元。为了rep一个NotQuery，我们
需要将~与基础的Query连接在一起。我们在输出的结果中加上适当的括号，这样读者就可以清楚地知道查询的优先级
了。
	值得注意的是,在NotQuery自己的rep成员中对rep的调用最终执行的是一个虚调用:query.rep()是对Query
类rep成员的非虚调用。接着Query::rep将调用q->rep()，这是一个通过Query_base指针进行的虚调用。
	~运算符动态分配一个新的NotQuery对象，其return语句隐式地接受一个shared_ptr<Query_base>的Query
构造函数。也就是说，return语句等价于:
		//分配一个新的NotQuery对象
		//将所得的NotQuery指针绑定到一个shared_ptr<Query_base>
		shared_ptr<Query_base>tmp(new NotQuery(expr));
		return Query(tmp);	//使用接受一个shared_ptr的Query构造函数
	eval成员比较复杂，因此我们将在类的外部实现它。15.9.4节将专门介绍如何定义eval函数。

BinaryQuery类
	BinaryQuery类也是一个抽象基类，它保存操作两个运算对象的查询类型所需的数据:
		class BinaryQuery : public Query_base{
		protected:
			BinaryQuery(const Query &l,const Query &r,std::string s):
				lhs(l),rhs(r),opSym(s){}
			//抽象类:BinaryQuery不定义eval
			std::string rep()const {
				 return "(" + lhs.rep() + " "+opSym + " " +rhs.rep() + ")";
			}
			Query lhs,rhs;	//左侧和右侧运算对象
			std::string opSym;	//运算符的名字
		};
BinaryQuery中的数据是两个运算对象及相对应的运算符符号，构造函数负责接受两个运算对象和有一个运算符符号，
然后将它们存储在对应的数据成员中。
	要向rep一个BinaryQuery，我们需要生成一个带括号的表达式。表达式的内容依次包括左侧运算对象、运
算符以及右侧运算对象。就像我们显示NotQuery的方法一样，对rep的调用最终是对lhs和rhs所指Query_base对
象的rep函数进行虚调用。
注意:
	BinaryQuery不定义eval而是继承了该纯虚函数。因此，BinaryQuery也是一个抽象基类，我们不能
创建BinaryQuery类型的对象。

AndQuery类、OrQuery类及相应的运算符
	AndQuery类和OrQuery类以及它们的运算符都非常相似:
		class AndQuery : public BinaryQuery {
			friend Query operator&(const Query &,const Query &);
			AndQuery(const Query &left,const Query &right):BinaryQuery(left,right,"&"){}
			//具体的类：AndQuery继承了rep并且定义了其他纯虚函数
			QueryResult eval(const TextQuery &)const;
		};
		inline Query operator&(const Query &lhs,const &rhs)
		{
			return std::shared_ptr<Query_base>(new AndQuery(lhs,rhs));
		}
		class OrQuery : public BinaryQuery{
			friend Query operator|(const Query &,const Query &);
			OrQuery(const Query &left,const Query &right):BinaryQuery(left,right,"|"){}
			QueryResult eval(const TextQuery &)const;
		};
		inline Query operator|(const Query &lhs,const Query &rhs){
			return std::shared_ptr<Query_base>(new OrQuery(lhs,rhs));
		}
这两个类将各自的运算符定义成友元，并且各自定义了一个构造函数通过运算符创建BinaryQueryy基类部分。他们
继承BinaryQuery的rep函数，但是覆盖了eval函数。和~运算符一样，&和|运算符也返回一个绑定到新分配对象
上的shared_ptr。在这些运算符中，return语句负责将shared_ptr转换成Query。

15.9.4	eval函数
	eval函数是我们这个查询系统的核心。每个eval函数作用于各自的运算对象，同时遵循的内在逻辑也有所区别:
OrQuery的eval操作返回两个运算对象查询结果的并集，而AndQuery返回交集。与它们相比，NotQuery的eval的
eval函数更加复杂一些，它需要返回运算对象没有的文本行。
	为了支持上述eval函数的处理，我们需要使用QueryResult，在它当中定义了12.3.2节练习添加的成员。假设
QueryResult包含begin和end成员，它们允许我们在QueryResult保存的行号set中进行迭代；另外假设QueryReuslt
还包含以一个名为get_file的成员，它返回一个指向待查询文件的shared_ptr。

注意:
	我们的Query类使用了练习12.3.2节为QueryResult定义的成员。

OrQuery::eval
	一个OrQuery表示的是它的两个运算对象结果的并集，对于每个运算对象来说，我们通过调用eval得到它的查询
结果。因为这些运算对象的类型是Query，所以调用eval也就是调用Query::eval，而后者实际上是对潜在的Query_base
对象的eval进行虚调用。每次调用完成后，得到的结果是一个QueryResult，它表示运算对象出现的行号。
我们把这些行号组织在一个新的set中:
		//返回运算对象查询结果set的并集
		QueryResult OrQuery::eval(const TextQuery &text)const
		{
			//通过Query成员lhs和rhs进行的虚调用
			//调用eval返回每个运算对象的行号拷贝到结果set中
			auto right = rhs.eval(text),left = lhs.eval(text);
			//将左侧运算对象的行号拷贝到set中
			auto ret_lines = make_shared<line_no>(left.begin(),left.end());
			//插入右侧运算对象所得的行号
			ret_lines->insert(right.begin(),right.end());
			//返回一个新的QueryResult，它表示lhs和rhs的并集
			return QueryQesult(rep(),ret_lines,left.get_file());
		}
我们使用接受一对迭代器的set构造函数初始化ret_lines。一个QueryResult的begin和end成员返回行号
set的迭代器，因此，创建ret_lines的过程实际上拷贝了left集合的元素。接下来对ret_lines调用insert，
并将right的元素插入进来。调用结束后，ret_lines将包含left或right中出现过的所有行号。
	eval函数在最后构建并返回一个表示混合查询匹配的QueryReuslt。QueryResult的构造函
数接受三个实参:一个表示查询的string、一个指向匹配行号的set的shared_ptr，调用get_file获取指向
文件的shared_ptr。因为left和right指向的是同一个文件，所以使用哪个执行get_file函数并不重要。

AndQuery::eval
	AndQuery的eval和OrQuery很类似，唯一的区别就是它调用了一个标准库算法来求得两个查询结果中共
有的行:
		//返回运算对象查询结果set的交集
		QueryResult AndQuery::eval(const TextQuery &text)const
		{
			//通过Query运算对象进行的虚调用，以获得运算对象的查询结果set
			auto left = lhs.eval(text),right = rhs.eval(text);
			//保存left和right交集的set
			auto ret_lines = make_shared<set<line_no>>{};
			//本次调用的目的迭代器向ret添加元素
			set_intersection(left.begin(),left.end(),right.begin(),right.end(),
							inserter(*ret_lines,ret_lines->begin()));
			return QueryResult(rep(),ret_lines,left.get_file());
		}
其中我们使用标准库算法set_intersection来合并两个set，也就是包含共有的成员。
	set_intersection算法接受五个迭代器。它使用前四个迭代器表示两个输入序列，最后有一个实参表示
目的位置。该算法将两个输入序列中共同出现的元素写入到目的位置中。
	在上述调用中我们传入一个插入迭代器作为目的位置。当set_intersection向这个迭代器写入
内容时，实际上是向ret_lines插入一个新元素。
	和OrQuery的eval函数一样，AndQuery的eval函数也在最后构建并返回一个表示混合查询匹配的QueryResult。

NotQuery::eval
	NotQuery查询运算对象没有出现的文本行:
		//返回其运算对象的结果set中不存在的行
		QueryResult NotQuery::eval(const TextQuery &text)const{
			//通过Query运算对象对eval进行虚调用
			auto result = query.eval(text);
			//开始时结果set为空
			auto ret_lines = make_shared<set<line_no>>();
			//我们必须在运算对象出现的所有行中进行迭代
			auto beg = result.begin(),end=result.end();
			//对于输入文件的每一行，如果该行不在result中，则将其添加到ret_lines
			auto sz = result.get_file()->size();
			for(size_t n = 0;n != sz;++n)
			{
				//如果我们还没有处理完result的所有行
				//检查当前行是否存在
				if(beg == end || *beg != n)
					ret_lines->insert(n);	//如果不在result当中，添加这一行
				else if(beg != end)
					++beg;		///否则继续去result的下一行(如果有的话)
			}
			return QueryResult(rep(),ret_lines,result.get_file());
		}
和其他eval函数一样，我们首先对当前的运算对象调用eval，所得的结果QueryResult中包含的是运算对象出现的行号，
但我们想要的是运算对象未出现的行号。也就是说，我们需要的是存在于文件中，但是不在result中的行。
	要想得到最终的结果，我们需要遍历不超过输出文件大小的所有整数，并将所有不在result中的行号放入到ret_lines
中。我们使用beg和end分别表示result的第一个元素和最后以一个元素的下一位置。因为遍历的对象是一个set，所以当
遍历结束后获得的行号将按照升序排列。
	循环体负责检查当前的编号是否在result当中。如果不在，将这个数字添加到ret_lines中；如果该数字属于
result，则我们递增result的迭代器beg。
	一旦处理完所有行号，就返回包含ret_lines的一个QueryRessult对象；和之前版本的eval类似，
该QueryResult对象还包含rep和get_file的运行结果。
