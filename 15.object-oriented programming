					第15章		面向对象程序设计
内容
---------------------------------
	15.1	OOP:概述
	15.2	定义基类和派生类
	15.3	虚函数
	15.4	抽象基类
	15.5	访问控制与继承
	15.6	继承中的类作用域
	15.7	构造函数与拷贝控制
	15.8	容器与继承
	15.9	文本查询程序再探
--------------------------------
	面向对象程序设计基于三个基本概念:数据抽象、继承和动态绑定。第七章以及介绍了数据抽象的知识，本章将介绍
继承和动态绑定。
	继承和动态绑定对象的编写有两方面的影响:一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在
使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。
	在很多程序中都存在一些相互关联但是有细微差别的概念。例如，书店中不同书籍的定价策略可能不同:有的书籍按
原价销售，有的则打折销售。有时，我们给那些购买书籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的
书籍打折，之后就调用原价，等等。面向对象的程序设计(OOP)适用于这类应用。

15.1	OOP:概述
	面向对象程序设计(object-oriented programming)的核心思想是数据抽象、继承和动态绑定。通过使用数
据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在
一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

继承:
	通过继承(inheritance)联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类(base class)，
其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类(derived class)。基类负责定义在层次关系中
所有共同拥有的成员，而每个派生类定义了各自特有的成员。
	为了对之前提到的不同定价策略建模，我们首先定义一个名为Quote的类，并将它作为层次关系中的基类。Quote
的对象表示按原价销售的书籍。Quote派生出另一个名为Bulk_quote的类，它表示可以打折销售的书籍。
	这些类将包含下面的两个成员函数:
		>>>	isbn()，返回书籍的ISBN编号。该操作不涉及派生类的特殊性，因此只定义在Quote类中。
		>>>	net_price(size_t)，返回书籍的实际销售价格，前提是用户购买该书的数量达到一定标准。这个操
作显然是类型相关的，Quote和Bulk_quote都应该包含该函数。
在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类
各自定义适合自身的版本，此时基类就将这些函数声明成虚函数(virtual function)。因此，我们可以将Quote类编
写成:
		class Quote{
		public:
			std::string isbn() const;
			virtual double net_price(std::size_t n)const;
		};
派生类必须通过使用派生列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生列表
的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符:
		class Bulk_quote : public Quote{	//Bulk_quote继承了Quote
		public:
			double net_price(std::size_t) const override;
		};
因为Bulk_quote在它的派生列表中使用了public关键字，因此我们完全可以把Bulk_quote的对象当成Quote的对象
来使用。派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但
是并不是非得这么做。出于15.3节将要解释的原因，C++11新标准允许派生类显示地注明它将使用哪个成员函数改写其基
类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。

动态绑定
	通过使用动态绑定(dynamic binding)，我们能用同一段代码分别处理Quote和Bulk_quote的对象。例如，当
要购买的书籍和购买的数量都已知时，下面的函数负责打印总费用:
		//计算并打印销售给定数量的某种书籍所得的费用
		double print_total(ostream &os,const Quote &item,size_t n)
		{
			//根据传入item形参的对象类型调用Quote::net_price
			//或者Bulk_quote::net_price
			double ret = item.net_price(n);
			os<<"ISBN: "<<item.isbn()<<" # sold: "<<n<<"total due: "<<ret<<endl;
			return ret;
		}
该函数非常简单，它返回调用net_price()的结果，并将该结果连同调用isbn()的结果一起打印出来。
	关于上面的函数有两个有意思的结论:因为函数print_total的item是基类Quote的一个引用，所以出于15.2.3
节将要解释的原因，我们既能使用基类Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它；又因为
print_tota是使用引用类型调用net_price函数的，所以出于15.2.1节将要解释的原因，实际传入print_total的
对象类型将决到底执行net_price的哪个版本:
		//basic的类型是Quote；bulk的类型是Bulk_quote
		print_total(cout,basic,20);			//调用Quote的net_price
		print_total(cout,bulk,20);			//调用Bulk_quote的net_price
第一条调用语句将Quote对象传入print_total，因此当print_total调用net_price时，执行的是Quote的版本；在
第二条调用语句中，实参的类型是Bulk_quote，因此执行的是Bulk_quote的版本(打算打折信息)。因为在上
述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为运行时绑定
(run-time binding)
注意:
	在C++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定！！！

15.2	定义基类和派生类
	定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也有有一些不同之处。本节将介绍
在定义有继承关系的类时可能用到的基本特性。

15.2.1	定义基类
	我们首先完成Quote类的定义:
		class Quote{
		public:
			Quote() = default;		//关于default请参见7.1.4
			Quote(const std::string &book,double Sales_price):
					bookNo(book),price(Sales_price){}
			std::string isbn() const { return bookNo;}
			//返回给定数量的书籍的销售总额
			//派生类负责改写并使用不同的折扣计算算法
			virtual double net_price(std::size_t n)const
			{
				return n * price;
			}
			virtual ~Quote() = default;		//对析构函数进行动态绑定
		private:
			std::string bookNo;		//书籍的ISBN编号
		protected:
			double price = 0.0;		//代表普通状态下不打折的价格
对于上面这个类来说，新增的部分是在net_price函数和析构函数之前增加的virtual关键字以及最后的protected访问
说明符。我们将在15.7.1节详细介绍虚析构函数的知识，现在只需记住作为继承关系中根节点的类通常都会定义一个虚析
构函数。
注意:
	基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

成员函数与继承
	派生类可以继承其基类的成员，然而当遇到如net_price这样与类型相关的操作时，派生类必须对其重新定义。换句
话说，派生类需要对这些操作提供自己的新定义以方法覆盖(override)从基类继承而来的旧定义。
	在C++语言中，基类必须将它的两种成员函数区分开来；一种是基类希望其派生类进行覆盖的函数；另一种是基类希
望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为虚函数(virtual)。当我们使用指针或引用调用函
数时，该调用将被动态绑定。根据引用或指针搜所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生
类的版本。
	基类在通过其他成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。任何构造函数之外的非静态
函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函
数声明成虚函数，则该函数在派生类中隐式地也是虚函数。我们将在15.3节介绍更多关于虚函数的知识。
	成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时。对于isbn成员来说这正是我们希望看到
的结果。isbn函数的执行与派生类的细节无关，不管作用于Quote对象还是Bulk_quote对象，isbn函数的行为都一样。
在我们的继承层次关系中只有一个isbn函数，因此也就不存在调用isbn()时到底执行哪个版本的疑问。

访问控制与继承
	派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类
的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员基类希望它的派生类有
权访问该成员，同时禁止其他用户访问。我们用受保护的(protected)访问运算符来说明这样的成员。
	我们的Quote类希望它的派生类定义各自的net_price函数，因此派生类需要访问Quote的price成员。与之相反，
派生类访问bookNo成员的方式与其他用户是一样的，都是通过调用isbn函数，因此bookNo被定义成私有的，即使是Quote
派生出来的类也不能直接访问它。我们将在15.5节介绍更多关于受保护成员的知识。
注意:
	protected　的成员是可以被派生类访问的，但是不能被基类的对象或者派生类的对象访问的。private　的成员是
只能被基类内部访问的，派生类的对象是不可以直接访问的，同样基类的对象也不能直接访问。

15.2.2	定义派生类
	派生类必须通过使用类派生列表(class derivation list)明确指出它是从哪个(哪些)基类继承而来的。类派生
列表的形式是:首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种说明符中的一个:
public、protected或者private。
	派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此我们的Bulk_quote类必须包含以一个
net_price成员:
		class Bulk_quote : public Quote{
		public:
			Bulk_quote() = default;
			Bulk_quote(const std::string &,double,std::size_t,double);
			//覆盖基类的函数版本以实现基于大量购买的折扣政策
			double net_price(std::size_t)const override;//这个是虚函数，被继承过来所
														//以必须得重新声明!!
		private:
			std::size_t min_qty = 0;
			double discount = 0.0;
		};
我们的Bulk_quote类从它的基类Quote那里继承了isbn函数和bookNo、price等数据成员。此外，它还定义了
net_price的新版本，同时拥有两个新增加的数据成员min_qty和discount。这两个成员分别用于说明享受折扣所
需购买的最低数量以及一旦该数量达到之后具体的折扣信息。
	我们将在15.5节详细介绍派生列表中用到的访问说明符。现在，我们只需知道访问说明符的作用是控制派生类从基类
继承而来的成员是否对派生类的用户可见。如果有一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，
我们能将以公有派生类型的对象绑定到基类的引用或指针上。因为我在派生列表中使用了public，所以Bulk_quote的接
口隐式地含有isbn函数，同时在任何需要Quote的引用或指针的地方我们都能使用Bulk_quote的对象。
	大多数类都只继承自一个类，这种形式的继承被称作"单继承"，它构成了本章的主题。关于派生列表中含有多于一个
基类的情况将在18.3节中介绍。

派生类中的虚函数
	派生类经常(但不总是)覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似
于其他的普通成员，派生类会直接继承其在基类中的版本。派生类可以在它覆盖的函数前使用virtual关键字，但不是非
得这么做。我们将在15.3介绍其原因。C++11新标准允许派生类显示地注明它使用某个成员函数覆盖了它继承的虚函数。
具体做法是在形参列表后面，或者在const成员函数的const关键字后面、或者在有引用成员函数的引用限定符后面添加
一个关键字override。

派生类对象及派生类向基类的类型转换
	一个派生类对象包含多个组成部分：一个含有派生类自己定义的(非静态)成员的子对象，以及一个与该派生类继承
的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个Bulk_quote对象将包含四个数据元素:
它从Quote继承而来的bookNo和price数据成员，以及Bulk_quote自己定义的min_qty和discount成员。
	C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为Bulk_quote的对象包含如图15.1所
示的两部分。
					Bulk_quote对象
	从Quote继承而来的成员		bookNo,price
	Bulk_quote自定义的成员		min_qty,discount
在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。上述只是表示类工作机理的概念模型，而非
物理模型因为在派生类对象中含有与基类对应的组成部分，所以我们能把派生类的对象当成其类对象来使用，而且我们也能
将基类的指针或引用绑定到派生类对象中的基类部分上。
		Quote item;		//基类对象
		Bulk_quote bulk;	//派生类对象
		Quote *p = &item;	//p指向Quote对象
		p = &bulk;			//p指向bulk的Quote部分
		Quote &r = bulk;	//r绑定到bulk的Quote部分
这种转换通常称为派生类到基类(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基
类的转换。
这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生
类对象的指针用在需要基类指针的地方。也就是说可以使用基类的指针或引用去绑定派生类。
注意：
	在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键。

派生类构造函数
	尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的
代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。
注意:
	每个类控制它自己的成员初始化过程
派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化截断执行初始化操作的。类似于我们初始化
成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的
Bulk_quote构造函数如下
所示:
		Bulk_quote(const std::string &book,double p,std::size_t qty,double disc):
						Quote(book,p),min_qty(qty),discount(disc){}
		///与之前一致
		};
该函数将它的前两个参数(分别表示ISBN和价格)传递给Quote的构造函数，由Quote的构造函数负责初始化Bulk_quote
基类部分(即bookNo成员和price成员)。当(空的)Quote构造函数体结束后，我们构建对象的基类部分也就完成初始化
了。接下来初始化由派生类直接定义的min_qty成员和discount成员。最后运行Bulk_quote构造函数的(空的)函数体。
	除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，
我们需要以类名加圆括号的内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构
造函数来初始化派生类对象的基类部分。
注意:
	首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

派生类使用基类的成员
	派生类可以访问基类的公有成员和受保护成员:
		//如果到达了购买书籍的某个最低限量值，就可以享受折扣价格了
		double Bulk_quote::net_price(size_t cnt)const
		{
			if(cnt >= min_qty)
				return cnt * (1-discount) * price;
			else
				return cnt * price;
		}
该函数产生一个打折后的价格：如果给定的数量超过了min_qty，则将discount(一个小于1大于0的数)作用于price。
	我们将在15.6节进一步讨论作用域，目前只需要了解派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的
一个成员来说，它使用派生类成员(例如min_qty和discount)的方式和使用基类成员(例如price)的方式没有什么不同。
关键概念:遵循基类的接口
	必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类
部分也是如此。
	因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护
的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构
造函数来初始化那些从基类中继承而来的成员。与就是通过构造函数来进行初始化每个类的成员，千万别越级操作。

继承与静态成员
	如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出多少个派生类，对
于每个静态成员来说都只存在唯一的实例:
		class Base{
		public:
			static void statmem();
		};
		class Derived : public Base{
			void f(const Derived &);
		};
静态成员遵循通用的访问控制规模，如果基类中的成员是private的，则派生类无权访问。假设某静态成员是可访问的，则
我们既能通过基类使用它也能通过派生类使用它:
		void Derived::f(const Derived & derived_obj)
		{
			Base::statmem();		//正确:Base定义了statmem
			Derived::statmem();		//正确:Derived继承了statmem
			//正确:派生类的对象能访问类的静态成员
			derived_obj.statmem();	//正确:通过Drived对象访问
			statmem();				//正确:通过this访问，也就是在类的定义的函数中使用

		}

派生类的声明
	派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生类列表:
		class Bulk_quote : public Quote;	//错误：派生列表不能出现在声明语句中
		class Bulk_quote;		//正确:声明派生类的正确方式
一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、有一个函数或是一个变量
等。派生列表以及与定义有关的其它细节必须与类的主体一起出现。

被用作基类的类
	如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明:
		class Quote;	//声明但未定义
		//错误:Quote必须被定义
		class Bulk_quote : public Quote{...};
这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它
们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。
	一个类是基类，同时它也可以是一个派生类:
		class Base { /* .....*/};
		class D1 : public Base {/*....*/};
		class D2 : public D1 {/*.....*/};
在这个继承关系中，Base是D1的直接基类(direct base)，同时是D2的间接基类(indirect base)。直接基类出现在
派生列表中，而间接派生类通过其直接基类继承而来。
	每个类都会继承直接基类的所有成员，对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又
含有其基类的成员；依次类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子
对象。

防止继承的发生
	有时我们会定义这样以一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，
C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final:
		class NoDerived final {/* ...... */};		//NoDerived不能作为基类
		class Base{/* ..*/};
		//Last是final的；我们不能继承Last
		class Last final : Base { /*....*/};	//Last不能作为基类
		class Bad : NoDerived{/*.....*/};//错误，NoDerived是final的
		class Bad2 : Last{/*....*/};	//错误:Last是final的

15.2.3	类型转换与继承
Wanrning	理解基类和和派生类之间的类型转化是理解C++语言面向对象编程的关键所在。
	通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应该与对象的类型一致。或者对象的
类型含有一个可接受的const的类型转换规则。存在继承关系的类是有一重要的例外:我们可以将基类的指针或引用绑定
到派生类对象上。例如，我们可以用Quote&指向一个Bulk_quote对象，也可以把一个Bulk_quote对象的地址赋给
一个Quote *。
	可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义:当使用基类的引用(或指针)时，实际上我们
并不清楚该引用(或指针)所绑定的对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。
注意:
	和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一
个基类的智能指针内。

静态类型与动态类型
	当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与表示该对象的动态类型区分开来。表
达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内
存中的对象的类型。动态类型直到运行时才可知。
	例如，当print_total调用net_price时:
		double ret = item.net_price(n);
我们知道item的静态类型是Quote &，它的动态类型则依赖于item绑定的实参，动态类型直到在运行时调用该函数时才
会知道。如果我们传递一个Bulk_quote对象给print_total，则item的静态类型将与它的动态类型不一致。如前所述
item的静态类型是Quote &，而在此例中它的动态类型则是Bulk_quote。
	如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。例如，Quote类型的变量将永远是一个
Quote对象，我们无论如何都不能改变该变量对应的对象的类型。
注意:
	基类的指针或引用的静态类型可能与其动态的类型不一致，读者一定要理解其中的原因。主要是为了面向对象而来
的。

不存在从基类向派生类的隐式类型转换.....
	之所以存在派生类向基类的类型转换是因为每个派生类对象都包含有一个基类部分，而基类的引用或指针可以绑定
到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是
派生对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。
	因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换:
		Quote base;
		Bulk_quote *bulkp = &base;		//错误:不能将基类转换成派生类
		Bulk_quote &bulkPef = base;		//错误:不能将基类转换成派生类
小结下关于基类和派生类的类型转换：
	首先，基类必定是作为派生类的一部分的。也就是说，在派生类对象中必定有基类对象。所以普通的基类对象可以
指向派生类（其实指向的是派生类中的基类的对象），同理，引用也是一样的。但是反过来看，一个普通的基类对象可
能仅仅是作为一个基类的对象，而不是被包含在一个派生类对象中。也有可能是作为一个派生类对象的一部分的基类对
象。所以将一个派生类对象指向基类对象是可以的，因为你不知道这个基类对象是不是独立的。比方说，你的派生类想
调用一部分派生类自己的成员，但是你指向的基类成员只是一个单纯的独立的基类，那么它就不会含有派生类的对象。
所以不可以将派生类指向基类。那么为什么基类就可以指向派生类了。因为基类指向的派生类中的基类！所以是没有问
题的。但是这个时候却不能使用派生类的自己定义的新的成员。所以我们的虚函数才是一种非常重要的作用，因为虚函
数在基类中也有，派生类中也有，但是是不一样的，所以才会有指向派生类的基类，这样就可以使用派生类中的不同作
用的虚函数了。

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派
生类的转换:
		Bulk_quote bulk;
		Quote *itemp = &bulk;		//正确:动态类型是Bulk_quote
		Bulk_quote *bulkP = itemp;	//错误:不能将基类转换成派生类！！！
编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推
断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换，该转换的
安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来强
制覆盖掉编译器的检查工作。
......在对象之间不存在类型转换
	派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和其他类类型之间不存在这样的转换。很多时
候我们确实希望将派生类对象转成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。
	请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数；
而当执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，该参数的类型是类类型的const版本的引用。
	因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象。
这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然
该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算
符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。
	例如，我们的书店类使用了合成版本的拷贝和赋值操作。关于拷贝控制与继承的知识将在15.7.2节做更详细的介绍，
现在我们只需要知道合成版本会像其他类一样逐成员地进行拷贝或赋值操作:
		Bulk_quote bulk;		//派生类对象
		Quote item(bulk);		//使用Quote::Quote(const Quote&)构造函数
		item = bulk;			//使用Quote::operator=(const Quote&);
当构造item时，运行Quote的拷贝构造函数。该函数只能处理bookNo和price两个成员，它负责拷贝bulk中Quote部
分的成员，同时忽略掉bulk和Bulk_quote部分的成员，类似的，对于将bulk赋值给item的操作哦来说，只有bulk
和Quote部分的成员被赋值item。
	因为在上述过程中会忽略掉Bulk_quote部分，所以我们可以说bulk的Bulk_quote部分被切掉了(slice down)。
注意:
	当我们用有一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，
它的派生类部分将被忽略掉。

关键概念:存在继承关系的类型之间的转换规则
	要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要:
		>>>	从派生类向基类的类型转换只对指针或引用类型有效
		>>>	基类向派生类不存在隐式类型转换!!!!
		>>>	和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节
介绍可访问性的问题
尽管自动类型转换只针对指针或引用类型有效，但是继承体系中的大多数类仍然(显示或隐式地)定义了拷贝控制成员。
因此我们通常能够将有一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派
生类对象的基类部分。

15.3	虚函数
	如前所述，在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运
行时才能知道到底用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，
则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也
无法确定到底会使用哪个虚函数。

对虚函数的调用可能在运行时才被解析
	当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的
函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。举个例子，考虑15.1节中的print_total函数，该
函数通过其名为item的参数来进一步调用net_price，其中item的类型是Quote&。因为item是引用而且net_price
是虚函数，所以到底调用net_price的哪个版本完全依赖于运行时绑定到item的实参的实际(动态)类型:
		Quote base("0-201-82470-1",50);
		print_totoal(cout,base,10);		//调用Quote::net_price
		Bulk_quote derived("0-201-82470-1",50,5,.19);
		print_total(cout,derived,10);	//调用Bulk_quote::net_price
在第一条调用语句中，item绑定到Quote类型的对象上，因此当print_total调用net_price时，运行在
Quote中定义的版本。在第二条调用语句中，item绑定到Bulk_quote类型的对象上，因此print_total调用
Bulk_quote定义的net_price。
	必须要搞清楚的一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生!!!
		base = derived;		//把derived的Quote部分拷贝到base，这个里base已经有拷贝控制成员
		base.net_price(20);	//调用Quote::net_price
当我们调用一个具有普通类型(非引用非指针)的表达式调用虚函数时，在编译时就会将调用的版本确定下来。例如，
如果我们使用base调用net_price，则应该运行net_price的哪个版本是显而易见的。我们可以改变base表示的
对象的值(即内容)。但是不会改变该对象的类型。因此，在编译时该调用会被解析成Quote的net_price。

关键概念:C++的多态性
	OOP的核心思想是多态性(polymorphism)。多态性这个词源自希腊语，其含义是"多种形式"。我们把具有继承
关系的多个类型称为多态类型，因为我们能使用这些类型的"多种形式"而无须在意它们的差异。引用或指针的静态类型
与动态类型不同这一事实正是C++语言支持多态性的根本所在。
	当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因
为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版
本，判断的依据是引用或指针所绑定的对象的真实类型。
	另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数(虚函数或非虚函数)调用也在编译
时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行
的函数调用将在编译时绑定到该对象所属类的函数版本上。当且仅当通过指针或引用调用虚函数时，才会在运行时解析
该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

派生类中的虚函数
	当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必
须的，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。
	一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与它覆盖的基类函数完全一致。同样，
派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针
或引用时，上述规则无效。也就是说，如果D由B派生得到的，则基类的虚函数可以返回B*而派生类的对应函数可以返
回D*，只不过这样的返回类型要求从D到B的类型转换是可以访问的。15.5节将介绍如何确定一个基类的可访问性，
在15.8.1节中我们将看到这种虚函数的一个实际例子。
注意:
	基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须
与派生类中的形参严格匹配。

final和override说明符
	如我们将要在15.6节介绍的，派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然
是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉
基类中的版本。就实际的编程习惯而言，这种声明方式往往意味着发生错误，因为我们可能原本希望派生类能覆盖掉基
类中的虚函数，但是一不小心把形参列表弄错了。
	要想调试并发现这样的错误显然非常困难。在C++11新标准中我们可以使用override关键字来说明派生类中的虚
函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得
更加重要。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错:
		struct B{
			virtual void f1(int)const;
			virtual void f2();
			virtual f3();
		};
		struct D1 : B{
			void f1(int)const override;		//正确:f1与基类中的f1匹配
			void f2(int)override;		//错误:B没有形如f2(int)的函数
			void f3()override;			//错误:f3不是虚函数
			void f4()override;			//错误:B没有名为f4的函数
		};
在D1中，f1的override说明符是正确的，因为基类和派生类中的f1都是const成员，并且它们都接受一个int返回
的void，所以D1中的f1正确的覆盖了它从B中继承而来的虚函数。
	D1中的f2声明与B中f2的声明不匹配，所以D1的f2不能覆盖B的f2，它是一个新函数，仅仅是名字恰好与原来
的函数一样而已。因为我们使用override所表达的意思是我们希望能覆盖掉基类中的虚函数而实际上并未做到，所以
编译器会报错。
	因为只有虚函数才能被覆盖，所以编译器会拒绝D1的f3。该函数不是B中的虚函数，因此它不能被覆盖。类似的，
f4的声明也会发生错误，因为B中根本就没有名为f4的函数。我们还能把某个函数指定为final，如果我们已经把函数
定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误:
		struct D2 : B{
			///从B继承f2()和f3()，覆盖f1(int)const
		void f1(int)const final;		//不允许后续的其他类覆盖f1(int)
		};
		struct D3 : D2{
			void f2();		//正确:覆盖从间接基类B继承而来的f2
			void f1(int)const;		//错误:D2已经将f2声明成final
		};
final和override说明符出现在形参列表(包括任何const或引用修饰符)以及尾置返回类型之后。


虚函数与默认实参
	和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态
类型决定。换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中的默认实参，即使实际运行的是派生类
中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则
程序结果将与我们的预期不符。这个的意思也就是说，虚函数的默认实参的使用是根据静态类型来决定的而不是动态类
型决定！！所以即使你的基类指向的是派生类，但是在使用默认实参的时候也是使用基类的默认实参，而不是派生类中
定义的默认实参！！！
注意:
	如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

回避虚函数的机制
	在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域
运算符可以实现这一目的，例如下面的代码:
		//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
		double undiscounted = baseP->Quote::net_price(42);
改代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解
析。
注意:
	通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制。
什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况
下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切
相关的操作。
注意:
	如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类
版本自身的调用，从而导致无限递归。

15.4	抽象基类
	假设我们希望扩展书店程序并令其支持几种不同的折扣策略。除了购买数量超过一定数量享受折扣外，我们也可以提
供另外一种策略，即购买数量不超过某个限额时可以享受折扣，但是一旦超过限制额就要按原价支付。或者折扣策略还可
能是购买数量超过一定数量后购买的全部书籍都享受折扣，否则全都不打折。
	上面的每个策略都要求一个购买量的值和一个折扣值。我们可以定义一个新的名为Disc_quote的类来支持不同的折
扣策略，其中Disc_quote负责保存购买量的值和折扣值。其他的表示某种特定策略的类(如Bulk_quote)将分别继承自
Disc_quote，每个派生类通过定义自己的net_price函数来实现各自的折扣策略。
	在定义Disc_quote类之前，首先要确定他的net_price函数完成什么工作。显然我们的Disc_quote类与任何特
定的折扣策略都无关，因此Disc_quote类中的net_price函数是没有实际含义的。
	我们可以在Disc_quote类中不定义新的net_price，此时，Disc_quote将继承Quote的net_price函数，
然而这样的设计可能导致用户编写出一些无意义的代码。用户可能会创建一个Disc_quote对象并为其提供购买量和折扣
值，如果将该对象传给一个像print_total这样的函数，则程序将调用Quote版本的net_price。显然，最终计算出
的销售价格并没有考虑我们在创建对象时提供的折扣值，因此上述操毫无意义。

纯虚构函数
	认真考虑上面描述的情形我们可以发现，关键问题并不仅仅是不知道应该如何定义net_price，而是我们根本就不希
望用户创建一个Disc_price对象。Disc_quote类表示的是一本打折书籍的通用概念，而非某种具体的折扣策略。
	我们可以将net_price定义成纯虚函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个
net_price函数是没有实际意义的。和普通函数的虚构函数不一样，一个纯虚构函数无须定义。我们通过在函数体的位置
(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处:
		//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略
		class Disc_quote:public Quote{
		public:
			Disc_quote() = default;
			Disc_quote(const std::string &book,double price,std::size_t qty,double disc):
						Quote(book,price),quantity(qty),discount(disc){}
			double net_price(std::size_t)const =0;
		protected:
			std::size_t quantity = 0;		//折扣适用的购买的数量
			double discount = 0.0;
		};
和我们之前定义的Bulk_quote类一样，Disc_quote也分别定义了一个默认构造函数和一个接受四个参数的构造函数。
尽管我们不能直接定义这个类的对象，但是Disc_quote的派生类构造函数将会使用Disc_quote的构造函数来构建各
个派生类对象的Disc_quote部分。其中接受四个参数的构造函数将前两个参数传递给Quote的构造函数，然后直接初
始化自己的成员discount和quantity。默认构造函数则对这些成员进行默认初始化。
	值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内
部为一个=0的函数提供函数体。

含有纯虚函数的类是抽象基类
	含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接
口。我们不能(直接)创建一个抽象基类的对象。因为Disc_quote将net_price定义成了纯虚函数，所以我们不能
定义Disc_quote的对象。我们可以定义Disc_quote的派生类对象，前提是这些类覆盖了net_price函数:
		//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数
		Disc_quote discounted;		//错误:不能定义Disc_count的对象
		Bulk_quote bulk;			//正确:Bulk_quote中没有纯虚函数
Disc_quote的派生类必须给出自己的net_price定义，否则它们仍将是抽象基类。
注意:
	我们不能创建抽象基类的对象！！！

派生类构造函数只初始化它的直接基类
	接下来可以重新实现Bulk_quote了，这一次我们让他继承Disc_quote而非直接继承Quote:
		//当同一本书籍的销售量超过某个值时启用折扣
		//折扣的值是一个小于1的正的小数值，依次来降低正常销售价格
		class Bulk_quote : public Disc_quote{
		public:
			Bulk_quote() = default;
			Bulk_quote(const std::string &book,double price,std::size_t qty,
					  double disc):Disc_quote(book,price,qty,disc){}
			double net_price(std::size_t)const override;
		};
这个版本的Bulk_quote的直接基类是Disc_quote，间接基类是Quote。每个Bulk_quote对象包含三个子
对象：一个空的Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。
	如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，它也仍
然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给Disc_quote的构造函数，随后
Disc_qoute的构造函数继续调用Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price成员，
当Quote的构造函数结束后，开始运行Disc_quote的构造函数并初始化quantity和discount成员，最后运行
Bulk_quote的构造函数，该函数无须执行实际的初始化或其他工作。
关键概念:重构
	在Quote的继承体系中增加Disc_quote类是重构(refactoring)的一个典型示例。重构负责
重新设计类的体系以便操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很
普通的现象。
	值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何
改动。不过一旦类被重构(或以其他方式被改变)，就意味着我们必须重新编译含有这些类的代码了。

15.5	访问控制与继承
	每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问(asscessible)

受保护的成员
	如前所述，一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。
protected说明符可以看做是public和private中和后的产物:
		>>>	和私有成员类似，受保护的成员对于类的用户来说是不可访问的。(这里类的用户也就是对象)
		>>>	和公有成员类似，受保护的成员对于派生类的成员和有友元来说是可以访问的
		>>>	派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保
护成员没有任何访问特权。也就是说可以访问类的成员，但是不能访问基类对象的成员。
为了理解最后一条规则，请考虑如下的例子:
		class Base{
		protected:
			int prot_mem;
		};
		class Sneaky : public Base{
			friend void clobber(Sneaky &);	//可访问Sneaky::prot_mem;
			friend void clobber(Base &);	//不能访问Base::prot_item;
			int j;		//j默认是private;
		};
		//正确:clobber能访问Sneaky对象的private和protected成员
		void clobber(Sneaky &s){
			s.j = s.prot_item = 0;
		}
		//错误:clobber不能访问Base的protected成员
		void clobber(Base &b){
			b.prot_mem = 0;
		}
如果派生类(及其友元)能访问基类对象的受保护成员，则上面的第二个clobber(接受一个Base &)将是合法的。
该函数不是Base的友元，但是它仍然能够改变一个Base对象的内容。如果按照这样的思路，则我们只要定义一个
形如Sneaky的新类就能非常简单地规避掉protected提供的访问保护了。
	要想阻止以上的用法，我们就要做出如下规定，即派生类的成员和友元只能访问派生类对象中的基类部分的受
保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。也就是说，派生类的成员和友元只能通过派生类
对象去访问基类中的受保护的成员，而不是直接通过基类对象就能访问基类中的受保护的成员。也就是成员函数或
友元函数只能通过该类的对象去访问其基类的成员，而不是直接通过基类对象直接访问基类的受保护成员！！

公有、私有和受保护继承
	某个类对其继承而来的成员访问权限受到两个因素影响：一个是基类中该成员的访问说明符，二是在派生类列
表中的访问说明符。举个例子，考虑如下的继承关系:
		class Base{
		public:
			void pub_mem();
		protected:
			int prot_mem();
		private:
			char priv_mem();
		};
		struct Pub_Derv : public Base{
			//正确:派生类能访问protected成员
			int f(){return prot_mem();}
			//错误:private成员对于派生类来说是不可访问的
			char g(){return priv_mem();}
		};
		struct Priv_Derv : private Base{
			//private不影响派生类的访问权限
			int f() const {return prot_mem();}
		};
派生类访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没有什么影响。对基类成员的访问权限只与
基类中的的访问说明符有关。Pub_Dev和Priv_Derv都能访问受保护的成员prot_mem，同时它们都不能访问私有
成员priv_mem。
	派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限:
		Pub_Derv d1;		//继承自Base的成员是public的
		Priv_Derv d2;		//继承自Base的成员是private的
		d1.pub_mem();		//正确:pub_mem在派生类中是public的
		d2.pub_mem();		//错误:pub_mem在派生类中是private的
Pub_Derv和Priv_Derv都继承了pub_mem函数。如果继承是公有的，则成员将遵循其原有的访问说明符，此时
d1可以调用pub_mem。在Priv_Derv中，Base的成员是私有的，因此类的用户不能调用pub_mem(类的用户，
也就是我们程序员创建的类的对象)。
	派生类访问说明符还可以控制继承自派生类的新类的访问权限:
		struct Derived_from_Public : public Pub_Derv{
		//正确:Base::prot_mem在Pub_Derv中仍然是protected的
		int use_base() { return prot_mem;}
		};
		struct Derived_from_Private: private Priv_Derv{
			//错误:Base::prot_mem在Priv_Derv中的是private的
			int use_base() { return prot_mem;}
		};
Pub_Derv的派生类之所以能访问Base的prot_mem成员是因为该成员在Pub_Derv中仍然是受保护的。相反，Priv_Derv
的派生类无法执行类的访问，对于它们来说，Priv_Derv继承自Base的所有成员都是私有的。
	假设我们之前还定义了一个名为Prot_Derv的类，它采用受保护继承，则Base的所有公有成员在新定义的类中
都是受保护的。Prot_Derv的用户不能访问pub_mem，但是Prot_Derv的成员和友元可以访问那些继承而来的成员。
小结下:
	派生类访问说明符(也就是派生列表中的那些)，不限制派生类的成员函数和友元函数去访问基类的中的成员(
也就是派生类中的成员函数和友元函数可以访问直接基类的public和protected成员)。派生类访问说明符只是
用来给派生类的用户(也就是对象)的。如果派生类使用public继承，那么派生类中的继承过来的基类的成员保持与
基类本身的成员的访问权限一致，保持不变。但是如果是private继承的，那么派生类中的基类的访问权限在派生
类的对象中就全是private的了。所以对派生类对象就不可访问的了。
所以:派生类访问符对于派生类本身访问基类
的成员是不变的，但是对于派生类的对象(用户)来说就是不一样的了。
对于派生类的派生类来说是同样的道理，就
可以把派生类产生的派生类看做是一个派生来对象来看待。

