									6	function

内容
-------------------------------
		6.1	函数基础
		6.2	参数传递
		6.3	返回类型和return语句
		6.4	函数重载
		6.5	特殊用途语言特性
		6.6	函数匹配
		6.7	函数指针
	本章首先介绍函数的定义和声明，包括参数如何传入函数以及函数如何返回结果。在C++语言中允许重载，
也就是几个不同的函数可以使用同一个名字。所以接下来我们介绍重载函数的方法，以及编译器如何从函数的
若干重载形式中选取一个与调用匹配的版本。最后我们将介绍一些关于函数指针的知识。
--------------------------------

6.1	函数基础
	一个典型的函数(function)定义包括以下部分：返回类型(return type)、函数名字、由0个或多个形参
（parameter）组成的列表以及函数体。其中形参以逗号隔开，形参的列表位于一对圆括号之内。函数执行的操作
在语句块中说明。该语句块称为函数体。
	我们通过调用运算符（call operator)来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达
式，该表达式是函数或者指向函数的指针：圆括号之内是一个用逗号隔开的实参（argument)列表，我们用实参
初始化形参。调用表达式的类型就是函数的返回类型。
	执行函数的第一步是（隐式的）定义并初始化它的形参。因此，当调用fact函数的时候，首先创建一个名为
val的int变量，然后将它初始化为调用时所用的实参5，也就是说，其实形参和实参是一个赋值的过程，也就是说，
实参是作为右值的，而形参是作为左值的。

形参和实参
	实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，依次类推。尽管实参与
形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。
	实参的类型必须与对应的形参类型匹配，这一点与之前的规则是一致的，我们知道在初始化过程中初始值的类
型也必须参与初始化对象的类型匹配。函数有几个形参，我们就必须提供相同数量的实参。因为函数的调用规定实
参数量与性参数量一致，所以形参一定会被初始化。
注意：
		"hello"这是一个const char *类型的数据类型
函数的形参列表
	函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法是书写一个空的形参
列表。不过为了与C语言兼容，也可以使用关键字void表示函数没有形参:
			void f1(){}			//隐式的定义空形参列表
			void f2(void) {}	//显示地定义空形参列表
形参列表中的形参通常使用逗号隔开，其中每一个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必
须把两个类型都写出来：
			int f3(int v1,v2){}		//错误，
			int f4(int v1,int v2){}	//正确
任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

函数返回类型
	大多数类型都能用作函数的返回类型。一种特殊的返回类型就是void，它表示函数不返回任何值。函数的返回
类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

6.1.1	局部对象
	在C++语言中，名字有作用域，对象有生命周期（lifetime)：
	>>>名字的作用域是程序文本的一部分，名字在其中可见。
	>>>对象的生命周期是程序执行过程中该对象存在的一段时间
	如我们所知，函数体是一个语句块。块构成一个新的作用域，我们可以在其中定义变量。形参和函数体内部定义
的变量统称为局部变量（local variable）。他们对函数而言是”局部“的。仅在函数的作用域内可见，同时局部
变量还会隐藏(hide)在外层作用域中同名的其他所有声明中。
	在所有函数体之外定义的对象存在于程序整个执行过程中。此类对象在程序启动时被创建，直到程序结束时才会
被销毁，局部变量的声明周期依赖于定义的方式。

自动对象
	对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末
尾时销毁它。我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成了
未定义的。
	形参是一种自动对象，函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦终止，
形参也被销毁。

局部静态对象
	某些时候，有必要令局部变量的生命周期贯穿函数调用及以后的时间，可以将局部变量定义成static类型从而获
得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才会被销毁，在
此期间即使对象所在的函数结束执行也不会对它有影响。
			size_t count_calls()
			{
					static size_t ctr = 0;
					return ++ctr;
			}
			int main(void)
			{
				for(size_t i = 0; i != 10; ++i)
					cout<< count_calls() <<endl;
				return 0;
			}
6.1.2	函数声明
	和其他名字一样，函数的名字也必须在使用之前声明。类似于变量，函数只能定义一次，但是可以声明多次。唯
一的例外是以后将要介绍的，如果一个函数永远不会被我们使用到，那么它可以只有声明没有定义。
	函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。
	因为函数的声明不包括函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管
如此，写上形参的名字还是有用处的。它可以帮助使用者更好的理解函数的功能：
	void print(vector<int>::const_iterator beg,vector<int>::const_iterator end);
函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需要的全部信息。函数声明
也称作函数原型。

在头文件中进行函数声明
	回忆之前所学的知识，我们建议变量在头文件中声明，在源文件中定义，与之类似的，函数也应该在头文件中声
明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。

6.2	参数传递
	当形参是引用类型时，我们说它对应的实参被引用传递或者函数被引用调用。和其它引用一样，引用形参也是它
绑定的对象的别名：也就是说，引用形参是它对应的实参的别名。
	当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值
调用。

使用引用避免使用拷贝
	拷贝大的类类型对象或者容器对象比较抵消，甚至有的类类型根本就不支持拷贝操作。当某种类型不支持拷
贝操作时，函数只能通过引用形参访问该类型的对象。
	举个例子，我们准备编写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应该
尽量避免直接拷贝他们，这时使用引用形参是比较明智的选择。又因为比较长度无须改变string对象的内容，
所以把形参定义成对常量的引用。
		bool isShorter(const string &s1,const string &s2)
		{
			return s1.size() < s2.size();
		}

如果函数无须改变引用形参的值，最好将其声明为常量引用。

使用引用形参返回额外信息
	一个函数只能返回一个值，然而有时候函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了
有效的途径。举个例子，我们定义一个名为find_char的函数，它返回在string对象中某个指定字符第一次出
现的位置。同时，我们也希望函数能返回该字符出现的总次数。
	该如何定义函数使得它能够既能够返回位置也返回出现次数呢？一种方法是定义一个新的数据类型，让它包含
位置和数量两个成员。还有一个更简单的方法，我们可以给函数传入一个额外的引用实参，令其保存字符出现的次数：
	string::size_type find_char(const string &s,char c,string::size_type &occurs)
		{
			auto ret = s.size();
			occurs = 0;
			for(decltype(ret) i = 0; i != s.size();++i)
			{
				if(s[i] == c)
				{
					if(ret == s.size())
						ret = i;
					++occurs;
				}
			}
			return ret;
		}
6.2.3	const形参和实参
	当形参是const时候，必须要注意关于顶层const的讨论。如前所述，顶层const作用于对象本身：
			const int ci = 42;	//不能改变ci，const是顶层的
			int i = ci;			//正确，当拷贝ci时，忽略了它顶层的const
			int * const p = &i;	//const是顶层的，不能给p赋值
			*p = 0;				//正确，通过p改变对象的内容是允许的，现在i变成了0
和其他初始化过程一样，当用实参初始化形参时，会忽略掉顶层const。换句话说，形参的顶层const被忽略
掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的：
			void fun(const int i){/*fcn能够读取i,但是不能向i写值！！！！*/}
调用fcn函数时，既可以传入const int也可以传入int。忽略掉顶层const可能产生意想不到的结果：
			void fcn(const int i){/*fcn能读取i，但是不能向i写值*/}
			void fcn(int i){/* /*}//重复定义了，fcn(int)。
在C++中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该具有明显的区别。因为顶层
const被忽略掉了，所以上面的代码中传入了两个fcn函数的参数可以完全一样。因此第二个fcn是错误的，尽管形
式上有差异，但实际上它的形参和第一个fcn的形参没有什么不同！
注意：
		形参中的顶层const会被忽略掉！所以要注意，不要向顶层中写入数据，只需要读取就好！

指针或引用形参与const
	形参的初始化方式和变量的初始化方式是一样的，所以回顾通用的初始化规则有助于理解本节的知识。我们可
以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。
			int i = 42;
			const int *cp = &i;//非常量可以给底层const初始化
			const int &r = i;//顶层const被忽略
			const int &r2 = 42;//正确，因为42是字面值常量
			int *p = cp;	//错误，类型不匹配，p可以改变cp指向地址的内容，所以不对
			int &r3 = r;	//错误，r3有改变r的风险，所以错误，也就是类型不匹配
			int &r4 = 42;	//错误，不能用一个字面值初始化一个非常量引用！

尽量使用常量引用
	把函数不会改变的形参定义成普通引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以
修改它的实参的值。此外，使用引用而非常量引用也会极大的限制函数所能接受的实参类型，就像刚刚看到的，我们不
能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。
	这种错误绝不像看起来那么简单，他可能会造成出人意料的后果。例如下面这个例子：
		string::size_type find_char(string &s,char c,string::size_type &occure)
则只能将find_char函数作用于string对象，类似下面这样的调用find_char("Hello World",'c',ctr);
将在编译时发送错误。因为普通的常量引用是不能用字面值常量来赋值初始化的。还有一个更难察觉的问题，假如其
他函数（正确的将他们的形参定义成常量引用，那么第二个版本的find_char无法在此类函数中正常使用。举个例子，
我们希望在一个判断string对象是否是句子的函数中使用find_char:
		bool is_sentence(const string &s)
		{
			string::size_type ctr = 0;
			return find_char(s,'.',ctr) == s.size() - 1 && ctr == 1;
		}
如果find_char的第一个形参类型是string &，那么上面的这条调用find_char语句将在编译时候发生错误。原因
在于s是常量引用，但是find_char的第一个形参是普通的引用，所以是不能赋值常量的！
所以：
		以后使用形参的时候，全用常量的引用作为形参！！！
6.2.4	数组形参
	数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组以及使用
数组时会将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，
所以我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。
	尽管我们不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：
		void print(const int*);
		void print(const int []);
		void print(const int[10]);//这里的维度表示我们期望数组含有多少个元素，但是不一定真的是这
么多，以上三种形式都是等价的！
如果我们传递给print函数的是一个数组，则实参自动转换成指向数组首元素的指针，数组的大小对于函数的调用没有
任何影响。
	因为数组是以指针的形式传递给函数的，所以一开始是不知道数组的确切尺寸，调用者应该为此提供一些额外的信
息。管理指针形参有三种常用的技术。

1.使用标记指定数组长度
	管理数组实参的第一种方法是要求数组本身包含一个结束标志。使用这种方法的典型示例就是C风格的字符串。C风
格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止。

2.使用标准库规范
	管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发。我们可以
按照如下形式输出元素的内容：
		void print(const int *beg,const int *end)
		{
			while(beg != end)
				cout<< *beg++ <<endl;
		}
为了调用这个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一位置：
		int j[2] = {0,1};
		print(begin(j),end(j));	//注意，这个普通的非string对象是没有迭代器的，所以没有s.end(),
s.begin()这中操作的。所以我们可以使用begin()和end()函数来获取相应的首元素和尾后元素的指针的位置。

3.显示传递一个表示数组大小的形参
	第三种方法其实就是专门定义一个表示数组大小的形参，可以将print重写成：
		void print(const int ia[],size_t size)
		{
			for(size_t i = 0;i != size; i++)
			{
				cout<<ia[i]<<endl;
			}		
		}
调用的话如下所示：
		int j[] = {0,1};
		print(j,end(j)-begin(j));

数组引用形参
	C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应
的实参上，也就是绑定到数组上：
		//正确：形参是数组的引用，维度是类型的一部分
		void print(int (&arr)[10])
		{
			for (auto elem : arr)
				cout<< elem << endl;
		}
注意：
		&arr两端的括号必不可少
		int &arr[10]		//错误：将arr声明成了引用的数组了
		int (&arr)[10]		//正确，首先&表示是一个引用，然后这是一个int类型的数组，所以是一个对
数组的引用。
还有一点要注意，这里的维度也是一个特定的东西，不能丢掉，这里的维度表示，你对数组的引用的维度是多大的。如
果超过这个维度，那么就会报错了！
例如：
		int i = 0,j[2]={0,1};
		int k[10] = {0,1,2,3,4,5,6,7,8,9};
		print(&i);		//错误：实参不是含有10个整数的数组
		print(j);		//错误：实参不是含有10个整数的数组
		print(k);		//正确：实参是含有10个整数的数组。

传递多维数组
	我们曾经介绍过，在C++语言中实际上并没有真正的多维数组。所谓多维数组其实是数组的多维。
	和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的
数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数
组类型的一部分，不能省略。
可以这样理解：
	当一维数组的时候，因为是当做是指针处理的，所以它的数组的具体大小是没必要知道的，所以可以写成[]/[10]
都是一样的。但是二维的话，你就必须知道你的第二维的大小，为什么？因为他是指向数组的指针，它就得知道那个数组
的大小，第一维可以省略，因为不用管一共多少个指向第二维大小的数组。就比如说[3][4]的，你可以省略第一维的3，
但是4不可以。省略以后，你不知道你指向的数组大小是多少了，你可以随便想了。但是第一维可以省略，因为你的总的
元素是知道的，你又知道被指向数组的大小是多少，所以可以省略。
可以这样想一个问题：
	[3][] = {0,1,2,3,4,5,6,7,9};
	[][4] = {0,1,2,3,4,5,6,7,9};
第一种方式是省略第二维，但是按照正常思维来说，你不确定列的大小，所以右无穷多种的方式来存储这已经列出的9个
数子；但是如果按照第二种写法，你已经知道列数了，所以你可以按照每一行有4个元素，顺序存储，按照二维的方法存
储，那么就会发现这个数组的大小是3*4因为你的数组存储这些数组的最小的维度就是3*4。
	      1 #include <iostream>
		  2 using namespace std;
		  3 
		  4 int main(void)
		  5 {
		  6     int a[][4] = {0,1,2,3,4,5,6,7,8};
		  7     size_t size = sizeof(a)/sizeof(a[0][0]);
		  8     cout<<size<<endl;
		  9 }
			输出结果是:
				12
验证了上述的想法！
	我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略第一个维度，所以最好不要把它包含在形参列
表中：
		void print(int matrix[][10],int rowSize){/*  */}
martrix的声明看起来是一个二维数组，但实际上形参是指向含有10个整数的数组的指针。

6.2.5	main:处理命令行选项
	main函数是演示C++程序如何向函数传递数组的好例子。到目前为止我们定义的main函数都是只有空形参列表：
		int main(){.....}
然而，有时候我们确实需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所需要执行的操作。
例如假定main函数位于可执行文件prog之内，我们可以此向程序传递下面的选项:
		prog -d -o oflie data0
这些命令行选项通过两个（可选的）形参传递给main函数：
		int main(int argc,char *argv[]){....}
第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。因为
第二个形参是数组，所以main函数可以定义成：
		int main(int argc,char **argv){...}
其中argv指向char *。
	当实参传递给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串。接下来的元素依次传递命
令行提供的实参。最后一个指针之后的元素值保证为0。
以上面提供的命令行为例，argc应该等于5，argv应该包含如下的C风格字符串：
		argv[0] = "prog";	//或者argv[0]也可以指向一个空字符串
		argv[1] = "-d";
		argv[2] = "-o";
		argv[3] = "ofile";
		argv[4] = "data0";
		argv[5] = 0;
当使用argv中的实参时，一定要记得可选实参是从argv[1]开始的；argv[0]保存程序的名字，而非用户输入。

6.2.6含有可变形参的函数
	有时候我们无法提前预知应该向函数传递几个实参。例如，我们想要编写代码输出程序产生的错误信息，此时
最好用一个函数实现该项功能，以便对所有错误的处理能够整齐划一。然而错误信息的种类不同，所以调用错误输
出函数时传递的实参也各不相同。
	为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以
传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所
谓的可变参数模板，关于它的细节将在后面介绍。
	C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。本节将要简要介绍省略符形参，
不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。

initializer_list形参
	如果函数的实参数量未知，但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。
initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同
名的头文件中，它提供的操作如下表所示：
		initializer_list<T> lst;	//默认初始化：T类型元素的空列表
		initializer_list<T> lst{a,b,c...};	//lst的元素数量和初始值一样多；lst的元素是对应
初始值的副本；列表中的元素是const
		lst2(lst)	拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和
副本共享元素
		lst2 = lst
		lst.size()		//列表中的元素数量
		lst.begin()		//返回指向lst中首元素的指针
		lst.end()		//返回指向lst中尾元素下一位置的指针！
	和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表
中所含元素的类型：
		initializer_list<string> ls;	//initializer_list的元素是string
		initializer_list<int>	li;		//initializer_list的元素类型是int
和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象
中的元素值。
	我们使用如下的形式编写输出错误信息的函数，使其可以作用于可变数量的实参：
		void error_msg(initializer_list<string> li)
		{
			for(auto beg = li.begin();beg != li.end; ++beg)
				cout<<*beg<<" ";
			cout<<endl;
		}
作用于initializer_list对象的begin和end操作类似于vector对象的成员。begin()成员提供了一个指向列表
首元素的指针，end()成员提供了一个指向列表尾后元素的指针。我们的函数首先初始化beg令其表示首元素，然后依
次遍历列表中的每个元素。在循环体中，解引用beg以访问当前元素并输出它的值。
	如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内：
		if(expected != actuall)
			error_msg({"functionX",expected,actual});
		else
			error_msg({"functionX","okday"});
在上面的代码中我们调用同一个函数error_msg，但是两次调用传递的参数数量是不同的：第一次调用传入了三个值，
第二次调用只传入了两个。
注意：
	这里为什么必须得用{}传入，因为initializer_list中的初始化方式中只有一个{a,b,c..}，这样最原始的
初始化方式，其他的都是间接使用另一个initializer_list对象给另一个这样的对象初始化。所以要是直接初始化
的时候，一定要使用{}初始化，但是要注意，a,b,c都是const常量的！
	含有initializer_list形参的函数也可以同时拥有其他形参。例如，调式系统可能有个名为ErrorCode的类
用来表示不同类型的错误，因此我们可以改写之前的程序，使其包含一个initializer_list形参和一个ErrorCode
形参。
		void error_msg(ErrorCode e,initializer_list<string> li)
		{
			/* ....　*/
		}
省略符形参
	省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varags的C标准库功能。通常，
省略符形参不应用其他目的。你的C编译器文档会描述如何使用varags。
注意：
	省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类型的对象都在传递给省略符形参时都无法
正确拷贝省略符形参只能出现在形参列表中的！！！最后一个位置！！，
它的形式无外乎于一下两种：
		void foo(parm_list,...);
		void foo(...);
第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参
无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。

6.3	返回类型和return语句
	return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return语句有两种形式：
			return ;
			return expression;
6.3.1	无返回值函数
	没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在
这类函数的最后一句后面会隐式的执行return。
	通常情况下，void函数如果想在他们的中间位置提前退出，可以使用return语句。return的这种用法有点类似于我
们用break语句退出循环。例如，可以编写一个swap函数，使其在参与交换的值相等的时候什么也不做，直接退出。！
		void swap(int &v1,int &v2)
		{
			//如果两个值是相等的，则不需要交换，直接退出
			if(v1 == v2)
				return;
			int temp = v2;
			v2 = v1;
			v1 = temp;
		}
这个函数首先检查值是否相等，如果相等就直接退出函数；如果不相等才交换他们的值。在最后一条赋值语句后后面隐式的
执行return。
	一个返回类型是void的函数也能使用return语句的第二种形式，不过此时return语句的expression必须是另外
一个返回void的函数。强行令void函数返回其他类型的表达式将产生变异错误。

6.3.2	有返回值函数
	return语句的第二种形式提供了函数的结果。只要函数的返回类型不是void，则该函数内的每条return语句必须
返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数的返回类型。
	尽管C++无法确保结果的正确性，但是可以保证每个return语句的结果类型的正确。也许无法顾及所有情况，但是
编译器仍然尽量确保具有返回值的函数只能通过一条有效的return语句退出。例如:
			bool str_subrange(const string &str1,const string &str2)
			{
				if(str1.size() == str2.size())
					return str1 == str2;
				auto size = (str1.size() < str2.size()) ? str1.size() : str2.size()
				for(decltype(size) i = 0;i != size;i++)
				{
					if(str1[i] != str2[i])
						return ;//错误，没有返回值，编译器将报告这一错误。
				}
			}

值是如何被返回的
	返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量
就是函数调用的结果。
	必须注意当前函数返回局部变量时的初始化规则。例如我们书写一个函数，给定计数值、单词和结束符之后，判断
计数值是否大于1：如果是，返回单词的复数形式；如果不是，返回单词的原形：
			string make_plural(size_t ctr,const string &word,const string &ending)
			{
				return (ctr > 1) ? word+ending : word;
			}
该函数的返回类型是string，意味着返回值将被拷贝调用到调用点。因此，该函数返回word的副本或者一个未命名的
临时string对象，该对象的内容是word和ending的和。
	同其他引用类型一样，如果函数返回引用，则该引用仅是它所引用对象的一个别名。举个例子来说明，假定某函数
挑出两个string形参中较短的那个并返回其引用：
			const string &shortString(const string &s1,const string &s2)
			{
				return s1.size() <= s2.size() ? s1 : s2;
			}
其中形参和返回类型都是const string的引用，不管是调用函数还是返回结果都不会真正拷贝string对象。

不要返回局部对象的引用或指针
	函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存
区域：
		//严重错误：这个函数试图返回局部对象的引用！！！
		const string &manip()
		{
			string ret;
			if(!ret.empty())
				return ret;//错误，返回局部对象的引用
			else
				return "Empty";//错误，"Empty"是一个局部临时变量
		}
要想确保返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪个对象？
	如前所述，返回局部对象的引用是错误的：同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被
释放，指针将指向一个不存在的对象。

返回类类型的函数和调用运算符
	和其他运算符一样，调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且
也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员。
	例如，我们可以通过如下形式得到较短string对象的长度：
		//调用string对象的size成员，该string对象是由shortString的函数返回的
		auto sz = shortString(s1,s2).size();
因为上面提到的运算符都满足左结合律，所以shortString的结果是点运算符的左侧运算对象，点运算符可以得到该
string对象的size成员，size又是第二个调用运算符的左侧运算对象。

引用返回左值
	函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像
其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值：
			char &get_val(string &str,string::size_type ix)
			{
				return str[ix];
			}
			int main()
			{
				string s("a value");	//输出 a value
				cout<< s <<endl;		//输出 a value
				get_val(s,0) = 'A';
				cout<< s <<endl;		//输出 A value
				return 0;
			}
如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的：
		shortString("hi","bye") = "X";	//错误：返回值是一个常量，不能对其进行相应的赋值运算。

列表初始化返回值
	C++11新标准规定，函数可以返回花括号包围的值的列表。类似与其他返回结果，此处的列表也用来对表示函数
返回的临时量进行初始化。如果列表为空，临时量执行值初始化：否则值由函数的返回类型决定。
	举个例子：
		vector<string>	process()
		{
			//expected 和 actual是string对象
			if(expected.empty())
				return {};	//返回一个空vector对象
			esle if(expected == actual)
				return {"functionX","okay"};
			else
				return {"functionX",expected,actual};
		}
第一条return语句返回一个空的列表，此时process函数返回的vector对象是空的。如果expected不为空，根据
expected和actual是否相等，函数返回的vector对象分别用两个或三个元素初始化。

6.3.3	返回数组指针
	因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想
定义一个返回数组的指针或引用的函数比较繁琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名：
		typedef int arrT[10];
		using arrT = int [10];
		arrT *func(int i);//func 是返回有一个指向含有10个整数的数组的指针。

声明一个返回数组指针的函数
	要想在声明func时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：
			int arr[10];	//arr是一个含有10个整数的数组
			int *p1[10];	//p1是一个数组，含有10个指针的数组
			int (*p2)[10]	//p2是一个指针，指向的是一个含有10个int元素的数组。
	和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参
列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：
			Type (*function(parameter_list)[dimension]
	类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。(*function(parameter_list))两端
的括号必须存在，就像我们定义p2时两端必须有括号一样。如果没有这对括号，函数的返回类型将是指针的数组：
	举个具体点的例子，下面这个func函数的声明没有使用类型别名：
		int (*func(int i))[10];
可以按照以下的顺序来逐层理解该声明的含义：
	>>	func(int i)表示调用func函数时需要一个int类的实参
	>>	(*func(int i))意味着我们可以对函数调用的结果执行解引用操作
	>>	(*func(int i))[10]	表示解引用func的调用将得到一个大小是10的数组。
	>>	int (*func(int i))[10]	表示数组中的元素是int类型
其实这个首先是一个指针，指向的是一个函数，该函数的返回是一个指向int数组的元素，该数组的大小是10。

使用尾置返回类型
	在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型(trailing return type)。任何函
数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。
尾后返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本该出现返回类型
的地方放置一个auto:
			//func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
			auto func(int i) -> int(*)[10];
因为我们把函数的返回类型放在了形参列表之后，所以可以清楚的看到func函数返回的是一个指针，并且该指针指向了含有10个
整数的数组。

使用decltype	
	还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的
函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的一个:
			int odd[] = {1,3,5,7,9};
			int even[] = {0,2,4,6,8};
			decltype(odd)	*arrPtr(int i)
			{
				return (i%2)?&odd : &even;
			}
其实这个和使用别名的方法是一样的，这里就不再赘述。

6.4	函数重载
	如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。例如下面：
		void print(const char *cp);
		void print(const int *beg,const int *end);
		void print(const int ia[],size_t size);
这些函数接受的形参类型不一样，但是执行的操作是非常类似的。当调用这些函数时，编译器会根据传递的实参类型推断想要
的是哪个函数：
		int j[2] = {0,1};
		print("hello world");	//调用print(const char*)
		print(j,end(j)-begin(j));	//调用print(const int ia[],size_t)
		print(bengin(j),end(j));	//调用print(const int*,const int*);
	函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻程序员起名字、记名字的负担。
注意：
		main函数是不可以重载的！！！！

定义重载函数
	有一种典型的数据库应用，需要创建几个不同的函数分别根据名字、电话、账户号码等信息查找记录。函数重载使得我
们可以定义一组函数，他们的名字都是lookup，但是查找的依据不同。我们通过以下形式中的任意一种调用lookup函数：
		Record lookup(const Account&);	//根据Account查找记录
		Record lookup(const Phone&);	//根据Phone查找记录
		Record lookup(const Name&);		//根据Name查找记录
		Account acct;
		Phone phone;
		Record r1 = lookup(acct);		//调用接受Account的版本
		Record r2 = lookup(phone);		//调用接受Phone的版本
其中，虽然我们定义的三个函数各不相同，但是他们都有同一个名字，编译器根据实参的类型确定应该调用哪一个函数。
	不允许两个函数除了返回类型外其他所有要素都相同。假设有两个函数，他们的形参列表一样但是返回类型不同，则第
二个函数的声明是错误的：
		Record lookup(const Account&);
		bool   lookup(const Account&);//错误，与上一个函数相比只有返回类型不同！！

判断两个形参的类型是否相异
	有时候两个形参列表看起来不一样，但是实际上是相同：
		Record lookup(const Account &acct);
		Record lookup(const Account &);	//省略了形参的名字
		typedef Phone Telno;
		Record lookup(const Account Phone&);
		Record lookup(const Telno&);	//Telno和Phone的类型相同

重载和const形参
	顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：
		Record lookup(Phone);
		Record lookup(const Phone);	//重复声明了Record　lookup(Phone);
		
		Record lookup(Phone *);
		Record lookup(Phone* const);	//重复声明了Record lookup(Phone*);
注意这里分析下，为什么会有的时候顶层const会在赋值的时候被自动去掉了。以下全是个人自己的见解：
	首先，在刨除引用的情况下！所有的顶层const都是保证让其不改变对应的数据，也就是常量的意思。那么普通的变量
初始化的时候，都是相当于创建相应的副本，其所操作都不会改变作为右值的内容。而顶层const的作用就是不让左值去改变
右值的内容。所以在这一点上顶层const在被赋值的时候是可以去掉的。那么接下来分析下顶层指针，其实是一样，这里也
不赘述。接下来就说说特别的引用。因为引用本身就是被赋值以后，不能再去被其他对象初始化了，也就是不会像指针一样，
可以转变指向的变量。所以引用中就没有像指针一样的底层和顶层那种明显的区别。引用只有顶层const。但是为什么顶层
的const引用和普通的引用却可以是不一样的，也就是为什么两者可以作为重载函数形参，就可以区分重载函数的。主要是
因为引用和指针一样，都可以改变被指向的对象的原始值。所以这样就不再是副本那样的东西了。顶层的const引用是不允
许通过该引用来改变引用对象的。但是普通的引用却可以来改变。所以顶层const引用就可以作为形参来区分重载函数。
所以下面的例子就可以解释通了：
			Record lookup(Account &);
			Record lookup(const Account&);	//新函数，作用于常量引用。
			Record lookup(Account *);
			Record lookup(const Account*);	//新函数，作用于指向常量的指针。
在上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数。因为const不能转换成其他类型。所以我们
只能把const对象（或指向const的指针)传递给const形参。相反的，因为非常量可以转换成const。所以上面的4
个函数都能作用于非常量对象或者指向非常量对象的指针。但是当我们传递一个非常量或者指向非常量对象的指针时，
编译器会优先选用非常量版本的函数。

const_cast和重载
	const_cast在重载函数的情况中最有用。举个例子，回忆以前的shortString函数：
			const string &shortString(const string &s1,const string &s2)
			{
				return s1.size() <= s2.size() ? s1 : s2;
			}
这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的
结果仍然是const string的引用，因为我们需要一种新的shortString函数，当它的实参不是常量的时候，得到的结果是一个普通的引用。使用const_cast可以做到这一点：
		string &shortString(string &s1,string &s2)
		{
			auto &r = shortString(const_cast<const string &>(s1),const_cast<const string &>(s2));
			return const_cast<string &>(r);
		}
在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shortString函数的const版本。const版
本返回对const string的引用，这个引用事实上绑定在了某个初始的实参上。因此，我们可以再将其转换成一个普通的
string &,这显然是安全的。

调用重载的函数
	定义了一组重载函数后，我们需要以合理的实参调用他们。函数匹配是指一个过程，在这个过程中我们把函数调用与
一组重载函数中的某一个关联起来，函数匹配也叫做重载确定。编译器首先将调用的实参与重载集合中每一个函数的形参进
行笔记，然后根据比较的结果决定到底调用哪个函数。
	现在我们需要掌握的是，当调用重载函数时有三种可能的结果：
		>>> 编译器找到一个与实参最佳匹配（best match)的函数，并生成调用该函数的代码
		>>>	找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息
		>>>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用。

6.4.1	重载与作用域
	对于刚刚接触C++的程序员来说，不太容易理清作用域和重载的关系。其实，重载对作用域的一般性质并没有什么改
变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：
		string read();
		void print(const string &);
		void print(double );
		void fooBar(int val)
		{
			bool read = false;
			string s = read();//	错误，因为在该作用域中已经定义了一个read，该类型为bool。所以屏蔽了外层的函数的声明
			void print(int);
			print("Value :");//	错误，因为在该层作用域中，已经定义了print的函数，并且其参数是int类型的，所以屏蔽了外层的print函数。
		}

6.5	特殊用途语言特性
	本节我们介绍三种函数相关的语言特性，这些特性对大多数程序都有用，它们分别是：
		默认实参，内联函数和constexpr函数，以及在程序调试过程中常用的一些功能。
6.5.1	默认实参
	形式：
		typedef string::size_type sz;
		string screen(sz ht = 24,sz wid = 80,char backgrnd = ' ');
其中我们为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义
默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。
这里解释下为什么必须有默认值：比如说一个函数有三个形参int a,int b=10,int c，但是你调用的时候输入的实
参只有两个(10,20)这个时候，编译器会根据形参挨个赋值，所以a=10,b=20，然后编译器发现没有给c赋值，所以就
会报错。但是如果默认实参后边全是默认的，那么就不会有问题，因为后边的都有默认值，所以不会担心实参的个数会因为
少而报错。（注意这里的少，是指的在满足所有没有默认参数的形参的情况下，而对于默认形参的赋值少的情况下）

默认实参声明
	对于函数的声明来说，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合
法的。不过有一点要注意，在给定的作用域中一个形参只能被赋予！！！一次默认实参。！！！换句话说，函数的后
续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。假如给定：
		string screen(sz,sz,char = ' ');
我们不能修改一个已经存在的默认值：
		string screen(sz,sz,char = '*');	//错误，重复声明（其实就是一个默认形参只能被赋值一次）
但是可以按照如下形式添加默认实参：
		string screen(sz=24,sz=80.char);	//正确，添加默认实参。
通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。

默认实参初始值
	局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成所需的类型，该表达式就能作为默认实参：
	//wd、def和ht的声明必须出现在函数之外
	sz wd = 80;
 	char def = ' ';
	sz ht();
	string screen(sz = ht(),sz = wd,char = def);	//该方法就是重新添加默认实参。
	string window = screen();	//调用 screen(ht(),80,' ')
用作默认实参的名字在函数声明所在的作用内解析，而这些名字的求职过程发生在函数调用时：
		void f2()
		{
			def = '*';	//改变了默认实参的值def
			sz wd = 100;//隐藏了外层定义的wd，但是没有改变默认值，因为局部变量不能作为默认实参
			window = scree();//调用screen(ht(),80,'*');
		}
我们在函数f2内部改变了def的值，所以对screen的调用将会传递这个更新过的值。（因为什么呢？主要是因为，函数在
调用的时候肯定会去找对应的形参进行实参赋值，所以如果原先的默认实参的值发送改变以后，那么默认的实参的值也会发
生改变）。另一方面，虽然我们的函数还声明一个局部变量用于隐藏外层的wd，但是该局部变量与传递给screen的默认
实参没有任何关系，因为局部变量能作为默认实参。

6.5.2	内联函数和constexpr函数
内联函数可以避免函数调用的开销
	将函数指定成为内联函数(inline)，通常就是将它在每个调用点上“内联”地展开，假设我们把shortString函数
定义成内联函数，则如下调用：
		cout<<shortString(s1,s2)<<endl;
将在编译过程中展开成类似于下面的形式：
		cout<<(s1.size() < s2.size() ? s1 : s2)<<endl;
从而消除了shortString函数的运行时开销
	在shortString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了。
inline const string &shortString(const string &s1,const string &s2)
{
	return s1.size()  < s2.size() ? s1 : s2;
}

constexpr函数
	constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要
遵循几项约定：
	>>>函数的返回类型及所有形参的类型都得是字面值类型
	>>>而且函数体中必须有且仅有一条return语句。
		constexpr int new_sz() { return 42;}
		constexpr int foo = new_sz();	//正确foo是一个常量表达式
我们把new_sz定义成无参数的constexpr函数。因为编译器能在程序编译的时候验证new_sz函数返回的是常量表达式，
所以可以用new_sz函数初始化constexpr类型的变量foo。
	执行初始化任务时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr
函数被隐式的指定为内联函数。constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。
例如，constexpr函数中可以有空语句、类型别名以及using声明。
	我们运行constexpr函数的返回值并非常量：
	//如果arg是常量表达式，则scale(arg)也是常量表达式
	constexpr size_t scale(size_t cnt)
	{
		return new_sz() * cnt; 
	}
			int arr[scale(2)];	//正确,scale(2)是常量表达式，因为在C++中允许使用常量表达式给数组的维度赋值
			int i = 2;
			int a2[scale(i)];	//错误：scale(i)不是常量表达式
所以注意：
			constexpr函数不一定返回常量表达式！！！
把内联函数和constexpr函数放在头文件中
	和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟编译器要想展开函数，仅有函数声明是
不够的，它还需要函数的定义。不过对某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。
基于这个原因，内联函数和constexpr函数通常定义在头文件中。

6.5.3	调式帮助
	C++程序员有时会调用一种类似于头文件保护的技术，以便有选择地执行调试代码。这种方法用到两项预处理功能:assert和NDEBUG。
assert预处理宏
	assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表
达式作为它的条件：
			assert(expr);
首先对expr求值，如果表达式为假，assert输出信息并终止程序的执行。如果表达式为真，assert什么也不做。
	assert宏定义在cassert头文件中。如我们所知，预处理名字由预处理器而非编译器管理，因此我们可以直接使用
预处理名字而无需提供using声明。也就是说，我们应该使用assert而不是std::assert，也不要为assert提供using
声明。
	和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者
其他实体。在实际编程过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都
包含了cassert，这就意味着即使你没有直接包含cassert，它也很有可能通过其他途径包含在你的程序中。
	assert宏常用于检查"不能发生"的条件。例如，一个对输入文本进行操作的程序可能要求所有给定的单词的长度都
大于某个阈值。此时程序可以包含一条吐下所示的语句：
		assert(word.size() > threshold);

NDEBUG	预处理变量
	assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下
没有定义NDEBUG，此时assert将执行运行时检查。
	我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们
可以预处理变量：
		$	CC -D NDEBUG main.c 
这条命令的作用等价于在main.c文件的一开始书写#define NDEBUG。
	除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifdef和#endif
之间的代码：如果定义了NDEBUG，这些代码将被忽略掉:
		void print(const int ia[],size_t size)
		{
			#ifndef NDEBUG
			//__func__是编译器定义的一个局部静态变量，用于存放函数的名字
				cerr<<__func__<<": array size is "<<size<<endl;
			#endif
		}
在这段代码中，我们使用变量__func__输出当前调试的函数的名字。编译器为每个函数都定义了__func__，他是const 
char的一个静态数组，用于存放函数的名字。
	除了C++编译器定义的__func__之外，预处理器还定义了另外4个对于程序调试很有用的名字：
			__FILE__	存放文件名的字符串字面值
			__LINE__	存放当前行号的整型字面值
			__TIME__	存放文件编译时间的字符串字面值
			__DATA__	存放文件编译日期的字符串字面值

6.6	函数匹配
确定候选函数和可行函数
	函数匹配的的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数。候选函数具备两个特征：
		>>>与被调用的函数同名
		>>>其声明在调用点可见
	第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。
可行函数也有两个特征：
		>>>形参数量与本次调用提供的实参数量相等
		>>>每个实参的类型与对应的形参的类型相同，或者能转换成形参的类型。

6.7	函数指针
	函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参
类型共同决定，与函数名无关。例如：
		bool lengthCompare(const string &,const string &);
该函数的类型是bool(const string &,const string &)。要想声明一个可以指向该函数的指针，只需要用指针替
代函数名即可：
		bool (*pf)(const string &,const string &);
*pf两端的括号必不可少。如果不写这对括号，则pf
是一个返回值为bool指针的函数:
		bool *pf(const string &,const string &);

使用函数指针
	当我们把函数名作为一个值使用时，该函数自动转换成指针。例如，按照如下形式我们可以将lengthCompare的
地址赋给pf:
		pf = lengthCompare;		//pf指向名为lengthCompare的函数
		pf = &lengthComapre;	//等价的赋值语句：取地址符可选的！！
此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：
		bool b1 = pf("hello","goodbye");	//调用lengthCompare函数
		bool b2 = (*pf)("hello","goodbye");	//一个等价的调用
在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整形常量
表达式。表示该指针没有指向任何一个函数！
		string::size_type sumLength(const string&,const string&);
		bool cstringCompare(const char*,const char*);
		pf = 0;		//正确:of不指向任何函数
		pf = sumLengthl		//错误，返回类型不匹配
		pf = cstringCompare;	//错误：形参类型不匹配
重载函数的指针
	当我们使用重载函数时，上下文必须清晰的界定到底应该选用哪个函数。如果定义了指向重载函数的指针
		void ff(int*);
		void ff(unsigned int);
		void (*pf)(unsigned int) = ff;	//pf指向ff(unsigned int)
编译器通过指针类型决定选用哪个调用函数，指针类型必须与重载函数中的某一个精确匹配！
		void (*pf2)(int) = ff;	//错误，没有任何一个ff与该形参列表匹配
		double (*pf3)(int *) = ff;	//错误：ff和of3的返回类型不匹配。

函数指针形参
	和数组类似，虽然不能定义函数类型的参数，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上
确实当成指针使用。
	//第三个形参是函数类型，它会自动转换成指向函数的指针
	void userBigger(const string &s1,const string &s2,bool pf(const string &,const string &s));
	//等价的声明：显示地将形参定义成指向函数的指针
	void useBigger(const string &s1,const string &s2,bool (*pf)(const string &,const string &));
我们可以直接把函数作为实参使用，此时他会自动转换成指针：
	//	自动将函数lengthCompare转换成指向该函数的指针
	useBigger(s1,s2,lengthCompare);
正如useBigger的声明语句所示，直接使用函数指针类型显得冗长而繁琐。类型别名和decltype能让我们简化使用
函数指针代码：
		typedef bool Func(const string&,const string &);
		typedef decltype(lengthCompare) Func2;	//等价的类型
		
		//FuncP和Funcp2是指向函数的指针
		typedef bool(*Funcp)(const string &,const string&);
		typedef decltype(lengthCompare) *Funcp2;
理解下，Funcp2。
	首先，lengthCompare作为一个返回类型是bool (const string &,const string &)类型。然后Funcp2
左结合的是*，所以该Funcp2是一个指针，然后指向的是decltype(lengthCompare)的函数类型。

返回指向函数的指针
	和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而我么必须把返回类型写成指针形式，
编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单
的办法就是使用类型别名：
		using F = int(int *,int);	//F是函数类型，不是指针
		using PF = int (*)(int *,int);	//PF是指针类型
其中我们使用类型别名将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型形参不一样，
返回类型不会自动地转换成指针。我们必须显示地将返回类型指定为指针。
		PF f1(int);		//正确：PF是指向函数的指针，f1返回指向函数的指针
		F f1(int);		//错误：F是函数类型，f1不能返回一个函数
		F *f1(int);		//正确：显示地指定返回类型是指向函数的指针。
	当然，我们也能用下面的形式直接声明f1:
		int (*f1(int))(int *,int);
解释下：
	首先根据优先级发现f1是一个函数，返回类型是一个指针，指针指向的是一个函数，函数的返回类型是int类型。
由于完整性的考虑，有必要提醒读者，我们还可以使用尾置返回类型的方式声明一个返回函数指针的函数：
		auto f1(int)->int (*)(int *,int);
注意：
	尾置返回类型就是前面的auto使用尾置后面的类型！！
将auto和decltype用于函数指针类型
	如果我们明确的知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。例如假定
有两个函数，他们的返回类型都是string::size_type,并且各有两个const string&类型的形参，此时我们可以编写
第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个。
		string::size_type	sumLength(const string&,const string&);
		string::size_type	largerLength(const string&,const string&);
		decltype(sumLength) *getFcn(const string&);
声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。
