					第十八章		用于大型程序的工具
内容　
------------------------------------
	18.1 异常处理
	18.2 命名空间
	18.3　多重继承与虚继承
------------------------------------
	C++语言能解决的问题规模千变万化，有的小到一个程序员几小时就能完成，有的则是含有几千万行代码的庞大
系统。需要几百个程序员协同工作好几年。本书之前介绍的内容对各种规模的编程问题都适用。
	除此之外，C++语言还包含其他一些特征，当我们编写比较复杂的、小组和个人难以管理的系统时，这些特征
最为有用。本章的主题即是向读者介绍这些特征，他们包含异常处理、命名空间和多重继承。
	与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求是高。大规模应用程序的特殊
要求包括:
		>>>	在独立开发的子系统之间协同处理从错误的能力
		>>>	使用各种库(可能包含独立开发的库)进行协同开发的能力
		>>>	对比较复杂的应用概念建模的能力。
本章介绍的三种C++语言特性正好满足上述要求，它们是:异常处理、命名空间和多重继承。

18.1	异常处理
	异常处理机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常使得
我们能够将问题的检测与解决过程分离开来，程序的一部分负责检测问题的出现，然后解决该问题的任务传递给
程序的另一部分。检测环节无须知道问题处理模块的所有细节，反之亦然。
	在5.6节我们曾介绍过一些有关异常处理的基本概念和机理，本节将继续扩展这些知识。对于程序员来说，
要想有效地使用异常处理，必须首先了解当抛出异常时发生了什么，捕获异常时发生了什么，以及用来传递错
误的对象的意义。

18.1.1	抛出异常
	在C++语言中，我们通过抛出一条表达式来引发一个异常。被抛出的表达式的类型以及当前的调用链共同
决定了哪段处理代码将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理
代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么错误。
	当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹
配的catch模块。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数
的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义:
		>>>	沿着调用链的函数可能会提早退出
		>>>	一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。
因为跟在throw后面的语句将不在被执行，所以throw语句的用法有点类似return语句：它通常作为条件语句
的一部分或者作为某个函数的最后(或者唯一)一条语句。

栈展开
	当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出
现在在一个try语句块内时，检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch
处理异常。如果这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的
catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找。
	如果对抛出异常的函数的调用语句位于一个try语句块内，则检查与该try块关联的catch子句。如果找
到了匹配的catch，就使用该catch处理异常。否则，如果该try语句嵌套在其他try块中，则继续检查与外
层try匹配的catch子句。如果仍然没有找到匹配的catch，则退出当前这个主调函数，继续在调用了刚刚退
出的这个函数的其他函数中寻找，依次类推。
	假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，
找到与try块关联的最后一个catch子句之后的定点，并从这里继续执行。
	如果没有找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事情，所以一
旦引发了某个异常，就不能对它置之不理。当找不到匹配的catch时，程序将调用标准库函数terminate，顾
名思义，terminate负责终止程序的执行过程。
注意:
	一个异常如果没有被捕获，则它将终止当前的程序

栈展开过程中对象被自动销毁
	在栈展开过程中，位于调用上链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局
部对象。我们已经知道，块退出后他的局部对象也将随之销毁，这条规则对于栈展开过程同样使用。如果在栈
展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。如果某个局部对象的类
型是类类型，则该对象的析构函数将被自动调用。与往常一样，编译器在销毁内置类型的对象时不需要做任何
事情。
	如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成
员在异常发生前也许还没有初始化。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确的销
毁。
	类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如果在异常发生前已经
构造了一部分元素，则我们应该确保这部分元素被正确地销毁。

析构函数与异常
	析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，这一特点对于我们如何组织程
序结构有重要影响。如我们在12.1.4节介绍过的。如果一个块分配了资源，并且在负责释放这些资源的代码
前面发生了异常，则释放资源的代码将不会被执行。另一方面，类对象分配的资源将由类的析构函数负责释放。
因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。
	析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。在栈展开的过程中，已经引
发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获。则系统将调用terminate函数。因此，出
于栈展开可能使用析构函数得考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数
需要执行某个可能抛出的异常的操作，则该操作应该被放置在一个try语句块当中，并且在析构函数内部得到
处理。
	在实际编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保
它们的析构函数不会引发异常。
注意:
	在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应
该抛出异常。一旦在栈展开过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终
止。

异常对象
	异常对象是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，throw语
句中的表达式必须拥有完全类型。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函
数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应
的指针类型。
	异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个catch子句都能访问该空间。当
异常处理完毕后，异常对象被销毁。
	如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退
出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向局部对象的指针几乎肯定是一种错误
行为。出于同样的原因，从函数中返回指向局部对象的指针也是错误的。如果指针所指的对象位于某个块中，
而该块在catch语句之前就已经退出了，则意味着在执行catch语句之前局部对象已经被销毁了。
	当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型。读者必须牢记这一点，
因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条throw表达式解引用一个基类指针，
而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。
注意:
	抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。

18.1.2	捕获异常
	catch子句中的异常声明看起来好像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch
无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。
	声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是
右值引用。
	当进入一个catch语句后，通过异常对象初始化异常声明中的参数。和函数的参数类似，如果catch的
参数类型是非引用类型，则该参数是异常对象的一个副本，在catch语句内改变该参数实际上改变的是局部副本
而非异常对象的本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此
时改变参数也是改变异常对象。
	catch的参数还有一个特性也与函数的参数非常类似:如果catch的参数是基类类型，则我们可以使用其
派生类类型的异常对象对其进行初始化。此时，如果catch的参数是非引用类型，则异常对象被切掉一部分，这
与将派生类对象以值传递的方式传给一个普通的函数差不多。另一方面，如果catch的参数是其基类的引用，则
该参数将以常规方式绑定到异常对象上。
	最后一点要注意的是，异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类
类型，则catch无法使用派生类特有的任何成员。
注意:
	通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型

查找匹配的处理代码
	在搜寻catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该
是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。
	因为catch语句是按照其出现的顺序逐一进行匹配的。所以当程序使用具有继承关系的多个异常时必
须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前。
	与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。此时，绝大多数类
型转换都被允许，除了一些极细小的差别之外，要求异常的类型和catch声明的类型是精确匹配的:
		>>>	允许从非常量向常量类型转换，也就是说，一条非常量对象的throw语句可以匹配一个接
受常量引用的catch语句。
		>>>	允许从派生类访问基类的类型转换
		>>>	数组被转换成指向数组(元素)类型的指针，函数被转换成指向该函数类型的指针。
除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch的过程中使用。
注意:
	如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类放在前面，而将
继承链最顶端的类放在后面。

重新抛出
	有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的catch
可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出的操作将异常传递给另一
个catch语句。这里的重新抛出仍然是一条throw语句，只不过不包含任何表达式:
		throw;
空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的
区域遇到了空throw语句，编译器将调用terminate。
	一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。很多时候，catch
语句会改变其参数的内容。如果在改变了参数的内容后catch语句重新抛出异常，则只有当catch异常声明是
引用类型时我们对参数所做的改变才会被保留并继续传播:
		catch (my_error &eObj){
			eObj.status = errCodes::serverErr;	//修改了异常对象
			throw;
		}catch (other_error eObj){
			eObj.status = errCodes::badErr;	//只修改了异常对象的局部副本
			throw;	//异常对象的status成员并没有改变
		}

捕获所有异常的处理代码
	有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。要想捕获所有可能的异常是比
较有难度的。毕竟有些情况下我们也不知道异常的类型到底是什么。即使我们知道所有的异常类型，也很难
为所有类型提供唯一一个catch语句。为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处
理代码称为捕获所有异常的处理代码，形如catch(...)。一条捕获所有异常的语句可以与任意类型的异
常匹配。
	catch(...)通常与重新抛出语句一起使用，其中执行当前局部能完成的工作，随后重新抛出异常。
		void manip(){
			try{
				//这里的操作将引发并抛出一个异常
			}
			catch(...){
				//处理异常的某些特殊操作
			}
		}
catch(...)既能单独出现，也能与其他几个catch语句一起出现。
注意:
	如果catch(...)与其他几个catch语句一起出现，则catch(...)必须在最后的位置。出现在
捕获所有异常语句后面的catch语句将永远不会被匹配。

18.1.3函数try语句块与构造函数
	通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在处理构造函数初值的过程
中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的try
语句块还未生效，所以构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常。
	要想处理构造函数初值抛出的异常，我们必须将构造函数写成函数try语句块(也称为函数测试块)的
形式。函数try语句块使得一组catch语句既能处理构造函数体(或析构函数体)，也能处理构造函数的初始
化过程(或析构函数的析构过程)。举个例子，我们可以把Blob构造函数置于一个函数try语句块中:
		template <typename T> Blob<T>::Blob(std::initializer_list<T> il) 
		try : data(std::make_shared<std::vector<T>>(il))
		{
			/*空函数体*/
		}catch(const std::bad_alloc &e){
			handle_out_of_memory(e);
		}
注意:关键字try出现在表示构造函数初始值列表的冒号以及表示构造函数体(此例为空)的花括号之前，与
这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。
	还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生　异常，这样的异常不属于函数
try语句块的一部分。函数try语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如
果在参数初始化过程中发生了异常，则该异常属于调用表达式的一部分，并将在调用者所在的上下文中处理。
注意:
	处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。

18.1.4	noexcept异常说明
	对于用户及编译器来说，预先知道某个函数不会抛出一异常显然大有裨益。首先，知道函数不会抛出
异常有助于简化调用该函数的代码；其次，如果编译器确认函数函数不会抛出异常，它就能执行某些特殊化
的优化操作，而这些优化操作并不适用于可能出错的代码。
	在C++11新标准中，我们可以通过提供noexcept说明指定某个函数不会抛出异常。其形式是关键字
noexcept紧跟在函数的参数列表后面，用以标识该函数不会抛出异常:
		void recoup(int) noexcept;	//不会抛出异常
		void alloc(int);			//可能抛出异常
这两条声明语句指出recoup将不会抛出任何异常，而alloc可能抛出异常。我们说recoup做了不抛出说
明。
	对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不
出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定noexcept。在
typedef或类型别名中则不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用
限定符之后，而在final、override或虚函数的=0之前。

违反异常说明
	读者需要清楚的一个事实是编译器并不会在编译时检查noexcept说明。实际上，如果一个函数在说
明了noexcept的同时又含有throw语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并
不会因为这种违反异常说明的情况而报错(不排除个别编译器会对这种用法提出警告):
		//尽管该函数明显违反了异常说明，但它仍然可以顺利编译通过
		void f() noexcept		//承诺不会抛出异常
		{
			throw exception();	//违反了异常说明
		}
因此可能出现这样一种情况:尽管函数声明了它不会抛出异常，但实际上还是抛出了。一旦一个noexcept
函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行
栈展开来作约定，因此noexcept可以用在两种情况下:一是我们确认函数不会抛出异常，二是我们根本不
知道该如何处理异常。
	指明某个函数不会抛出异常可以令该函数的调用着不必考虑如何处理异常。无论是函数确实不抛出异
常，还是程序被终止，调用者都无须为此负责。
注意:
	通常情况下，编译器不能也不必在编译时验证异常说明。

向后兼容:异常说明
	早期的C++版本设计了一套更加详细的异常说明方案，该方案使得我们可以指定某个函数可能抛出的
异常类型。函数可以指定一个关键字throw，在后面跟上括号括起来的异常类型列表。throw说明符所在
的位置与新版本C++中noexcept所在的位置相同。
	上述使用throw的异常说欧美方案在C++11新版本中已经被取消了。然而尽管如此，它还有一个重
要的用处。如果函数被设计为是throw()的，则意味着该函数将不会抛出异常:
		void recoup(int) noexcept;	//recoup将不会抛出异常
		void recoup(int) throw();	//等价的声明
上面两条声明语句是等价的，他们都承诺recoup不会抛出异常。可以这样理解，要是throw()有异常的话，
就会在括号里写上相应的参数了，但是没有异常的话，就不用写了。

异常说明的实参
	noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型：如果实参是true，则函数不
会抛出异常；如果实参是false，则函数可能抛出异常:
		void recoup(int) noexcept(true);	//recoup不会抛出异常
		void alloc(int) noexcept(false);	//alloc可能会抛出异常

noexcept运算符
	noexcept说明符的实参常常与noexcept运算符混合使用。noexcept运算符是一个一元运算符。
它的返回值是一个bool类型的右值常量表达式，用于给定的表达式是否会抛出异常。和sizeof类似，noexcept
也不会求其运算对象的值。
	例如，因为我们声明recoup时使用了noexcept说明符，所以下面的表达式的返回值为true:
		noexcept(recoup(i))	//如果recoup不抛出异常则结果为true；否则结果为false
更普通的形式是:
		noexcept(e)
当e调用的所有函数都做了不抛出说明且e本身不含有throw语句时，上述表达式为true；否则noexcept(e)
返回false。
	我们可以使用noexcept运算符得到如下的异常说明:
		void f() noexcept(noexcept(g()));	//f个g的异常说明一致
如果函数g承诺了不会抛出异常，则f也不会抛出异常；如果g没有异常说明符，或者g虽然有异常说明符
但是允许抛出异常，则f也可能抛出异常。
注意:
	noexcept有两层意义:当跟在函数参数列表后面时它是异常说明符；而当作为noexcept异常说
明的bool实参出现时，它是一个运算符。

异常说明与指针、函数和拷贝控制
	尽管noexcept说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响函数的使用。
	函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个指针做了不抛
出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出
异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以:
		//recoup和pf1都承诺不会抛出异常
		void (*pf1)noexcept = recoup;
		//正确:recoup不会抛出异常，pf2可能抛出异常，二者之间互不干扰
		void (*pf2)(int) = recoup;
		pf1 = alloc;	//错误：alloc可能抛出异常，但是pf1已经说明了它不会抛出异常
		pf2 = alloc;	//正确:pf2可以指向任何函数
如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；相反，如果基类的
虚函数允许抛出异常，则派生类的对应的函数既可以允许抛出异常，也可以不允许抛出异常:
		class Base{
		public:
			virtual double f1(double)noexcept;	//不会抛出异常
			virtual int f2()noexcept(false);		//可能抛出异常
			virtual void f3();		//可能抛出异常
		};
		class Derived : public Base{
		public:
			double f1(double);		//错误:Base::f1承诺不会抛出异常，但这里却可以出现异常
			int f2()noexcept(false);//正确:与Base::f2的异常说明一致
			void f3()noexcept;		//正确:Derived的f3做了更严格的限定
		};
当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会
抛出异常，则合成的成员是noexcept的。如果合成成员调用的任意一个析构函数可能抛出异常，则合成的
成员是noexcept(false)。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器
将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所有的异常说明一致。

18.1.5	异常类层次
	标准库异常类构成了图18.1所示的继承体系:
					exception
			/		/	\		\
		   /	   /	 \		 \
	   bad_cast	  /		  \	    bad_alloc
				 /		   \
		  runtime_error   logic_error
				|			|
				|			|____domain_error
overflow_error--|			|____invalid_argument
underflow_error-|			|____out_off_range
  range_error---|			|____length_error

类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员。其中
what函数返回一个const char *，该指针指向一个以unll结尾的字符数组，并且确保不会抛出任何异常。
	类exception、bad_cast和bad_alloc定义了默认构造函数。类runtime_error和logic_error
没有默认构造函数，但是有一个可以接受C风格字符串或者标准库string类型实参的构造函数，这些实参
负责提供关于错误的更多信息。在这些类中，what负责返回用于初始化异常对象的信息。因为what是虚函数，
所以当我们捕获基类的引用时，对what函数的调用将执行与异常对象动态类型对应的版本。

书店应用程序的异常类
	实际的应用程序通常会自定义exception(或者exception的标准库派生类)的派生类以扩展其继承体系。
这些面向应用的异常类表示了与应用相关的异常条件。如果我们构建的是一个真实的书店应用程序，则其中的类将
比本书之前所示的复杂的多。复杂性的一个方面就是如何处理异常。实际上，我们很可能需要建立一个自己的异常
类体系，用它类表示与应用相关的各种问题。我们设计的异常类可能如下所示:
		//为某个书店应用程序设定的异常类
		class out_of_stock : public std::runtime_error{
		public:
			explicit out_of_stock(const std::string &s)
				:std::runtime_error(s){}
		};
		class isbn_mismatch : public std::logic_error{
		public:
			explicit isbn_mismatch(const std::string &s): std::logic_error(s){}
			isbn_mismatch(const std::string &s,
						  const std::string &lhs,
						  const std::string &rhs)
					:std::logic_error(s),left(lhs),right(rhs){}
			const std::string left,right;
		};
由上可知，我们的面向应用的异常类继承自标准异常类。和其他继承体系一样，异常类也可以看做按照层次关系
组织的。层次越低，表示的异常情况就越特殊。例如，在异常类继承体系中位于最顶层的通常是exception，
exception表示的含义是某处出错了，至于错误的细节则未描述。继承体系的第二层将exception划分为两
个大类别：运行时错误和逻辑错误。运行时错误表示的是只有在程序运行时才能检测到错误；而逻辑错误一般指
的是我们可以在程序代码中发现的错误。
	我们的书店应用程序进一步细分上述异常类别。名为out_of_stock的类表示在运行时可能发生的错误，
比如某些顺序无法满足：名为isbn_mismatch的类表示logic_error的每一个特例，程序可以通过比较对象
的isbn()结果来组织或处理这一错误。

使用我们自己的异常类型
	我们使用自定义异常类的方式与使用标准异常类的方式完全一样。程序在某处抛出异常类型的对象，在另
外的地方捕获并处理这些出现的问题。举个例子，我们可以为Sales_data类定义一个复合加法运算
符，当检测到参与加法的两个ISBN编号不一致时抛出名为isbn_mismatch的异常:
		//如果参与加法的两个对象并非同一本书籍，则抛出一个异常
		Sales_data &Sales_data::operator+=(const Sales_data &rhs)
		{
			if(isbn() != rhs.isbn())
				throw isbn_mismatch("wrong isbns",isbn(),rhs.ibsn());
			units_sold += rhs.units_sold;
			revenue += rhs.revenue;
			return *this;
		}
使用了复合加法运算符的代码将能检测到这一错误，进而输出一条相应的错误信息并继续完成其他任务:
		//使用之前设定的书店程序异常类
		Sales_data item1,item2,sum;
		while(cin>>item1>>item2){
			try{
				sum = item1+item2;
			}catch (const isbn_mismatch &e){
				cerr<<e.what()<<": left isbn("<<e.left
					<<") right isbn("<<e.right<<")"<<endl;
			}
		}

18.2	命名空间
	大型程序往往会使用多个独立开发方法的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用
程序用到多个供应商提供的库时，不可避免的会发生某些名字相互冲突的情况。多个库将名字放置在全局命名空间中
将引入命名空间污染。
	传统上，程序员通过将其定义的全局实体名字设的很长来避免命名空间污染问题。这样的名字中通常包含表示
名字所属库的前缀部分:
		class cplusplus_primer_Query{...};
		string cplusplus_primer_make_plural(size_t,string &);
这种解决方案显然不太理想：对于程序员来说，书写和阅读这么长的名字费时费力且过于繁琐。
	命名空间(namespace)为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个
命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者(以及用户)可以避免全局名字固有的限制。

18.2.1	命名空间定义
	一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是
一系列花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类，变量(
及其初始化操作)、函数(及其定义)、模板和其他命名空间:
		namespace cplusplus_primer{
			class Sales_data{/*...*/};
			Sales_data operator+(const Sales_data&,const Sales_data&);
			class Query{/*...*/};
			class Query_base{/*...*/};
		}//命名空间结束后无序分号，这一点与块类似
上面的代码定义了一个名为cplusplus_primer的命名空间，该命名空间包含四个成员：三个类和一个重载的+
运算符。
	和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域
内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。
注意:
	命名空间作用域后面无须分号。

每个命名空间都是一个作用域
	和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不
同，所以在不同命名空间内可以有相同名字的成员。
	定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的
任何单位访问。位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间:
		cplusplus_primer::Query q = cplusplus_primer::Query("hello");
如果其他命名空间(比如说AddisonWesley)也提供了一个名为Query的类，并且我们希望使用这个类替代
cplusplus_primer中定义的同名类。则可以按照如下方式修改代码:
		AddisonWesley::Query q = AddisonWesley::Query("hello");

命名空间可以是不连续的
	如我们在16.5节介绍过的，命名空间可以定义在几个不同的部分，这一点与其他作用域不太一样。编写如下
的命名空间定义:
		namespace nsp{
		//相关声明
		}
可能是定义了一个名为nsp的新命名空间，也可能是为已经存在的命名空间添加一些新成员。如果之前没有名为
nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其
添加一些新成员的声明。
	命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，
命名空间的组织方式类似于我们管理自定义类及函数的方式:
		>>>	命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该
置于头文件中，这些头文件将被包含在使用了这些成员的文件中。
		>>>	命名空间成员的定义部分则置于另外的源文件中。
在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定义的名字也需要满足
这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数
和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明。
注意:
	定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关联类型构成的集合)。

定义本书的命名空间
	通过使用上述接口与实现分离的机制，我们可以将cplusplus_primer库定义在几个不同文件中。
Sales_data类的声明及其函数将置于Sales_data.h头文件中，第15章介绍的Query类将置于Query.h头
文件中，依次类推，对应的实现文件将分别是Sales_data.cc和Query.cc:
		//Sales_data.h
		#include <string>
		namespace cplusplus_primer{
			class Sales_data{/*...*/};
			Sales_data operator+(const Sales_data &,const Sales_data &);
			//Sales_data的其他接口函数的声明
		}
		//Sales_data.cc
		//确保#include出现在打开命名空间的操作之前
		#include "Sales_data.h"
		namespace cplusplus_primer{
		//Sales_data成员及重载运算符的定义
		}
程序如果想使用我们定义的库，必须包含必要的头文件，这些头文件中的名字定义在命名空间cplusplus_primer
内:
		//--user.cc--
		//Sales_data.h头文件的名字位于命名空间cplusplus_primer中
		#include "Sales_data.h"
		int main()
		{
			using cplusplus_primer::Sales_data;
			Sales_data trans1,trans2;
			//...
			return 0;
		}
这种程序的组织方式提供了开发者和库用户所需的模块性。每个类仍组织在自己的接口和实现文件中，一个类的
用户不必编译与其他类相关的名字。我们对用户隐藏了实现细节，同时允许文件Sales_data.cc和user.cc被
编译并链接成一个程序而不会产生任何编译时错误或链接时错误。库的开发者可以分别实现每一个类，相互之间
没有干扰。
	有一点需要注意，在通常情况下，我们不把#include放在命名空间内部。如果我们这么做了，隐含的意
思是把所有的名字定义成该命名空间的成员。例如，如果Sales_data.h在包含string头文件前就已经
打开了命名空间cplusplus_primer，则程序将出错，因为这么做意味着我们试图将命名空间std嵌套在命名
空间cplusplus_primer中。

定义命名空间成员
	假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一个命名空间定义的名字的简写形式:
		#include "Sales_data.h"
		namespace cplusplus_primer{	//重新打开命名空间cplusplus_primer
		//命名空间中定义的成员可以直接使用名字，此时无须前缀
		std::istream & operator>>(std::istream &in,Sales_data &s){/*...*/}
		}
也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的
定义需要明确指出其所属的命名空间:
		//命名空间之外定义的成员必须使用过含有前缀的名字
		cplusplus_primer::Sales_data 
		cplusplus_primer::operator+(const Sales_data &lhs,const Sales_data &rhs){
			Sales_data ret(lhs);
			//...
		}
和定义在类外部的类成员一样，一旦看到含有完整前缀的名字，我们就可以确定该名字位于命名空间的作用域内。
在命名空间cplusplus_primer内部，我们可以直接使用该命名空间的其他成员，比如在上面的代码中，可以
直接使用Sales_data定义函数的形参。
	尽管命名空间的成员可以定义在命名空间外部，但是这样的定义必须出现在所属命名空间的外层空间中。
换句话说，我们可以在cplusplus_primer或全局作用域中定义Sales_data operator+,但是不能
在一个不相关的作用域中定义这个运算符。

模板特例化
	模板特例化必须定义在原始模板所属的命名空间。和其他命名空间名字类似，只要我们在命名空间中声明
了特例化，就能在命名空间外都定义它了:
		//我们必须讲过模板特例化声明成std的成员
		namespace std{
			template<> struct hash<Sales_data>;
		}
		//在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了
		template <> struct std::hash<Sales_data>
		{
			size_t operator()(const Sales_data &s)const{
				return hash<string>()(s.book) ^
					   hash<unsigned>()(s.units_sold)^
					   hash<double>()(s.revenue);
			}
			//其他成员与之前的版本一致
		};

全局命名空间
	全局作用域中定义的名字(即在所有类、函数及命名空间之外定义的名字)也就是定义在全局命名空间中。
全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命
名空间中。
	作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字。下面的形式
		::member_name
表示全局命名空间中的一个成员。

嵌套的命名空间
	嵌套的命名空间是指定义在其他命名空间中的命名空间:
		namespace cplusplus_primer{
			//第一个嵌套的命名空间，定义了库的Query部分
			namespace QueryLib{
				class Query{/*...*/};
				Query operator&(const Query&,const Query&);
				//...
			}
			//第二个嵌套的命名空间：定义了库的Sales_data部分
			namespace Bookstore{
				class Quote{/*...*/};
				class Disc_quote : public Quote{/*...*/};
				//....
			}
		}
上面的代码将命名空间cplusplus_primer分割为两个嵌套的命名空间，分别是QueryLib和Bookstor。
	嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套的命名空间中的名
字遵循的规则与往常类似:内层命名空间声明的名字将隐藏外层命名空间声明的同名成员，在嵌套的命名空间
中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前添加限定符。例如，
在嵌套的命名空间QueryLib中声明的类名是
		cplusplus_primer::QueryLib::Query

内联命名空间
	C++11新标准引入了一种新的嵌套命名空间，称为内联命名空间。和普通的嵌套命名空间不同，内联
命名空间中的名字可以被外层命名空间直接使用，也就是说，我们无须在内联命名空间的名字前添加表示该
命名空间的前缀。通过外层命名空间的名字就可以直接访问它。
	定义内联命名空间的方式是在关键字namespace前添加关键字inline:
		inline namespace FifthEd{
			//该命名空间表示本书第5版的代码
		}
		namespace FifthEd{
			class Query_base{/*...*/};
			//其他与Query有关的声明
		}
关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline，也可
以不写。
	当应用程序在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。例如，我们可
以把本书当前版本的所有代码都放在一个内联命名空间中，而之前版本的代码都放在一个非内联命名空间中:
		namespace FourhtEd{
			class item_base{/*...*/};
			class Query_base{/*...*/};
			//本书第四版用到的其他代码
		}
命名空间cplusplus_primer将同时使用这两个命名空间。例如，假定每个命名空间都定义在同名的头文
件中，则我们可以把命名空间cplusplus_primer定义成如下形式:
		namespace cplusplus_primer{
			#include "FifthEd.h"
			#include "FourthEd.h"
		}
因为FifthEd是内联的，所以形如cplusplus_primer::的代码可以直接获得FifthEd的成员。如果我
们想使用早期版本的代码，则必须像其他嵌套的命名空间一样，加上完整的外层命名空间名字，比如
cplusplus_primer::FourthEd::Query_base。

未命名的命名空间
	未命名的命名空间是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间
中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。
	一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义在自
己的未命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名
空间中可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，
则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。
注意:
	和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同
的文件。
定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名字来限定他们；同样的，
我们也不能对未命名的命名空间的成员使用作用域运算符。
	未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定
义在头文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别:
		int i;		//i的全局声明
		namespace {
			int i;
		}
		//二义性：i的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中
		i = 100;
其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似，一个未命名的命名空
间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员可以通过外层命名空间的名字来访问:
		namespace local{
			namespace{
				int i;
			}
		}
		//正确:定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同
		local::i = 42;
未命名的命名空间取代文件中的静态声明
	在标准C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件
有效。在文件中进行静态声明的做法是从C语言继承而来的。在C语言中，声明为static的全局实体在
其所在的文件外不可见。
	在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。

18.2.2	使用命名空间成员
	像namespace_name::member_name这样使用命名空间的成员显然非常频繁，特别是当命名空
间的名字很长时尤其如此。幸运的是，我们可以通过一些其他更简单的方法使用命名空间的成员。之前的
程序已经使用过其中一种方法，即using声明。本节还将介绍另外几种方法，如命名空间的别名以及using
指示等。

命名空间的别名
	命名空间的别名使得我们可以为命名空间的名字设定一个短得多的同义词。例如，一个很长的命名
空间的名字形如:
		namespace cplusplus_primer{/*...*/};
我们可以为其设定一个短的多的同义词:
		namespace primer = cplusplus_primer;
命名空间的别名声明以关键字namespace开始，后面是别名所用的名字、=符号、命名空间原来的名字
以及一个分号。不能在命名空间还没有定义前就声明别名，否则将产生错误。
	命名空间的别名也可以指向一个嵌套的命名空间:
		namespace Qlib = cplusplus_primer::QueryLib;
		Qlib::Query q;
注意:
	一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。

using声明:扼要概述
	一条using声明语句一次只引入命名空间的一个成员，它使得我们可以清楚地知道程序中所用的到底
是哪个名字。using声明引入的名字遵循与过去一样的作用域规则：它的有效范围从using声明的地方开始，
一直到using声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。未加限定的名字
只能在using声明所在的作用域以及其内层作用域中使用。在有效作用域结束后，我们就必须使用完整的经
过限定的名字了。
	一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类
的作用域中，这样的声明语句只能指向基类成员。

using指示
	using指示和using声明类似的地方是，我们可以使用命名空间名字的简写形式：和using声明不同
的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。
	using指示以关键字using开始，后面是关键字namespace以及命名空间的名字。如果这里所用的
名字不是一个已经定义好的命名空间的名字，则程序将发生错误。using指示可以出现在全局作用域、局部
作用域和命名空间作用域中，但是不能出现在类的作用域中。using指示使得某个特定命名空间中所有的名
字都可见，这样我们就无须再为他们添加任何前缀限定符了。简写的名字从using指示开始，一直到using
指示所在的作用英语结束都能使用。
注意:
	如果我们提供了一个对std等命名空间的using指示而未做任何特殊控制的话，将重新引入由于使用
了多个库而造成的名字冲突问题。

using指示与作用域
	using指示引入的名字的作用域远比using声明引入的名字的作用域复杂。如我们所知，using声明
的名字的作用域与using声明语句本身的作用域一致，从效果上看就好像using声明语句为命名空间的成员
在当前作用域内创建了一个别名一样。
	using指示做的绝非声明别名这么简单，相反，它具有将命名空间成员提升到包含命名空间本身和
using指示的最近的作用域的能力。
	using声明和using指示在作用域上的区别直接决定了它们的工作方式的不同。对于using声明来说，
我们只是简单地令名字在局部作用域内有效。相反，using指示是令整个命名空间的所有内容变的有效。通
常情况下，命名空间中会含有一些不能出现在局部作用域中的定义，因此，using指示一般被看作是出现
在最近的外层作用域中。
	在最简单的情况下，假定我们有一个命名空间A和一个函数f，它们都定义在全局作用域中，如果f含有
一个对A的using指示，则在f看来，A中的名字仿佛是出现在全局作用域中f之前的位置一样:
		//命名空间A和函数f定义在全局作用域中
		namespace A{
			int i,j;
		}
		void f(){
			using namespace A;		//把A的名字注入到全局作用域中
			cout << i * j<<endl;	//使用命名空间A中的i和j
			//....
		}

using 指示示例
	让我们看一个简单的示例:
		namespace blip{
			int i = 16,j = 15,k = 23;
			//其他声明
		}
		int j = 0;		//正确:blip的j隐藏在命名空间中
		void manip(){
			//using指示，blip中的名字被"添加到"全局作用域中
			using namespace blip;	//如果使用了j，则将在::j和blip::j之间产生冲突
			++i;		//将blip::i设定为17
			++j;		//二义性错误：是全局的j还是blip::j?
			++::j;		//正确：将全局的j设定为16
			++blip::j;	//正确:将blip::j设定为16
			int k = 97;	//当前局部的k隐藏了blip::k
			++k;		//将当前局部的k设定为98
		}
manip的using指示使得程序可以直接访问blip的所有名字，也就是说，manip的代码可以使用blip
中名字的简写形式。
	blip的成员看起来好像是定义在blip和manip所在的作用域一样。假定manip定义在全局作用域
中，则blip的成员也好像是定义在全局作用域中一样。当命名空间被注入到它的外层作用域之后，很有可
能该命名空间中定义的名字会与其外层作用域中的成员冲突。例如在manip中，blip的成员j就与全局
作用域中的j产生了冲突。这种冲突是允许存在的，但是要想使用冲突的名字，我们就必须明确指出名字的
版本，manip中所有未加限定的j都会产生二义性错误。
	为了使用像j这样的名字，我们必须使用作用域运算符来明确指出所需的版本。我们使用::j来表示定
义在全局作用域中的j，而使用blip::j来表示定义在blip中的j。
	因为manip的作用域和命名空间的作用域不同，所以manip内部的声明可以隐藏命名空间中的某些成
员的名字。例如，局部变量k隐藏了命名空间的成员blip::k。在manip内使用k不存在二义性。它指的就是
局部变量k。
注意:
	这里想要说明的就是，如果你的命名空间是定义在全局的话，那么你的命名空间可能会与全局变量中
的变量冲突（在使用过程中），如果你的命名空间的作用域和使用该命名空间的作用域不同的话，那么使用
同名的变量的话，会被隐藏掉。

头文件与using声明或指示
	头文件如果在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件
的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件
最多只能在它的函数或命名空间内使用using指示或using声明。

提示：避免using指示
	using指示一次性注入某个命名空间的所有名字，这种用法看似简单实则充满了风险：只用一条语句
就突然将命名空间中所有成员的名字变的可见了。如果应用程序使用了多个不同的库，而这些库中的名字通
过using指示变的可见，则全局命名空间污染的问题将重新出现。（注意是全局命名空间）。
	而且，当引入库的新版本后，正在工作的程序可能会编译失败。如果新版本引入了一个与应用程序正
在使用的名字冲突的名字，就会出现这个问题。
	另外一个风险是由using指示引发的二义性错误只有在使用了冲突名字的地方才被发现。这种延后的
检测意味着可能在特定库引入很久之后才爆发冲突。直到程序开始使用该库的新部分后，之前一直未被检测
的错误才会出现。
	相比于使用using指示，在程序中对命名空间的每个成员分别使用using声明效果更好。这么做就可
以减少注入到命名空间中的名字数量。using声明引起的二义性问题在声明处就能发现，无须等到使用名字
的地方，这显然对检测并修改错误大有益处。
注意:
	using指示也并非一无是处，例如在命名空间本身的实现文件中就可以使用using指示。
小结一下:
	using声明的作用域和using指示的作用域是不一样的。首先，using声明的作用域是从using声明开始
的地方开始，一直到using所在的作用域结束为止。此过程中，外层作用域的同名实体将被隐蔽。未加限定
的名字只能在using声明所在的作用域以及其内层作用域中使用。
	但using指示的作用域是：根据你的namespace空间定义的位置来使用的。当你的位置是全局变量
的话，那么你使用指示的时候，就是代表的使用的全局的。所以在全局范围内如果有一个相同的变量名就会
产生二义性。当你使用的变量和不在全局变量中的变量的时候，就以该变量所在的作用域的变量为主，也就
是不同作用域的话，全局变量被屏蔽了。

18.2.3	类、命名空间与作用域
	对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个层作用域。外层作用域也
可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止。只有位于开放的块中且在使
用点之前声明的名字才被考虑:
		namespace A{
			int i;
			namespace B{
				int i;	//在B中隐藏了A::i
				int j;
				int f1(){
					int j;	//j是f1的局部变量，隐藏了A::B::j
					return j;
				}
			}//命名空间B结束，此后B中定义的名字不再可见
			int f2(){
				return j;		//错误:j没有被定义
			}
			int j = i;	//用A::i进行初始化
		}
对于位于命名空间中的类来说，常规的查找规则仍然适用:当成员函数使用某个名字时，首先在该成员中进行
查找(包括基类)，接着在外层作用域中查找，这时一个或几个外层作用域可能就是命名空间:
		namespace A{
			int i;
			int k;
			class C1{
			public:
				C1(): i(0),j(0){}		//正确:初始化C1::i和C1::j
				int f1(){return k;}		//返回A::k
				int f2(){return h;}		//错误:h未定义
				int f3();
			private:
				int i;		//在C1中隐藏了A::i
				int j;
			};
			int h = i;

		}
		//成员f3定义在C1和命名空间A的外部
		int A::C1::f3(){return h;}	//正确:返回A::h
除了类内部出现的成员函数定义外，总是向上查找作用域，名字必须先声明后使用，因此f2的return语句
无法通过编译。该语句试图使用命名空间A的名字h，但此时h尚未定义。如果h在A中定义的位置位于C1的
定义之前，则上述语句将合法。类似的，因为f3的定义位于A::h之后，所以f3对于h的使用是合法的。
注意:
	可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反的次序指出被查找的作用域。
限定符A::C1::f3指出了查找类作用域和命名空间作用域的相反次序。首选查找函数f3的作用域，然后
查找外层类C1的作用域，最后检查命名空间A的作用域以及包含着f3定义的作用域。

实参相关的查找与类类型形参
	考虑下面这个简单的程序:
		std::string s;
		std::cin >> s;
如我们所知，该调用等价于:
		operator>>(std::cin,s);
operator>>函数定义在标准库string中，string又定义在命名空间std中。但是我们不用std::限
定符和using声明就可以调用operator>>。
	对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输出运算符。这
个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命
名空间。这一例外对于传递类的引用或指针的调用同样有效。
	在此例中，当编译器发现对operator>>的调用时，首先在当前作用域中寻找合适的函数，接着查
找输出语句的外层作用域。随后，因为>>表达式的形参是类类型的，所以编译器还会查找cin和s的类所
属的命名空间。也就是说，对于这个调用来说，编译器会查找定义了istream和string的命名空间std。
当在std查找时，编译器还找到了string的输出运算符函数。
	查找规则的这个例外允许概念上作为类接口一部分的非成员函数无须单独的using声明就能被程序
使用。假如该例外不存在，则我们将不得不为输出运算符专门提供一个using声明:
		using std::operator>>;	//要想用cin>>s就必须有using声明
或者使用函数调用的形式把命名空间的信息包含进来:
		std::operator>>(std::cin,s);	//正确:显示使用std::>>
在没有使用运算符语法的错误下，上述两种声明都显得比较笨拙且无形中增加了使用IO标准库的难度。

查找与std::move和std::forward
	很多甚至是绝大多数C++程序员从来都没有考虑过与实参相关的查找问题。通常情况下，如果在应
用程序中定义了一个标准库中已有的名字，则将出现以下两种情况中的一种:要么根据一般的重载规则确
定某次调用应该执行函数的哪个版本；要么应用程序根本就不会执行函数的标准库版本。
	接下来考虑标准库move和forward函数。这两个都是模板函数，在标准库的定义中它们都接受
一个右值引用的函数形参。如我们所知，在函数模板中，右值引用形参可以匹配任何类型。如果我们的
应用程序也定义了一个接受单一形参的move函数，则不管该形参是什么类型，应用程序的move函数都
将与标准库的版本冲突。forward函数也是如此。
	因此，move(以及forward)的名字冲突要比其他标准库函数的冲突频繁的多。而且，因为move
和forward执行的是非常特殊的类型操作，所以应用程序专门修改函数原有行为的频率非常小。
	对于move和forward来说，冲突很多但是大多数都是无意的，这一特点解释了为什么我们建议
最好使用他们的带限定语的完整版本的原因。通过书写std::move而非move，我们就能明确地知道
想要使用的是函数的标准库版本。

友元声明与实参相关的查找
	回顾我们曾经讨论过得，当类声明了一个友元时，该友元声明并没有使得友元本身可见。然而，
一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的
成员。这条规则与实参相关的查找规则结合在一起将产生意向不到的效果:
		namespace A{
			class C{
				//两个友元，在友元声明之外没有其他声明
				//这些函数隐式地成为命名空间A的成员
				friend void f2();		//除非另有声明，否则不会被找到
				friend void f(const C&);//根据实参相关的查找规则可以被找到
			};
		}
此时，f和f2都是命名空间A的成员。即使f不存在其他声明，我们也能通过实参相关的查找规则调用f:
		int main()
		{
			A::C cobj;
			f(cobj);		//正确:通过在A::C中友元声明找到A::f
			f2();	//错误:A::f2没有被声明
		}
因为f接受一个类类型的实参，而且f在c所属的命名空间进行了隐式的声明，所以f能被找到。相反，因为f2
没有形参，所以它无法被找到。

18.2.4	重载与命名空间
	命名空间对函数的匹配过程有两方面的影响。其中一个影响非常明显：using声明或using指示能将某
些函数添加到候选函数集。另外一个影响则比较微妙。

与实参相关的查找与重载
	在上一节中我们了解到，对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进
行。这条规则对于我们如何确定候选函数集同样也有影响。我们将在每个实参类(以及实参类的基类)所属的命
名空间中搜寻候选函数。在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中，即使其中
某些函数在调用语句处不可见也是如此:
		namespace NS{
			class Quote{/*...*/};
			void display(const Quote &){/*....*/}
		}
		//Bulk_item的基类声明在命名空间NS中
		class Bulk_item : public NS::Quote{/*...*/};
		int main(){
			Bulk_item bookl;
			display(bookl);
			return 0;
		}
我们传递给display的实参属于类类型Bulk_item，因此该调用语句的候选函数不仅应该在调用语句所在
的作用域中查找，而且也应该在BUlk_item及其基类Quote所属的命名空间中查找。命名空间NS中声明的
函数display(const Quote&)也将被添加到候选函数当中。

重载与using声明
	要想理解using声明与重载之间的交互关系，必须首先明确一条:using声明语句声明的是一个
名字，而非一个特定的函数:
		using NS::print(int);	//错误:不能指定形参列表
		using NS::print;		//正确:using声明只声明一个名字
当我们为函数书写using声明时，该函数所有版本都被引入到当前作用域中。一个using声明囊括了重载函
数的所有版本以确保不违反命名空间的接口。库的作者为某项任务提供了好几个不同的函数。允许用户选择
性地忽略重载函数中的一部分但不是全部有可能导致意想不到的程序行为。
	一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果using声明
出现在局部作用域中，则引入的名字将隐藏外层作用域中的相关声明。如果using声明所在的作用域中已经
有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误。除此之外，using声明将为
引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。

重载与using指示
	using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用
域的函数同名，则命名空间的函数将被添加到重载函数集合中:
		namespace libs_R_us{
			extern void print(int);
			extern void print(double);
		}
		//普通的声明
		void print(const std::string &);
		//这个using指示把名字添加到print调用的候选函数集
		using namespace libs_R_us;
		//print调用此时的候选函数包括
		//libs_R_us的print(int)
		//libs_R_us的print(double)
		//显示声明的print(const std::string &)
		void fooBar(int ival)
		{
			print("Value: ");		//调用全局函数print(const string &)
			print(ival);		//调用libs_R_us::print(int)
		}
与using声明不同的是，对于using指示来说，引入一个已有函数形参列表完全相同的函数并不会产生错误。
此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。

跨越多个using指示的重载
	如果存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分:
		namespace AW{
			int print(int);
		}
		namespace Primer{
			double print(double);
		}
		//using指示从不同的命名空间中创建了一个重载函数集合
		using namespace AW;
		using namespace Primer;
		long double print(long double);
		int main(){
			print(1);		//调用AW::print(int)
			print(3.1);		//调用Primer::print(double)
			return 0;
		}
在全局作用域中，函数print的重载集合包括print(int)、print(double)和print(long double)，
尽管他们的声明位于不同作用域中，但他们都属于main函数中print调用的候选函数集。

18.3	多重继承与虚继承
	多重继承是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。尽管概念
上非常简单，但是多个基类相互交织产生的细节可能会带来错综复杂的设计问题与实现问题。
	为了讨论有关多重继承的问题，我们将以动物园的层次关系作为教学实例。。动物园中的动物存在于不同
的抽象级别上。有个体的动物，如Ling-Ling、Mowggli和Balou等，它们以名字进行区分:每个动物属于一个
物种，例如Ling-Ling是一只大熊猫；物种又是科的成员，大熊猫是熊科的成员；每个科是动物界的成员，在
这个例子中动物界是指一个动物园中所有动物的总和。
	我们将定义一个抽象类ZooAnimal，用它来保存动物园中动物共有信息并提供公共接口。类Bear将存放
Bear科特有的信息，依次类推。除了类ZooAnimal之外，我们应用程序还包含其他一些辅助类，这些类负责
封装不同的抽象，如濒临灭绝的动物。以类Panda的实现为例，Panda是由Bear和Endangered共同派生的。

18.3.1	多重继承
	在派生类的派生列表中可以包含多个基类:
		class Bear : public ZooAnimal{
		class Panda : public Bear,public Endangered{/*...*/};
每个基类包含一个可选的访问说明符。一如往常，如果访问说明符被忽略掉了，则关键字class对应的默认访问
说明符是private，关键字struct对应的是public。
	和只有一个基类的继承一样，多重继承的派生列表也只能包已经被定义过的类，而且这些类不能是final
的。对于派生类能够继承的基类个数，C++没有进行特殊规定:但是在某个给定的派生列表中，同一个基类只能
出现一次。

多重继承的派生类从每个基类中继承状态
	在多重继承关系中，派生类的对象包含有每个基类的子对象。如图18.2所示，在Panda对象中含有一个
Bear部分(其中又含有一个ZooAnimal部分)、一个Endangered部分以及在Panda中声明的非静态数据成员。
				|----------			--------ZooAnimal成员
				|					
				|					--------Bear成员
		Panda对象|					
				|					--------Endangered成员
				|					
				|___________		--------Panda成员

派生类构造函数初始化所有基类
	构造一个派生类的对象将同时构造并初始化它的所有基类子对象。与从一个基类进行的派生一样，多重继
承的派生类的构造函数初始值也只能初始化它的直接基类:
		//显示地初始化所有基类
		Panda::Panda(std::string name,bool onExhibit):
						Bear(name,onExhitbit,"Panda"),
						Endangered(Endangered::critical){}
		//隐式地使用Bear的默认构造函数初始化Bear子对象
		Panda::Panda():Endangered(Endangered::critical){}
派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现
顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。一个Panda对象按照如下次序进行初始化:
		>>>	ZooAnimal是整个继承体系的最终基类，Bear是Panda的直接基类。ZooAnimal
是Bear的基类，所以首先初始化ZooAnimal。
		>>>	接下来初始化Panda的第一个直接基类Bear
		>>>	然后初始化Panda的第二个直接基类Endangered。
		>>>	最后初始化Panda。

继承的构造函数与多重继承
	在C++11新标准中，允许派生类从他的一个或几个基类中继承构造函数。但是如果从多个基类中继承了
相同的构造函数(即形参列表完全相同)，则程序将产生错误:
		struct Base1{
			Base1() = default;
			Base1(const std::string &);
			Base1(std::shared_ptr<int>);
		};
		struct Base2{
			Base2() = default;
			Base2(const std::string &);
			Base2(int);
		};
		//错误:D1试图从两个基类中都继承D1::D1(const string &)
		struct D1 : public Base1,public Base2{
			using Base1::Base1;		//从Base1继承构造函数
			using Base2::Base2;		//从Base2继承构造函数
		};
如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本:
		struct D2 : public Base1,public Base2{
			using Base1::Base1;		//从Base1继承构造函数
			using Base2::Base2;		//从Base2继承构造函数
			//D2必须有自定义一个接受string的构造函数
			D2(const string &):Base1(s),Base2(s){}
			D2() = default;		//一旦D2定义了它自己的构造函数，则必须出现

析构函数与多重继承
	和往常一样，派生类的析构函数只负责派生类本身分配的资源，派生类的成员及基类都是自动销毁的。
合成的析构函数体为空。
	析构函数的调用顺序正好与构造函数相反，在我们的例子中，析构函数的调用顺序是~Panda、~Endangered、
~Bear和~ZooAnimal。

多重继承的派生类的拷贝与移动操作
	与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则
必须在完整的对象上执行拷贝、移动或赋值操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，
才会自动对其基类部分执行这些操作。在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完
成构造、赋值或销毁工作。
	例如，假设Panda使用了合成版本的成员ling_ling的初始化过程:
		Panda ying_yang("ying_yang");
		Panda ling_ling = ying_yang;	//使用拷贝构造函数
将调用Bear的拷贝构造函数，后者又在执行自己的拷贝任务之前先调用ZooAnimal的拷贝构造函数。一旦
ling_ling的Bear部分构造完成，接着就会调用Endangered的拷贝构造函数来创建对象相应的部分。
最后，执行Panda的拷贝构造函数。合成的移动构造函数的工作机理与之类似。
	合成的拷贝赋值运算符的行为与拷贝构造函数很相似，它首先赋值Bear部分(并且通过Bear赋值ZooAnimal
部分)，然后赋值Endangered部分，最后是Panda部分，移动赋值运算符的工作机理与之类似。

18.3.2	类型转换与多个基类
	在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针或引用。多个基
类的情况与之类似。我们可以令某个可访问基类的指针或引用直接指向一个可派生类对象。例如，一个ZooAnimal
，Bear或Endangered类型的指针或引用可以绑定到Panda对象上:
		//接受Panda的基类引用的一系列操作
		void print(const Bear &);
		void highlight(const Endangered&);
		ostream &operator<<(ostream &,const ZooAnimal &);
		Panda ying_yang("ying_yang");
		print(ying_yang);	//把一个Panda对象传递给一个Bear的引用
		highlight(ying_yang);	//把一个Panda对象传递给一个Endangered的引用
		cout << ying_yang<<endl;//把一个Panda对象传递给一个ZooAnimal的引用
编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好。例如，
如果存在如下所示的print重载形式:
		void print(const Bear&);
		void print(const Endangered&);
则通过Panda对象对不带前缀限定符的print函数进行调用将产生编译错误:
		Panda ying_yang("ying_yang");
		print(ying_yang);	//二义性错误

基于指针类型或引用类型的查找
	与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些成员。如果我们使用
一个ZooAnimal指针，则只有定义在ZooAnimal中的操作是可以使用的。Panda接口中的Bear、Panda和
Endangered特有的部分都不可见。类似的，一个Bear类型的指针或引用只能访问Bear及ZooAnimal的成
员，一个Endangered的指针或引用只能访问Endangered的成员。
	举个例子，已知我们的类已经定义了表18.1列出的虚函数，考虑下面的函数调用:
		Bear *pb = new Panda("ying_yang");
		pb->print();		//正确:Panda::print()
		pb->cuddle();		//错误:不属于Bear的接口
		pb->highlight();	//错误:不属于Bear的接口
		delete pb;			//正确:Panda::~Panda()
当我们通过Endangered的指针或引用访问一个Panda对象时，Panda接口中Panda特有的部分以及属于Bear
的部分是不可见的。
		Endangered *pe = new Panda("ying_yang");
		pe->print();		//正确:Panda::print()
		pe->toes();			//错误:不属于Endangered的接口
		pe->cuddle();		//错误:不属于Endangered的接口
		pe->highlight();	//正确:Panda::highlight()
		delete pe;			//正确:Panda::~Panda()

		表18.1	:在ZooAnimal/Endangered中定义的虚函数

		函数						含有自定义版本的类
	　  　print				ZooAnimal::ZooAnimal
							Bear::Bear
							Endangered::Endangered
							Panda::Panda

		highlight			Endangered::Endangered
							Panda::Panda

		toes				Bear::Bear
							Panda::Panda

		cuddle				Panda::Panda

		析构函数				ZooAnimal::ZooAnimal
							Endangered::Endangered

18.3.3	多重继承下的类作用域
	在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中。查找过程沿着继承体系
自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。
	在多重继承的情况下，相同的查找过在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该
名字的使用将具有二义性。
	在我们的例子中，如果我们通过Panda的对象、指针或引用使用了某个名字，则程序会并行地在Endangered
和Bear/ZooAnimal这两棵子树中查找该名字。如果名字在超过一棵树中被找到，则该名字的使用具有二义。
对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须
明确地指出它的版本。
注意:
	当一个类拥有多个基类时，有可能出现在派生类从两个或更多基类中继承了同名成员的情况。此时，不加前
缀限定符直接使用该名字将引发二义性。
	例如，如果ZooAnimal和Endangered都定义了名为max_weight的成员，并且Panda没有定义该
成员。则下面的调用是错误的:
		double d = ying_yang.max_weight();
Panda在派生的过程中拥有了两个名为max_weight的成员，这是完全合法的。派生仅仅是产生了潜在的二义
性。只要Panda对象不调用max_weight函数就能避免二义性错误。另外，如果每次调用max_weight时都指
出所调用的版本(ZooAnimal::max_weight或者Endangered::max_weight)，也不会发生
二义性。只有当要调用哪个函数含糊不清时程序才会出错。
	在上面的例子中，派生类继承的两个max_weight会产生二义性，这一点显而易见。一种更复杂的情
况是，有时即使派生类继承的两个函数形参列表不同也可能发生错误。此外，即使max_weight在一个类中是
私有的，而在另一个类中是公有的或受保护的同样也可能发生错误。最后一种情况，假如，max_weight定义
在Bear中而非ZooAnimal中，上面的程序仍然是错误的。
	和往常一样，先查找名字后进行类型检查。当编译器在两个作用域中同时发现了max_weight时，将直接
报告一个调用二义性错误。
	要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。李荣融入如，我们可以为Panda
定义一个max_weight函数从而解决二义性问题:
		double Panda::max_weight()const{
			return std::max(ZooAnimal::max_weight(),Endangered::max_weight());
		}

18.3.4	虚继承
	尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的
两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。
	举个例子，IO标准库的istream和ostream分别继承了一个共同的名为base_ios的抽象基类。该抽象基
类负责保存流的缓冲内容并管理流的条件状态。iostream是另外一个类，它从istream和ostream直接继承
而来，可以同时读写流的内容。因为istream和ostream都继承自base_ios，所以iostream继承了base_ios
两次，一次是通过istream，另一次是通过ostream。
	在默认情况下，派生类含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次。则派生
类中将包含该类的多个子对象。
	这种默认情况对某些形如iostream的类显然是行不通的。一个iostream对象肯定希望在同一个缓冲
区中进行读写操作，也会要求条件状态同时反映输入和输出操作的情况。假如在iostream对象中真的包含
了base_ios的两份拷贝，则上述的共享行为就无法实现了。
	在C++语言中我们通过虚继承的机制解决上述问题。虚继承的目的是令某个类做出声明，承诺愿意共享它
的基类。其中，共享的基类子对象称为虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派
生类中都只包含唯一一个共享的虚基类子对象。

另一个Panda类
	在过去，科学界对于大熊猫属于Raccoon科还是Bear科争论不休。为了如实地反映这种争论，我们可
以对Panda类进行修改，令其同时继承Bear和Raccoon。此时，为了避免赋予Panda两份ZooAnimal的子
对象，我们将Bear和Raccoon继承ZooAnimal的方式定义为虚继承。图18.3描述了新的继承体系:
					ZooAnimal
					/		\
		　　　　虚继承/		 \虚继承
				  /			  \
			    Bear		Raccoon			Endangered
				　\			   |				/
				  \			   |			   /
				   \	       |			  /
					\          |			 /
							Panda
观察这个新的继承体系我们将发现虚继承的一个不太直观的特征:必须在虚派生的真实需求出现前就已经
完成从虚派生的操作。例如在我们的类中，当我们定义Panda时才出现了对虚派生的需求。但是如果Bear
和Raccoon不是从ZooAnimal虚派生的到的。那么Panda的设计者就显得不太幸运了。
	在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，
使用虚继承的类层次是由一个人或一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基
类中某一个虚基类，况且新基类的开发者也无法改变已存在的类体系。
注意:
	虚基类只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。

使用虚基类
	我们指定虚基类的方式是在派生列表中添加关键字virtual:
		//关键字public和virtual的顺序随意
		class Raccoon : public virtual ZooAnimal{/(/*...*/};
		class Bear: virtual public ZooAnimal{/*...*/};
通过上面的代码我们将ZooAnimal定义为Raccoon和Bear的虚基类。
	virtual说明符表明一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能
够作为虚基类并没有特殊规定。
	如果某个类指定了虚基类，则该类的派生仍按常规方式进行:
		class Panda : public Bear,public Raccoon,public Endangered{};
Panda通过Raccoon和Bear继承了ZooAnimal，因为Raccoon和Bear继承ZooAnimal的方式都是
虚继承，所以在Panda中只有一个ZooAnimal基类部分。

支持向基类的常规类型转换
	不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。例如，下面这些从Panda
向基类的类型转换都是合法的:
		void dance(const Bear&);
		void rummage(const Raccoon&);
		ostream &operator<<(ostream &,const ZooAnimal &);
		Panda ying_yang;
		dance(ying_yang);		///正确:把一个Padna对象当成Bear传递
		rummage(ying_yang);		//正确:把一个Panda对象当成Raccoon传递
		cout<<ying_yang;		//正确:把一个Panda对象当成ZooAnimal传递

虚基类成员的可见性
	因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会
产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。
但是如果成员被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。
	例如，假定类B定义了一个名为x的成员，D1和D2都是从B虚函数继承得到的，D继承了D1和D2，则在
D的作用域中，x通过D的两个基类都是可见的。如果我们通过D的对象使用x，有三种可能性:
		>>>	如果在D1和D2中都没有x的定义，则x将被解析为B的成员，此时不存在二义性，一个D的对
象只含有x的一个实例。
		>>>	如果x是B的成员，同时是D1和D2中某一个的成员，则同样没有二义性，派生类的x比共享虚
基类B的x优先级更高。
		>>>	如果在D1和D2中都有x的定义，则直接访问x将产生二义性问题。
与非虚的多重继承体系一样，解决这种二义性做好的方法是在派生类中为成员自定义新的实例！！！
注意:
	如果基类A中，有一个函数f，那么派生类B中也有一个函数f但是行参不同，这个时候，你用B的对象调用
A中的f是不对的。这个时候，其实就像是B中的f把A中的f给覆盖了一样。但不是重载。

18.3.5	构造函数与虚继承
	在虚派生中，虚基类是由最底层的派生类初始化的，以我们的程序为例。当创建Panda对象时，由Panda
的构造函数独自控制ZooAnimal的初始化过程。
	为了理解这一规则，我们不妨假设当以普通规则处理初始化任务时会发生什么情况。在此例中，虚基类将
会在多条路径上被重复初始化。以ZooAnimal为例，如果应用普通规则，则Raccoon和Bear都会试图初始化
Panda对象的ZooAnimal部分。
	当然，继承体系中的每个类都可能在某个时刻成为"最底层的派生类"。只要我们能创建虚基类的派生对象，
该派生类的构造函数就必须初始化它的虚基类。例如，在我们的继承体系中，当创建一个Bear(或Raccoon)的
对象时，它已经位于派生的最底层，因此Bear(或Raccoon)的构造函数将直接初始化其ZooAnimal基类部分:
		Bear::Bear(std::stringg name,bool onExhibit):ZooAnimal(name,onExhibit,"Bear"){}
		Raccoon::Raccoon(std::string name,bool onExhibit):ZooAnimal(name,onExhibit,"Raccoon"){}
而当创建一个Panda对象时，Panda位于派生的最底层并由它负责初始化共享的ZooAnimal基类部分。即使
ZooAnimal不是Panda的直接基类，Panda的构造函数也可以初始化ZooAnimal:
		Panda::Panda(std::string name,bool onExhibit):
						ZooAnimal(name,onExhibit,"Panda"),
						Bear(name,onExhibit),
						Raccoon(name,onExhibit),
						Endangered(Endangered::critical),
						sleeping_flag(false){}

虚继承的对象的构造方式
	含有虚基类的镀锡的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值
初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化:
	例如，当我们创建一个Panda对象时:
		>>>	首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分。
		>>>	接下来构造Bear部分。
		>>>	然后构造Raccoon部分
		>>>	然后构造第三个直接基类Endangered
		>>>	最后构造Panda部分。
如果Panda没有显示地初始化ZooAnimal基类，则ZooAnimal的默认构函数将被调用。如果ZooAnimal没有
默认构造函数，则代码将发生错误。
注意:
	虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。

构造函数与析构函数的次序
	一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。
例如，在下面这个稍显杂乱的TeddyBear派生类关系中有两个虚基类：ToyAnimal是直接虚基类，ZooAnimal
是Bear的虚基类:
		class Character{/*...*/};
		class BookCharacter : public Character {/*...*/};
		class ToyAnimal {/*....*/};
		class TeddyBear : public BookCharacter,
						  public Bear,
						  public virtual ToyAnimal{/*..*/};
编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，
然后按照声明的顺序逐一构造其他非虚基类。因此，要想创建一个TeddyBear对象，需要按照如下次序
调用这些构造函数:
		ZooAnimal();		//Bear的虚基类
		ToyAnimal();		//直接虚基类
		Character();		//BookCharacter
		BookCharacter();	//第一个直接非虚基类
		Bear();				//第二个直接非虚基类
		TeddyBear();		//最低层的派生类
合成的拷贝和移动运算符构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。
和往常一样，对象的值销毁顺序与构造顺序正好相反，首先销毁TeddyBear部分，最后销毁ZooAnimal部分。
