							第十三章		拷贝控制
内容
--------------------------
	13.1	拷贝、赋值与销毁
	13.2	拷贝控制和资源管理
	13.3	交换操作
	13.4	拷贝控制示例
	13.5	动态内存管理类
--------------------------
	如我们在第7章所见，每个类都定义了一个新类型和在此类型对象上可执行的操作。在本章中，我们还将学到，类可以
定义构造函数，用来控制在创建此类型对象时做什么。在本章中，我们还讲学习类如何控制该类型对象拷贝、赋值、移动或
销毁时做什么。类通过一些特殊的成员函数控制这些操作，包括，拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋
值运算符以及析构函数。
	当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值或销毁时做什么。一个类通过定义五种
特殊的成员函数来控制这些操作，包括:拷贝构造函数(copy construtor)、移动赋值运算符(move-assignment 
operator)、拷贝赋值运算符(copy-assignment operator)、移动构造函数(move constructor)和析构函数(destructor)。拷贝和移动构造函数定义了当同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义
了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控
制操作(copy control)。
	如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺少的操作。因此，很多类会忽略这些拷贝控制
操作。但是对一些类说，依赖这些操作的默认定义会导致灾难。通常，实现拷贝控制操作最困难的地方是首先认知到什么时
候需要定义这些操作。

注意:
	在定义任何C++类时，拷贝控制操作都是必要部分。对于初学C++的程序员来说，必须定义定义对象拷贝、移动、赋值
或销毁时做什么，这常常令他们感到困惑。这种困扰很复杂，因为如果我们不显示定义这些操作，编译器也会为我们定义，
但编译器定义的版本行为可能并非我们所想。

13.1	拷贝、赋值与销毁
	我们将以最基本的操作－－拷贝构造函数、拷贝赋值运算符和析构函数作为开始。我们将在13.6节中介绍移动操作。

13.1.1	拷贝构造函数
	如果一个构造函数的第一个参数是自身类类型的引用，其任何额外参数都有默认值，则此构造函数是拷贝构造函数。
		class Foo{
		public:
			Foo();		//默认构造函数
			Foo(const Foo&);	//拷贝构造函数
			// ...
		};
拷贝构造函数的第一个参数必须是一个引用类型，原因我们稍后解释。虽然我们可以定义一个接受非const引用的拷贝构
造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常
不应该是explicit的。

合成拷贝构造函数
	如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成模拟人构造函数不同，即使我们定
义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。如我们将在13.1.6节中所见，对某些类来说，合成拷贝
构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的
对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。
	每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。
虽然我们不能直接拷贝一个数组，但合成构造拷贝函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则
使用元素的拷贝构造函数来进行拷贝。
	作为一个例子，我们的Sales_data类的合成拷贝构造函数等价于:
		class Sales_data{
		public:
			//其他成员和构造函数的定义，如前
			//与合成的拷贝构造函数等价的拷贝构造函数的声明
			Sales_data(const Sales_data&);
		private:
			std::string bookNo;
			int units_sold = 0;
			double revenue = 0.0;
		};
		//与Sales_data的合成的拷贝构造函数等价
		Sales_data::Sales_data(const Sales_data &orig):
			bookNo(orig.bookNo),
			units(orig.units_sold),
			revenue(orig.revenue)
			{}

拷贝初始化
	现在，我们可以完全理解直接初始化和拷贝初始化之间的差异了:
		string dots(10,'.');			//直接初始化
		string s(dots);					//直接初始化
		string s2 = s;					//拷贝初始化
		string null_book = "9-99-999";	//拷贝初始化
		string nines = string(100,'9);	//拷贝初始化
当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用
拷贝初始化(copy initialization)时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还要
进行类型转换。
	拷贝初始化通常使用拷贝构造函数来完成。但是，如我们将在13.6.2节所见，如果一个类有一个移动构造函数，则拷贝
初始化有时会使用移动构造函数而非拷贝构造函数来完成。但现在，我们只需要了解拷贝初始化何时发生，以及拷贝初始化是
依靠拷贝构造函数或移动构造函数来完成的就可以了。
	拷贝初始化不仅在我们用=定义变量时会发生，在下列的情况下也会发生:
		>>>	直接初始化时，实参是一个对象的时候！
		>>>	将一个对象作为实参传递给一个非引用类型的形参
		>>>	从一个返回类型为非引用类型的函数返回一个对象
		>>>	用花括号列表初始化一个数组中的元素或一个聚合类中的成员
某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其insert或push成员时，容
器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。

参数和返回值
	在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会
被用来初始化调用方的的结果。拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数被用来初始
化非引用类类型参数，这一特性解释了为什么拷贝构造函数在自己的参数必须是引用类型。如果其参数不是引用类型，则调用永
远也不会成功－－为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限
循环。

拷贝初始化的限制
	如前所述，如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化还是直接
初始化就不是无关紧要的了:
		vector<int>	v1(10);			//正确，直接初始化
		vector<int>	v2 = 10;		//错误:接受大小参数的构造函数是explicit的
		void f(vector<int>);	//f的参数进行拷贝初始化
		f(10);			//错误:不能用一个explicit的构造函数拷贝一个实参
		f(vector<int>(10);	//正确：从一个int直接构造一个临时vector
小提示:
		explicit　表示构造函数是不能够隐式转换的。必须是同类型的对象！
直接初始化v1是合法的，但看起来与之等价的拷贝初始化v2则是错误的，因为vector的接受单一大小参数的构造函数是explicit
的。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个explicit构造函数。如果我们希望使用
一个explicit构造函数，就必须显示的使用，像此代码中最后一行那样。

编译器可以绕过拷贝构造函数
	子啊拷贝初始化过程中，编译器可以(但不是必须)跳过拷贝/移动构造函数，直接创建对象。即，编译器被允许将下面的
代码:
		string null_book = "9-999-9999-9";	//拷贝初始化
改写为
		string null_book("9-999-9999-9");	//编译器略过了拷贝构造函数
但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的(例如，不能是
private　的)。

13.1.2	拷贝赋值运算符
	与类控制其对象如何初始化一样，类也可以控制其对象如何赋值:
		Sales_data trans,accum;
		trans = accum;		//使用Sales_data的拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

重载赋值运算符
	在介绍合成赋值运算符之前，我们需要了解一点有关重载运算符的知识，详细内容将在第14章进行介绍。重载运算符本质
上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator=的函
数。类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。
	重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个
成员函数，其左侧运算对象就绑定到隐式的this参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显示参数
传递。拷贝赋值运算符接受一个其所在类相同类型的参数:
		class Foo{
		public:
			Foo &operator=(const Foo&);	//赋值运算符
			//....
		};
为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值的注意的是，标准库通常要求
保持在容器中类型要具有赋值运算符，且其返回值是左侧运算对象的引用。
注意:
	赋值运算符通常应该返回一个指向其左侧运算对象的引用。

合成拷贝赋值运算符
	与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。类似
拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右
侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数
组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。
	作为一个例子，下面的代码等价于Sales_data的合成拷贝赋值运算符:
		//等价于合成拷贝赋值运算符
		Sales_data &Sales_data::operator=(const Sales_data &rhs)
		{
			bookNo = rhs.bookNo;
			units_sold = rhs.units_sold;
			revenue = rhs.revenue;
			return *this;
		}

13.1.3	析构函数
	析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数
释放对象使用的资源，并销毁对象的非static数据成员。析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返
回值，也不接受参数:
		class Foo{
		public:
			~Foo();	//析构函数
			//....
		};
由于析构函数不接受参数，因此它不能被重载，对一个给定类，只会有一个析构函数。

析构函数完成什么工作
	如果构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化
是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成
员按初始化顺序的逆序销毁。在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何首尾工作。通常，析构
函数释放对象在生存期分配的所有资源。在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构
部分是隐式的。成员销毁时发生什么完全依赖于成员类型。销毁类类型的成员需要成员执行自己的析构函数。内置类型没有析构函
数，因此销毁内置类型成员什么也不需要做。
注意:
	隐式销毁一个内置指针类型的成员不会delete它所指向的对象。
与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，指针成员在析构阶段会被自动销毁。

什么时候会调用析构函数
	无论何时一个对象被销毁，就会自动调用其析构函数:
		>>>变量在离开其作用域时被销毁
		>>>当一个对象被销毁时，其成员被销毁
		>>>容器(无论是标准库容器还是数组)被销毁时，其元素被销毁
		>>>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
		>>>对于临时对象，当创建它的完整表达式结束时被销毁
由于析构函数自动运行，我们的程序可以按需要分配资源，而(通常)无须担心何时释放这些资源。
	例如，下面代码片段定义了四个Sales_data对象:
		{	//新作用域
			//p和p2指向动态分配的对象
			Sales_data *p = new Sales_data;	//p是一个内置指针
			auto p2 = make_shared<Sales_data>();	//p2是一个shared_ptr
			Sales_data item(*p);	//拷贝构造函数将*p拷贝到item中（见前面使用拷贝构造函数的特例)
			vector<Sales_data> vec;	//局部对象
			vec.push_back(*p2);		//拷贝p2指向的对象
			delete p;		//对p指向的对象执行析构函数
		};	//退出局部作用域；对item、p2和vec调用析构函数
			//销毁p2会递减其引用计数，如果引用计数为0，对象被释放
			//销毁vec会销毁它的元素
每个Sales_data对象都包含一个string成员，它分配动态内存保存bookNo成员中的字符。但是，我们的代码唯一需要
直接管理的内存就是我们直接分配的Sales_data对象。我们的代码只需要释放绑定到p的动态分配对象(动态分配的内存，删
除指向其内存的指针的时候，就会将那个内存空间删除)。
	其他Sales_data对象会在离开作用域时被自动销毁。当程序块结束时，vec、p2和item都离开了其作用域，意味着
在这些对象上分别会执行vector、shared_ptr和Sales_data的析构函数。vector的析构函数会销毁我们添加到vec的
元素。shared_ptr的析构函数会递减p2指向的对象的引用计数。在本例中，引用计数会变为0。因此shared_ptr的析构函
数会delete p2分配的Sales_data对象。在所有情况下，Sales_data的析构函数都会隐式地销毁bookNo成员。销毁
bookNo会调用string的析构函数，它会释放用来保存ISBN的内存。
注意:
	当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

合成析构函数
	当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。类似拷贝构造函数和拷贝赋值运算符，对于某些类，
合成析构函数被用来组织该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。例如，下面的代码片段等价于
Sales_data的合成析构函数:
		class Sales_data{
		public:
			//成员会被自动销毁，除此之外不需要做其他事情
			~Sales_data(){}
			//其他成员的定义，如前
		};
在(空)析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被调用，它将释放bookNo成员所用的内存。
	认识到析构函数体本身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构截断中被销毁的。在整个对象
销毁过程中，析构函数是作为成员的销毁步骤之外的另一部分而进行的。

注意:
	成员的初始化是在函数体执行之前完成的；成员的销毁是在析构函数函数体之后完成的。析构函数函数体不会执行销毁操作。

13.1.4	三/五法则
	如前所述，有三个基本操作可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个
类还可以定义一个移动构造函数和一个移动赋值运算符，我们将在13.6节中介绍这些内容。
	C++语言并不要求我们定义所有这些操作，可以只定义其中一个或两个，而不必定义所有。但是，这些操作通常应该被看作
一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。

需要析构函数的类也需要拷贝和赋值操作
	当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，
对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需
要一个拷贝构造函数和一个拷贝赋值运算符。
	我们在练习过程中使用过HasPtr类是一个好例子。这个类在构造函数中分配动态内存。合成析构函数不会delete一个指针
数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。
		class HasPtr{
		public:
			HasPtr(const std::string &s = std::string()):ps(new std::string(s)),i(0){}
		private:
			std::string *ps;
			int i;
		};
注意:
	这里说一下，为什么析构函数不会delete一个指针数据成员！其实不是不会删除指针，是不会删除指针所指向的对象！
要想删除这个所指向的对象(这个对象必须是动态分配的)，就必须显示使用delete才可以！

应该怎么做可能还有点不清晰，但基本原则告诉我们，HasPtr也需要一个拷贝构造函数和一个拷贝赋值运算符。如果我们为
HasPtr定义一个析构函数，但使用合成版本的拷贝构造函数和拷贝赋值运算符，考虑会发生什么:
		class HasPtr{
		public:
			HasPtr(const std::string &s = std::string()) : ps(new std::string(s),i(0){}
			~HasPtr(){delete ps;}
			//错误：HasPtr需要一个拷贝构造函数和一个拷贝赋值运算符
			//其他成员的定义，如前
		};
在这个版本的类定义中，构造函数中分配的内存将在HasPtr对象销毁时被释放。但不幸的是，我们引入一个严重的错误！
这个版本的类使用了合成的拷贝构造函数和拷贝赋值运算符，这些函数简单拷贝指针成员，这意味着有多个HasPtr对象可
能指向相同的内存:
		HasPtr f(HasPtr hp)	//HasPtr是传值参数，所以将被拷贝
		{
			HasPtr ret = hp;		//拷贝给定的HasPtr
			//处理ret
			return ret;
		}
当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构函数会delete　ret和hp中的指针成员。
但这两个对象包含相同的指针值。此代码会导致此指针被delete两次，这显然是一个错误。将要发生什么是未定义的。
注意:
	这里解释下为什么会指向相同的内存区间，主要就是因为ps是一个指针，因为指针在拷贝赋值的时候，是直接赋予
的指向内存的地址，所以，hp中ps指向的内存和ret中指向的内存地址是一样的！所以这样在析构函数中会被delete两
次。注意这里的指针指向的内存是被动态分配的才可以，要不然，使用delete只会删除指针本身的内存，而不是指向
对象的内存！注意，这样的情况下，还会删除被传参进来的实参的ps中指向的内存！！

	此外，f的调用者还会使用传递给f的对象:
		HasPtr p("some values");
		f(p);		//当f结束时，p.ps指向的内存被释放
		HasPtr q(p);	//现在，p和q都指向无效内存。
p(以及q)指向的内存不再有效，在hp(或ret)销毁时，它就被归还给系统了。！！
注意:
	如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。

需要拷贝操作的类也需要赋值操作，反之亦然
	虽然很多类需要定义所有(或者是不需要定义任何)拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，
不需要析构函数。作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个拷贝构造函数为
每个新创建的对象生成一个新的、独一唯二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个
类还需要自定义拷贝赋值运算符来避免序号赋予目的对象。但是，这个类不需要自定义析构函数。
	这个例子引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。
反之亦然－－如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构
造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。
注意:
	要区别拷贝构造函数和拷贝赋值运算符！拷贝构造函数是在初始化的时候使用的！拷贝赋值运算符是在赋值的时候使
用的。所以，一旦一个类需要拷贝构造函数，那么肯定也需要拷贝赋值运算符！

13.1.5	使用=default
	我们可以通过将拷控制成员定义为=default来显示地要求编译器生成合成的版本:
		class Sales_data{
		public:
			//拷贝控制成员，使用default
			Sales_data() = default;
			Sales_data(const Sales_data &) = default;
			Sales_data &operator=(const Sales_data&);
			~Sales_data() = default;
			//其他成员定义，如前
		};
		Sales_data &Sales_data::operator=(const Sales_data &) = default;
当我们在类内使用=default修饰成员声明时，合成的函数将隐式地声明为内联的(就像是任何其他类内声明的成员函数一样)
。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。
注意:
	我们只能对具有合成版本的成员函数使用=default(即，默认构造函数或拷贝控制成员)。

13.1.6	阻止拷贝
	大多数应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显示地。
虽然大多数类应该定义(而且通常也的确定义了)拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。
在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读
取相同的IO缓冲。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的:如果我们的类未定义这些操
作，编译器为它生成合成的版本。

定义删除的函数
	在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除函数(deleted function)来组织拷贝。删除
的函数是这样一种函数:我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们
希望将它定义了删除的:
		struct Nocopy{
			Nocopy() = default;		//使用合成的默认构造函数
			Nocopy(const Nocopy &) = delete;		//阻止拷贝
			Nocopy & operator=(const Nocopy &) =delete;	//阻止赋值
			~Nocopy() = default;	//使用合成的析构函数
		};
=delete通知编译器(以及我们代码的读者)，我们不希望定义这些成员。
	与default不同，=delete必须出现在第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的
成员只影响为这个成员而生成的代码，因此=default知道编译器生成代码的时候才需要。而另一方面，编译器需要知道一个
函数是删除的，以便禁止试图使用它的操作。
	与=default的另一个不同之处是，我们可以对任何函数指定=delete(我们只能对编译器可以合成的默认构造函
数或拷贝控制成员使用=default)。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除
函数有时也是有用的。

析构函数不能是删除的成员
	值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的
类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们
也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员是无法被销毁的。而如果一个成员无法
被销毁，则对象整体也就无法被销毁了。
	对于删除了析构函数的类型，虽然我们不能定义这种类型的变量成员，但可以动态分配这种类型的对象。但是不能释放
这些对象:
		struct NoDtor{
			NoDtor() = default;	//使用合成默认构造函数
			~NoDtor() = delete;	//我们不能销毁NoDtor类型的对象
		};
		NoDtor nd;			//错误:NoDtor的析构函数是删除的
		NoDtor *p = new NoDtor();	//正确:但我们不能delete p!!!
		delete p;	//错误:NoDtor的析构函数是删除的
注意:
	对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

合成的拷贝控制成员可能是删除的
	如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数，编译器
会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数:
		>>如果类的某个成员的析构函数是删除的或不可访问的(例如，是private的),则类的合成析构函数定义为可删除
的。
		>>如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个
成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
		>>如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的引用成员，则类的合成拷贝赋
值运算符被定义为删除的。
		>>如果类的某个成员的析构函数是可删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一
个const成员，它没有类内初始化器且类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。
本质上，这些规则的含义是:如果一个类有数据成员不能默
认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的。一
个成员有删除的或不可访问的析构函数会导致合成的默认构
造函数被定义删除的，这看起来可能有些奇怪。其原因是，如果没有这条
规则，我们可能会创建出无法销毁的对象。
	对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认的构造函数，这应该不奇怪。(主要是因为，引
用类型的必须要赋初值才行，如果有默认构造函数的话，就有可能会没有被赋初值，const同理)同样不出人意料的是:如果有一个
类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个const对象是
不可能的。
	虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成
拷贝赋值运算符，则赋值后，左侧的运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对向指向相同的对象。由于这种行
为看起来并不是我们希望的，因此对有引用成员的类，合成拷贝赋值运算符被定义为删除的。
这里的意思是:
			int b =10;			Sales_data b1,c1;
			int &a = b;			Sales_data a1 = b1;
			a = 12;				a1 = c1;
在引用的时候，我们通过拷贝赋值，改变的是引用对象的值，也就是b的值。但是在类中拷贝赋值运算符的意思是将c1拷贝给a1
，如果要是用默认合成赋值运算符的话，改变的是引用本身，而不是引用对象的值！所以必须得自己定义赋值运算符才可以的，不
能使用默认的合成赋值运算符！！
	我们将在13.6.2节、15.7.2节以及19.6节中介绍导致类的拷贝控制成员被定义为删除函数的其他原因。

private	拷贝控制
	在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来组织拷贝:
		class PrivateCopy{
			//无访问说明符；接下来的成员默认为private的
			//拷贝控制成员是private的，因此普通用户代码无法访问，也就是普通的对象是访问不了的，只能是类的成员
函数才可以访问的
			PrivateCopy(const PrivateCopy&);
			PrivateCopy &operator=(const PrivateCopy &);
			//其他成员
		public:
			PrivateCopy() = default;		//使用合成的默认构造函数
			~PrivateCopy();	//用户可以定义此类型的对象，但无法拷贝他们
		};
由于析构函数是public的，用户可以定义PrivateCopy类型的对象。但是，由于拷贝构造函数和拷贝赋值运算符是private的
，用户代码将不能拷贝这个类型的对象。但是，友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将
这些拷贝控制成员声明为private的，但并不定义他们。
	声明但不定义一个成员函数是合法的，对此只有一个例外，我们将在15.2.1节中介绍。试图访问一个未定义的成员将导致
一个链接时错误。通过声明(但不定义)private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图:试图拷贝对象
的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。
注意:
	希望阻止拷贝的类应该使用=delete来定义他们自己的拷贝构造函数和拷贝赋值运算方法，而不应该将它们声明为private。

13.2	拷贝控制和资源管理
	通常，管理类外资源的类必须定义拷贝控制成员。如我们在13.1.4节中所见，这种类需要通过析构函数来释放对象所分
配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。
	为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择:可以定义拷贝操作，使类的行为
看起来像一个值或像一个指针。类的行为像一个值，意味着它应该也有自己的状态，当我们拷贝一个像值的对象时，副本和原
对象是完全独立的，改变副本不会对原对象有任何影响，反之亦然。
	行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原
对象，反之亦然。在我们使用过的标准库类中，标准库容器和string类的行为像一个值。而不出意外的，shared_ptr类
提供类似指针的行为，就像我们的StrBlob类一样，IO类型和unique_ptr不允许拷贝或赋值，因此他们的行为既
不像值也不像指针。
	为了说明这两种方式，我们会为联系中的HasPtr类定义拷贝控制成员。首先，我们将令类的行为像一个值；然后重新实
现类，使它的行为像一个指针。我们的HasPtr类有两个成员，一个int和一个string指针。通常，类直接拷贝内置类型(不包
括指针)成员:这些成员本身就是值，因此通常应该让它们的行为像值一样。我们如何拷贝指针成员决定了像HasPtr这样的
类是具有类值行为还是类指针行为。

13.2.1	行为像值的类
	为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的string，每个
HasPtr对象都必须有自己的拷贝。为了实现类值行为，HasPtr需要:
		>>>定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
		>>>定义一个析构函数来释放string
		>>>定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string
类值版本的HasPtr如下所示
		class HasPtr{
		public:
			HasPtr(const std::string &s = std::string()):ps(new std::string(s)),i(0){}
			//对ps指向的string，每个HasPtr对象都有自己的拷贝
			HasPtr(const HasPtr &p):ps(new std::string(*(p.ps)),i(p.i){}
			HasPtr &operator=(const HasPtr &);
			~HasPtr(){delete ps};
		private:
			std::string *ps;
			int 		i;
		};
我们的类足够简单，在类内就已定义了除赋值运算符之外的所有成员函数。第一个构造函数接受一个(可选的)string参
数。这个构造函数动态分配它自己的string副本，并将指向string的指针保存在ps中。拷贝构造函数也分配它自己的string
副本。析构函数对指针成员ps执行delete，释放构造函数中分配的内存。

类拷贝赋值运算符
	赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝
构造函数，赋值操作会从右侧运算对象拷贝数据。但是，非常重要的一点是，这些操作是以正确的顺序执行的，即使将一
个对象赋予它自身，也保证正确。而且，如果可能我们编写的赋值运算符还应该是异常安全的－－－当异常发生时能将左
侧运算对象置于一个有意义的状态。
	在本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。在完成拷
贝后，我们释放左侧运算对象的资源，并更新指针指向所分配的string:
		HasPtr &operator=(const HasPtr &rhs)
		{
			auto newp = new string(*rhs.ps);	//拷贝底层string
			delete ps;		//释放旧内存
			ps = newp;		//从右侧运算对象拷贝数据到本对象
			i = rhs.i;
			return *this;	//返回本对象
		}
在这个赋值运算符中，非常清楚，我们首先进行了构造函数的工作:newp的初始化等价于HasPtr的拷贝构造函数中ps的初
始化器。接下来与析构函数一样。我们delete当前ps指向的string。然后就只剩下拷贝指向新分配的string的指针，
以及从rhs拷贝int值到本对象了。
关键概念:赋值运算符
	当你编写赋值运算符时，有两点需要记住:
		>>如果将一个对象赋予它自身，赋值运算符必须能正确工作
		>>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运
算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成
员中了。
	为了说明防范自赋值操作的重要性，考虑如果赋值运算符如下编写将发生什么:
		//这样编写赋值运算符是错误的!
		HasPtr &HadPtr::operator=(const HasPtr &rhs)
		{
			delete ps;		//释放对象指向的string
			//如果rhs和*this是同一个对象，我们就将已从释放的内存中拷贝数据!
			ps = new string(*rhs.ps);
			i = rhs.i;
			return *this;
		}
如果rhs和本对象是同一个对象，delete ps会释放*this和rhs指向的string。接下来，当我们在new表达式中试图拷贝
*(rhs.ps)时，就会访问一个指向无效内存的指针，其行为和结果是未定义的。
对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也能正确工作。一个好的方法是在销毁
左侧运算对象资源之前拷贝右侧运算对象。主要是为了防止销毁对象是本身所要拷贝的内存空间!

13.2.2	定义行为像指针的类
	对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是指向它指向的
string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。但是，在本例中，析构函数不
能单方面释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。
	令一个类展现类似指针的行为的最好的方法是使用shared_ptr来管理类中的资源。拷贝(或赋值)一个shared_ptr
会拷贝(赋值)shared_ptr所指向的指针。shared_ptr类自己记录有多少个用户共享它所指向的对象。当没有用户使用
对象时，shared_ptr类负责释放资源。
	但是，有时我们希望直接管理资源。在这种情况下，使用引用计数就很有用了。为了说明引用计数如何工作，我们将重
新定义HasPtr，令其行为像指针一样，但我们不使用shared_ptr，而是设计自己的引用计数。

引用计数
	引用计数的工作方式如下:
		>>除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象正在创建
共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。
		>>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数
器，指出给定对象的状态又被一个信用户所共享。
		>>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态
		>>拷贝赋值运算符递增右侧对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意
味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。
唯一的难题是确定在哪里存放引用计数。计数器不能直接作为HasPtr对的成员。下面的例子说明了原因:
		HasPtr p1("Hiya");
		HasPtr p2(p1);		//p1和p2指向相同的string;因为这是拷贝初始化
		HasPtr p3(p1);		//p1、p2和p3都指向相同的string
如果引用计数保存在每个对象中，当创建p3时我们应该如何正确更新它呢？可以递增p1中的计数器并将其拷贝到p3中，
但如何更新p2中的计数器呢？
	解决此问题的一种方法是将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋
值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会相同的计数器。

定义一个使用引用计数的类
	通过使用引用计数，我们就可以编写类指针的HasPtr版本了:
		class HasPtr{
		public:
			//构造函数分配新的string和新的计数器，将计数器置为1
			HasPtr(const std::string &s = std::string()) : 
				ps(new std::string(s)),
				i(0),
				use(new std::size_t(1)){}
			//拷贝构造函数拷贝所有三个数据成员，并递增计数器
			HasPtr(const HasPtr &p) : ps(p.ps),i(p.i),use(p.use){++*use;}
			HasPtr &operator=(const HasPtr &);
			~HasPtr();
		private:
			std::string *ps;
			int i;
			std::size_t *use;	//用来记录有多少个共享对象*ps的成员
		};
在此，我们添加了一个名为use的数据成员，它记录有多少个对象共享相同的string。接受string参数的构造函数分
配新的计数器，并将其初始化为1，指出当前有一个用户使用本对象的string成员。

类指针的拷贝成员"篡改"引用计数
	当拷贝或赋值一个HasPtr对象时，我们希望副本和原对象都指向相同的string。即，当拷贝一个HasPtr时，我
们将拷贝ps本身，而不是ps指向的string。当我们进行拷贝时，还会递增该string关联的计数器。
	(我们在类内定义的)拷贝构造函数拷贝给定HasPtr的所有三个数据成员，这个构造函数还递增use成员，指出ps
和p.ps指向的string又有了一个新的用户。析构函数不能无条件地delete ps－－可能还有其他对象指向这块
内存。析构函数应该递减引用计数，指出共享string的对象少了一个。如果计数器变为0，则析构函数释放ps和use
指向的内存。
		HasPtr::~HasPtr()
		{
			if(--*use == 0){	//如果引用计数变为0
				delete ps;		//释放string内存
				delete use;		//释放计数器内存
			}
		}
注意:
	这里有一点前提很重要，就是在类销毁对象的时候，不会销毁指针指向的对象的内容。只会销毁指针本身。但是如果
你指针指向一个动态内存分配的对象，且显示的删除该指针，那么就会删除指针指向对象的内容！所以在这里，对象共享
的时候，如果单纯的引用计数没有为0话，删除该对象，指针会被释放掉，但是指向内存的内容是不会被释放掉的，因
为你没有进行显示的delete。
拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算对象的引用计数(即，拷
贝构造函数的工作)，并递减左侧运算对象的引用计数，在必要时释放使用的内存(即，析构函数的工作)。
	而且与往常一样，赋值运算符必须处理自赋值。我们通过先递增rhs中的计数然后再递减左侧运算对象中的计数来实现
这一点。通过这种方法，当两个对象相同时，在我们检查ps(及use)是否应该释放之前，计数器就已经被递增过了。
		HasPtr &HasPtr::operator=(const HasPtr &ths)
		{
			++*rhs.use;	//递增右侧运算对象的引用计数
			if(--*use == 0){	//然后递减本对象的引用计数
				delete ps;		//如果本对象的因拥计数变为0了，那就删除ps指向的内存空间
				delete use;		//并且把use指向的内存空间的内容删除掉
			}
			ps = rhs.ps;	//重新赋值
			i = rhs.i;
			use = rhs.use;	//一定要记得赋予这个引用计数，因为这个引用计数也是这个对象共享的
			return *this;
		}
小结:
	13.2主要就是介绍了，如何使用拷贝构造函数和拷贝赋值运算符来进行拷贝值，还是拷贝指针本身！！
13.3	交换操作
	除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使
用的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。
	如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap，虽然与往
常一样我们不知道swap是如何实现的，但理论上很容易理解，为了交换两个对象，我们需要进行一次拷贝和两次赋值。例
如，交换两个类值HasPtr对象的代码可能像下面这样:
		HasPtr temp = v1;		//创建v1的值的一个临时副本
		v1 = v2;				//将v2的值赋予v1
		v2 = temp;				//将保存的v1的值赋予v2
这段代码将原来v1中的string拷贝了两次，第一次是HasPtr的拷贝构造函数将v1拷贝给temp，第二次是赋值运算符
将temp赋予v2。将v2赋予v1的语句还拷贝了原来v2中的string。如我们所见，拷贝一个类值的HasPtr会分配一个新
string并将其拷贝到HasPtr指向的位置。
	理论上，这些内存分配都是不必要的，我们更希望swap交换指针，而不是分配string的新副本。即，我们希望这
样交换两个HasPtr:
		string *temp = v1.ps;		//为v1.ps中的指针创建一个副本
		v1.ps = v2.ps;				//将v2.ps中的指针赋予v1.ps
		v2.ps = temp;				//将保存的v1.ps中原来的指针赋予v2.ps

如何编写我们自己的swap函数
	可以在我们的类上定义一个自己版本的swap来重载swap的默认行为。swap的典型实现如下:
		class HasPtr{
			friend void swap(HasPtr &,HasPtr &s);
			//其他成员定义，和以前一样
		};
		inline void swap(HasPtr &lhs,HasPtr &rhs)
		{
			using std::swap;
			swap(lhs.ps,rhs.ps);	//交换指针，而不是string数据
			swap(lhs.i,rhs.i);		//交换int成员
		}
我们首先将swap定义为friend，以便能访问HasPtr的(private)数据成员，由于swap的存在就是为了优化代码，我们
将其声明为inline的函数。swap的函数体对给定对象的每个数据成员调用swap。我们首先swap绑定到rhs和lhs的对象
的指针成员，然后是int成员。
注意:
	与拷贝控制成员不同，swap并不是必要的，但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。

swap函数应该调用swap，而不是std::swap
	此代码中有一个很重要的微妙之处:虽然这一点在这个特殊的例子中并不重要，但在一般情况下他们非常重要--swap
函数中调用的swap而不是std::swap。在本例中，数据成员是内置类型的，而内置类型是没有特定版本的swap的，所以
在本例中，对swap调用会调用标准库std::swap。
	但是如果一个类的成员有自己类型特定的swap函数，调用std::swap就是错误的了。例如，假定我们有一个命名为
Foo的类，它有一个类型为HasPtr的成员h。如果我们未定义Foo版本的swap，那么就会使用标准库版本的swap。如我们
所见，标准库swap对HasPtr管理的string进行了不必要的拷贝。
注意:
	其实就是一个类C1如果有了自己定义的swap函数，那么如果这个类的对象被做了另一个类C2的成员的话，那么C2的
成员使用的swap其实是标准库中的swap而不是原先C1的成员的swap函数。

我们可以为Foo编写一个swap函数，来避免这些拷贝。但是，如果这样编写Foo版本的swap:
		void swap(Foo &lhs,Foo &rhs)
		{
			//错误:这个函数使用了标准库版本的swap，而不是HasPtr版本
			std::swap(lhs.h,rhs.h);
			//交换类型Foo的其他成员
		}
此编码会编译通过，且正常允许。但是，使用此版本与简单使用默认版本的swap并没有任何性能差异。问题在于我们显示地
调用了标准库版本的swap。但是，我们不希望使用std中的版本，我们希望使用为HasPtr对象定义的版本。
	正确的swap函数如下所示:
		void swap(Foo &lhs,Foo &rhs)
		{
			using std::swap;
			swap(lhs.h,rhs.h);//使用HasPtr版本的swap
			//交换类型Foo的其他成员
		}
每个swap调用应该都是未加限定的。即，每个调用都应该是swap，而不是std::swap。如果存在类型特定的swap版本，
其匹配程度会优于std中定义的版本，原因我们将在16.3节中进行解释。因此，如果存在类型特定的swap版本，swap调用
会与之匹配。如果不存在类型特定的版本，则会使用std中的版本(假定作用域中有using声明)。
	非常仔细的读者可能会奇怪为什么swap函数中的using声明没有隐藏HasPtr版本的声明。我们将在18.2.3节中解释
为什么这段代码能正常工作。

在赋值运算符中使用swap
	定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝交换的计数。这种计数将左侧运算
对象与右侧运算对象的一个副本进行交换:
		//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
		//将右侧运算对中的string拷贝到rhs
		HasPtr &HasPtr::operator=(HasPtr rhs)
		{
			//交换左侧运算对象和局部变量rhs的内容
			swap(*this,rhs);	//rhs现在指向本对象曾经使用的内存
			return *this;		//rhs被销毁，从而delete了rhs中的指针
		}
在这个版本中的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs是右
侧运算对象的一个副本。参数传递时拷贝HasPtr的操作会分配该对象的string一个新副本。
	在赋值运算符的函数体中，我们调用swap来交换rhs和*this中的数据成员。这个调用将左侧运算对象中原来保存的指
针存入rhs中，并将rhs中原来的指针存入*this中。因此在swap调用之后，*this中的指针成员将指向新分配的strring--
右侧运算对象中的一个副本。
	当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，即释放掉左
侧运算对象中原来的内存。这个技术的有趣之处是它自动处理了自赋值情况且天然是异常安全的。它通过在改变左侧运算对象
之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。它保证异常安全的方法也
与原来的赋值运算符实现一样。代码中唯一可能抛出异常的是拷贝构造函数中的new表达式，如果真发生了异常，它也会在我
们改变左侧运算对象之前发生。
Tips
	使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值
小结:
	在13.3节中首先提出的两种交换操作中，第二种的性能是优于第一种性能的。首先在有指针的情况下，指针的开销是比
string对象的开销要小的。接着如果没有指针对象的话，那么第一种还需要使用析构函数以及构造函数来进行相应的资源释
放和创建也是一种资源的浪费。

13.4拷贝控制示例
	虽然通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因。一些类
也需要拷贝控制成员的帮助来进行簿记工作或其他操作。作为类需要拷贝控制来进行簿记操作的例子，我们将概述两个类的设
计，这两个类可能用于邮件处理应用中。两个类名为Messages和Folder中。分别表示电子邮件(或者其他类型的)的消息
和消息目录。每个Messages对象可以出现在多个Folder中。但是，任意给定的Message的内容只有一个副本。这样，如
果一条Message的内容被改变，则我们从它所在的任何Folder来浏览时，都会看到改变后的内容。
	为了记录Message位于哪些Folder中，每个Message都会保存一个它所在Folder的指针的set，同样的，每个Folder
都保存一个它包含的Message的指针的set。我们的Message类会提供save和remove操作，来向一个给定的Folder添加一条
Message或是从中删除一条Message。为了创建一个新的Message,我们会指明消息内容，但不会指出Folder。为了将一条
Message放到一个特定的Folder中，我们必须调用save。当我们拷贝一个Message时，副本和原对象将是不同的Message对
象，但两个Message都出现在相同的Folder中。因此拷贝Message的操作包括消息内容和Folder指针的set的拷贝。而且，
我们必须在每个包含此消息的Folder中添加一个指向新创建的Message的指针。
	当我们销毁一个Message时，它将不复存在。因此，我们必须从包含此消息所有Folder中删除指向此Message的指针。
当我们将一个Message对象赋予另一个Message对象时，左侧Message的内容会被右侧Message的内容所替代。我们还必须
更新Folder集合，从原来包含左侧Message的Folder中将它删除，并将它添加到包含右侧Message的Folder中。
	观察这些操作，我们可以看到，析构函数和拷贝赋值运算符都必须从包含一条Message的所有Folder中删除它。类似的，
拷贝构造函数和拷贝赋值运算符都要将一个Message添加到给定的一组Folder中。我们将定义这两个private的工具函数
来完成这些工作。
注意:
	拷贝赋值运算符通常执行拷贝构造函数和析构函数中要左的工作。这种情况下，公共的工作应该放在private的工具函数
中完成。

	Folder类也需要类似的拷贝控制成员，来添加或删除它保存的Message。我们将Folder类的设计和实现留作练习。
但是，我们将假定Folder类包含名为addMsg和remMsg的成员，分别完成在给定Folder对象的消息集合中添加和删除Message
的工作。

Message类
	根据上述设计，我们可以编写Message类，如下所示:
		class Message{
		friend class Folder;
		public:
			//folder被隐式初始化为空集合
			explicit Message(const std::string &str = ""):contents(str){}
			//拷贝控制成员，用来管理指向本Message的指针
			Message(const Message&);		//拷贝构造函数
			Message &operator=(const Message&);	//拷贝赋值运算符
			~Message();
			//从给定Folder集合中添加/删除本Message
			void save(Folder &);
			void remove(Folder &);
		private:
			std::string content;	//实际消息文本
			std::set<Folder *>folders;	//包含本Message的Folder
			//拷贝构造函数、拷贝赋值运算符和析构函数所使用的工具函数
			//将本Message添加到指向参数的Folder中
			void add_to_Folders(const Message &);
			//从folders中的每个Folder中删除Message
			void remove_from_Folders();
		};
这个类定义了两个数据成员:contents，保存消息文本；folders，保存指向本Message所在Folder的指针。接受一个
string参数的构造函数将给定string拷贝给contents，并将folders(隐式)初始化为空集。由于此构造函数有
一个默认参数，因此它也被当做Message的默认构造函数。

save和remove成员
	除拷贝控制成员外，Message类只有两个公共成员:save，将本Message存放在给定的Folderr中；remove，删
除本Message:
		void Message::svae(Folder &f)
		{
			folders.insert(&f);	//讲给定的Folder添加到我们的Folder列表中,这里为什么用&，因为
folders的元素是指向Folder的指针，所以的取地址！
			f.addMsg(this);		//将本Mssage添加到f的Message集合中
		}
		void Message::remove(Folder &f)
		{
			folders.erase(&f);		//将给定Folder从我们的Folder列表中删除
			f.remMsg(this);
		}
为了保存(或删除)一个Message，需要更新本Message的folders成员。当save一个Message时，我们应保存一个指向
给定Folder的指针；当remove一个Message时，我们要删除此指针。
这些操作还必须更新给定的Folder。更新一个Folder
的任务由Folder类的addMsg和remMsg成员来完成的，分别添加和删除给定的Message的指针。

Message类的拷贝控制成员
	当我们拷贝一个Message时，得到的副本应该与原Message出现在相同的Folder中。因此，我们必须遍历Folder指针
的set，对每个指向原Message的Folder添加一个指向新Message的指针。拷贝构造函数和拷贝赋值运算符都需要做这个工
作，因此我们定义一个函数来完成这个公共操作:
		//将本Message添加到指向m的Folder中
		void Message::add_to_Folders(const Message &m)
		{
			for(auto f : m.folders)	//对每个包含m的Folder
				f->addMsg(this);	//向该Folder添加一个指向本Message的指针
		}
此例中我们对m.folders中每个Folder调用addMsg会将本Message的指针添加到每个Folder中。
	Message的拷贝构造函数拷贝给定对象的数据成员:
		Message::Message(const Message &m):content(m.contents),folders(m.folders){
			add_to_Folders(m);	//将本消息添加到指向m的Folder中
		}
并调用add_to_Folders将新创建的Message的指针添加到每个包含原Message的Folder中。

Message的析构函数
	当一个Message被销毁时，我们必须从指向此Message的Folderr中删除它。拷贝赋值运算符也要执行此操作，因此我
们会定义一个公共函数来完成此操作:
		//从对应的Folder中删除本Message
		void Message::remove_from_Folder()
		{
			for(auto f : folders)	//对folder中每个指针
				f->remMsg(this);		//从该Folder中删除本Message
		}
函数remove_from_Folder的实现类似add_to_Folders，不同之处是它调用remMsg来删除当前Message而不是调用
addMsg来添加Message。
	有了remove_from_Folder函数，编写析构函数就很简单了:
		Message::~Message()
		{
			remove_from_Folders();
		}
调用remove_from_Folders确保没有任何Folder保存正在销毁的Message的指针。编译器自动调用string的析构
函数来是释放contents，并自动调用set的析构函数来清理合成员使用的内存。

Message的拷贝赋值运算符
	与大多数赋值运算符相同，我们的Message类的拷贝赋值运算符必须指向拷贝构造函数和析构函数的工作一样。与往常
一样，最重要的是我们要组织好代码结构，使得即使左侧和右侧运算对象是同一个Message，拷贝赋值运算符也能正确执行。
在本例中，我们先从左侧运算对象的folders中删除此Message的指针，然后再将指针添加到右侧运算算对象的folders
中从而实现自赋值的正确处理:
		Message &Message::operator=(const Message &rhs)
		{	//通过先删除指针再插入他们来处理自赋值情况
			remove_from_Folders();	//更新已有Folder
			contents = rhs.contents;	//从rhs拷贝消息
			folders = rhs.folders;	//从rhs拷贝Folders指针
			add_to_Folders(rhs);	//将本Message添加到那些Folder中
			return *this;
		}
如果左侧和右侧运算对象是相同的Message，则他们具有相同的地址，如果我们在add_to_Folders之后调用
remove_from_Folders，就会将此Message从它所在的所有Folder中删除。

Message的swap函数
	标准库中定义了string和set的swap版本。因此，如果为我们的Message类定义它自己swap版本，它将从中收益。
通过定义一个Message特定版本的swap，我们可以避免对contents和folders成员进行不必要的拷贝。
	但是，我们的swap函数必须管理指向被交换Message的Folder指针。在调用swap(m1,me)之后，原来指向m1的
Folder现在必须指向m2,反之亦然。我们通过两遍扫描folders中每个成员来正确处理Folder指针。第一遍扫描将Message
从他们所在的Folder中删除。接下来我们调用swap来交换数据成员。最后对folders进行第二遍扫描来添加交换过的Message：
		void swap(Message &lhs,Message &rhs)
		{
			using std::swap;	//在本例中严格来说并不需要，但这是一个好习惯
			//将每个消息的指针从它(原来的)所在Folder中删除
			for(auto f : lhs.folders)
				f->remMsg(&rhs);
			for(auto f : rhs.folders)
				f->remMsg(&rhs);
			//交换contents和Folder指针set
			swap(lhs.folders,rhs.folders);	//使用swap(sett &,set &)
			swap(lhs.contents,rhs.contents);	//使用swap(string &,string &);
			//将每个Message的指针添加到他们的(新)Folder中
			for(auto f : lhs.folders)
				f->addMsg(&lhs);
			for(auto f : rhs.folders)
				f->addMsg(&rhs);
		}
这里讲解下:
	这个交换的逻辑，首先要明白一点就是Message里的folders存储的是它在那些Folder下存在；而addMsg是表示
Folder要显示的信息有哪些。所以，在交换的时候，首先要将Folder中的相关的Message的指针给清理掉，然后再交换
相关的Message应该在那些Folder中出现，最后再让Folder重新添加相应的Message指针。

13.5	动态内存管理类
	某些类需要在运行时分配可变大小的内存空间。这种类通常可以(并且如果它们确实可以的话，一般应该)使用标准库
容器来保存它们的数据。例如，我们的StrBlob类使用一个vector来管理其元素底层内存。但是，这一策略并不是对每个
类都使用：某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。例如，我们
将实现标准库vector类的一个简化版本，我们所做的一个简化是不使用模板，我们的类只用于string。因此，它被命名为
StrVec。

StrVec类的设计
	回忆一下，vector类将其元素保存在连续内存中。为了获得可接受的性能，vector预先分配足够的内存来保存可能
需要的更多元素。vector的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个可
用位置构造一个对象。如果没有可用空间，vector就会重新分配空间；它获得新的空间，将已有元素移动到新空间中，释
放旧空间，并添加新元素。
	我们在StrVec类中使用类似的策略。我们将使用一个allocator来获得原始内存。由于allocator分配的内存是
未构造的，我们将在需要添加新元素时用allocator的constructor成员在原始内存中创建对象。类似的，当我们需要删
除一个元素时，我们将使用destory成员来销毁元素。
	每个StrVec有三个指针成员指向其元素所使用的内存:
		>>elements，指向分配的内存中的首元素
		>>first_free,指向最后一个实际元素之后的位置。
		>>cap，指向分配的内存末尾之后的位置
图13.2说明了这些指针的含义:
		|0||1||2||3||4|未构造的元素|
	   |               |		  |
	 elements       first_free   cap
除了这些指针外，StrVec还有一个名为alloc的静态成员，其类型为allocator<string>。alloc成员会分配StrVec
使用的内存。我们的类还有4个工具函数:
		>>alloc_n_copy会分配内存，并拷贝一个给定范围中的元素
		>>free会销毁构造的元素并释放内存
		>>chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc会
调用reallocate来分配更多内存。
		>>reallocate在内存用完时为StrVec分配新内存
虽然我们关注的是类的实现，但我们也将定义vector接口中的一些成员。

StrVec类定义
	有了上述实现概要，我们现在可以定义StrVec类，如下所示:
		//类vector类内存分配策略的简化实现
		class StrVec{
		public:
			//allocator成员进行默认初始化
			StrVec():elements(nullptr),first_free(nullptr),cap(nullptr){}
			StrVec(const StrVec&);	//拷贝构造函数
			StrVec &operator=(const StrVec &);	//拷贝赋值运算符
			~StrVec();				//析构函数
			void push_back(const std::string &);	//拷贝元素
			size_t size()const {return first_free - elements;}
			size_t capacity() const { return cap - elements;}
			std::string *begin()const { return elements;}
			std::string *end()const { return first_free;}
			//...
		private:
			Static std::alloactor<string> alloc;
			//被添加元素的函数所使用
			void chk_n_alloc(){
				if(size() == capacity())
					reallocatr();
			}
			//工具函数，被拷贝构造函数、赋值运算符和析构函数所使用
			std::pair<std::string *,std::string *>
			alloc_n_copy(const std::string *,const std::string *);
			void free();		//销毁元素并释放内存
			void reallocate();	//获得更多内存并拷贝已有元素
			std::string *elements;	//指向数组首元素的指针
			std::string *first_free;	//指向数组第一个空闲元素的指针
			std::string *cap;
		};
	类体定义了多个成员:
		>>默认构造函数(隐式地)默认初始化alloc并(显示地)将指针初始化为nullptrr，表明没有元素。
		>>size成员返回当前真正在使用的元素的数目，等于first_free-elements;
		>>capacity成员返回StrVec可以保存的元素的数量，等价于cap-elements;
		>>当没有内存空间容纳新元素的时候，即cap==size时，chk_n_alloc会为StrVec重新分配内存。
		>>begin和end成员分别返回指向首元素(即elements)和最后一个构造元素之后的位置(即first_free)的指针

使用construct
	函数push_back调用chk_n_alloc确保有空间容纳新元素。如果需要，chk_n_alloc会调用reallocate。当
chk_n_alloc返回时，push_back必须有空间容纳新的元素。它要求其allocator成员来construct新的尾元素:
		void StrVec::push_back(const string &s)
		{
			chk_n_alloc();	//确保有空间容纳新元素
			//在first_free指向的元素中构造s的副本
			alloc.construct(first_free++,s);
		}
当我们用allocator分配内存时，必须记住内存是未构造的。为了使用原始内存，我们必须调用construct，在此内存中
构造一个对象。传递给construt的第一个参数必须是一个指针，指向调用allocate所分配的未构造的内存空间。剩余参
数确定用哪个构造函数来构造对象。在本例中，只有一个额外参数，类型为string，因此会使用string的拷贝构造函数。
	值得注意的是，对construct的调用也会递增first_free，表示已经构造了一个新的元素，它使用后置递增，因此
这个调用会在first_free当前值指定的地址构造一个对象，并递增first_free指向下一个未构造的元素。

alloc_n_copy成员
	我们在拷贝或赋值StrVec时，可能会调用alloc_n_copy成员。类似vector，我们的StrVec类有类值的行为。
当我们拷贝或赋值StrVec时，必须分配独立的内存，并从原StrVec对象拷贝元素至新对象。
	alloc_n_copy成员会分配足够内存来保存给定范围的元素，并将这些元素拷贝到新分配的内存中。此函数返回一
个指针的pair，两个指针分别指向新空间的开始位置和拷贝的尾后位置:
		pair<string *,string *> StrVec::alloc_n_copy(const string *b,const string *e)
		{
			//分配内存空间保存给定范围中的元素
			auto data = alloc.allocate(e-b);
			//初始化并返回一个pair，该pair由data和uninitialized_copy的返回构成
			return {data,uninitialized_copy(b,e,data)};
		}
alloc_n_copy用尾后指针减去首元素指针，来计算需要多少空间。在分配内存之后，它必须在此空间中构造给定元素的副本。
	它是在返回语句中完成拷贝工作的，返回语句中对返回值进行了列表初始化。返回的pair的first成员指向分配内存的
开始位置；second成员则是uninitialized_copy的返回值，此值是一个指针，指向最后一个构造元素之后的位置。

free成员
