									第四章 表达式
内容
-------------------------
	4.1		基础
	4.2		算术运算符
	4.3		逻辑和关系运算符
	4.4 	赋值运算符
	4.5 	递增和递减运算符
	4.6		成员访问运算符
	4.7 	条件运算符
	4.8		位运算符
	4.9 	sizeof运算符
	4.10	逗号运算符
	4.11 	类型转换
	4.12	运算符优先级表
-------------------------
	C++语言提供了一套丰富的运算符，并定义了这些运算符作用于内置类型的运算对象时所执行的操作。同时，当运算对象是类类型时，C++语言也允许用户指定上述运算符的含义。本章主要介绍由语言本身定义、并用于内置类型运算对象的运算符，同时简单介绍几种标准库定义的运算符。
	表达式由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式（expression），其结果就是字面值和变量的值。把一个运算符（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式。
-----------
4.1		基础
4.1.1	基本概念
	C++定义了一元运算符（unary operator）和二元运算符（binary operator）。作用于一个运算对象的运算符是一元运算符，如取地址符（&）和解引用符（*）；作用于两个运算符是二元运算符，如相等运算符（==）和惩罚运算符（*）。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一个特殊的运算符，它对运算对象的数量没有限制。
	一些符号既可以作为一元运算符也可以作为二元运算符。以符号*为例，作为一元运算时执行解引用操作，作为二元运算符时执行惩罚操作。一个符号到底是一元运算符还是二元运算符由它的上下文决定。对于这类符号来说，它的两种用法互不相干，完全可以当成两个不同的符号。		

组合运算符和运算对象
	对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级（precedence）、结合律（associativity）以及运算对象的求值顺序（order of evaluation）。例如，下面这条表达式的求职结果依赖于表达式中运算符和运算对象的组合方式：
			5 + 10 * 20/2;
运算对象转换
	在表达式求值过程中，运算对象常由一种类型转换成另外一种类型。例如，尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候即使运算对象的类型不同也没有关系，只要他们能被转换成同一类型即可。
	类型转换的规则虽然有点复杂，但是大多数都合乎情理、容易理解。例如，整数能转换成浮点数，浮点数也能转换成整数，但是指针不能转换成浮点数。让人稍微有点意外的是，小整数类型（如bool,char,short等）通常会被提升成较大的整数类型，主要是int。
重载运算符
	C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型对象时，用户可以自行定义其含义！！！因为这种自定义的过程事实上是为已存在的运算符赋予另外一层含义，所以称之为重载运算符（overloaded operator）。IO库的>>和<<运算符以及string对象，vector对象迭代器使用的运算符都是重载运算符。
左值和右值
	C++的表达式要不然是右值（rvalue,读作"are-value"），要不然就是左值(lvalue，读作"ell-value"）。这两个名词是从C原因继承过来的。原本是为了帮助记忆：左值可以位于赋值语句的左侧，右侧则不能。
	在C++语言中，二者的区别就没那么简单。一个左值表达式的求职结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求职结果是对象，但是他们是右值而非左值。可以做一个简单的归纳：
		当一个对象被用作右值的时候，用的是对象的值；
		当对象被用作左值的时候，用的是对象的身份（在内存中的位置）
	不同的运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。一个重要的原则是在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用。当一个左值被当做右值使用时，实际上使用的是它的内容。到目前为止，已经有几种我们熟悉的运算符是要用到左值的。
		>>>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值！！！（也就是是说可以连续赋值  a = b = c = 10;)
		>>>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。
		>>>内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下表运算符的求值结果都是左值。
		>>>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值
使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式得到一个引用类型。举个例子，假定p的类型是int *，因为解引用运算生成左值，所以decltype(*p)的结果是int &。另一方面，因为取地址运算符生成右值，所以decltype(&p)的结果是int **，也就是说，结果是一个指向整形指针的指针。

4.1.2	优先级与结合律
	表达式中的括号无视结合律和优先级，所以程序员可以使用括号将表达式的某个局部括起来使其得到优先运算。
	结合律对表达式产生影响的一个典型示例是输入输出运算，4.8节将要介绍IO相关的运算符满足左结合律。这一规则意味着我们可以把几个IO运算符组合在一条表达式中：
			cin >> v1 >> v2;//注意，因为cin支持左结合律，所以首先的是cin >> v1然后其返回值仍然可以结合第二个v2。

4.1.3	求值顺序
	优先级规定了运算对象的组合方式（注意是运算对象的组合方式），但是没有说明运算对象按照什么顺序求职。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式：
			int i = f1() * f2();
我们知道f1和f2一定会在执行乘法之前被调用，因为毕竟相乘是这两个函数的返回值。但是我们无法知道到底是f1在f2之前调用还是f2在f1之前调用。
	对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将发生未定义的行为。但是注意，对于<<运算符来说，目前我百度出来的结果，以及在ubuntu 16.04下的g++编译器中出现的结果是没有未定义的结果。接下来的内容是从百度上得到的结果：https://blog.csdn.net/qq_40024275/article/details/100524036
先看这样一个例子：
				   #include <iostream>
				   using namespace std;
				   int  main(void)
				   {
					   int i = 2;
 				       cout<<"i = "<<i<<endl;
				       cout<<"i++: "<<i++<<",i++ : "<<i++<<endl;
				       cout<<"i = "<<i<<endl;
				       cout<<"++i : "<<++i<<",++i : "<<++i<<endl;
				       cout<<"i= "<<i<<endl;
				       cout<<"++i : "<<++i<<",i++ : "<<i++<<",++i : "<<++i<<endl;
				       cout<<"i = "<<i<<endl;
				       return 0;
				   }
继续看输出：
					i = 2
					i++: 3,i++ : 2
					i = 4
					++i : 6,++i : 6
					i= 6
					++i : 9,i++ : 7,++i : 9
					i = 9
这里我们首先得区别一下i++和++i的区别：
	i++，俗称先用后加；++i，俗称先加后用。
	i++，不可以做左值；++i,可以做左值
这是为什么？我们具体来看下他们的实现：
	i++
		const int int::operator++(int)
		{
			int old = *this;
			++(*this);
			return old;
		}
	++i
		int& int::operator++()
		{
			*this += 1;
			return *this;
		}
	前缀形式(++i)返回的是引用形式，也就是一个地址值，说明函数的返回值可以作为左值使用，并且函数本身是无参的，意味着是自身所在的空间增一后，再将自身的引用返回。
	而后缀形式（i++）是带参的，说明在刚进入函数的时候在另外的空间开辟，先将传入的值复制到一个副本中，将自身空间原本对应的位置值增一，最后返回的是副本的值。由于在函数的返回值传递的时候是传值进来的，因此返回的值指示一个临时变量，并不可以作为左值使用！也就是返回的结果还是原先的值，而本身的i却改变了。
cout的执行顺序
	cout输出的时候，是先从右往左扫描，将数据读入缓冲区，然后再将缓冲区的内容依次输出。缓冲区是一种类似与堆栈的结构，满足先进后出的特效。
因此分析一下上面的程序输出的结果：
	初始值i=2;
	cout<<"i++:"<<i++<<",i++:"<<i++<<endl;
	先扫描第一个i++,i变为1，但是i++返回的结果是0(也就是old)。所以缓冲区是：|2|。然后接下来扫描到i++,此时因为i是3，经过i++以后，i变为4，但是返回的结果依旧是old(也就是3）。所以此时缓冲区：|2||3|。然后cout按照堆栈的结果输出所以就是32了！！！（先进后出嘛）
	接下来，i=4；
	cout<<"++i:"<<++i<<",++i:"<<++i<<endl;
	按照cout从右往左扫描。首先扫到++i,此时i变为5，返回的是i的引用，所以进入栈的是|&i|，然后接下来是++i，所以此时i变为6，此时返回的还是i的引用。所以此时的缓冲区变为|&i||&i|。所以输出的是66！
但是请注意：这个可能是因为编译器的原因，编译器给你自动按照这种规则来处理的，在C++中这种运算对象的求值顺序的的确确是未定义的！！！！！！
但是这里有4种运算符明确规定了运算对象的求值顺序。第一种是提到的逻辑与（&&）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。另外三种分别是逻辑或（||），条件（?:)运算符和逗号(,)运算符符。

求值顺序、优先级、结合律
	运算对象的求值顺序与优先级和结合律是无关的，在一条形如f()+g()*h()+j()的表达式中：
			>>>>优先级规定：g()的返回值和h()的返回值相乘
			>>>>结合律规定：f()的返回值优先与g()和h()的乘积想加，所得结果再与j()的返回值相加。
			>>>>对于这些函数的调用顺序没有明确规定！！！！
如果f,g,h,和j是无关函数，它们既不会改变同一个对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。
小结：
		这里再一次说明，对象的调用顺序在C++中是没有明确的规定的，所以上面讲的都是针对C++语言本身的情况。在实际情况中，你是用的编译器肯定是支持某一种情况的。所以我上面讲的那个例子也只是在我ubuntu下g++版本下的编译器下的情况而已。其他的情况要看自己使用的编译器来具体对待。

4.2	算术运算符
						算术运算符（左结合律）
		运算符				功能				  用法
		  +				   一元正号			+ expr
		  -				   一元负号			-expr
-------------------------------------------------
		  *					 乘法            expr * expr
		  /					 除法		    expr / expr
		  %					 求余			expr % expr
-------------------------------------------------
		  +					二元加号			expr + expr
		  -					二元减号			expr - expr
上面的横线表示的优先级的分类，从上到下优先级依次减小。
算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升到较大的整数类型，所以运算对象最终会转变成同一类型。
	运算符%俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数，参与取余运算的运算对象必须是：：：整数：：：类型！
			int ival = 42;
			double dval = 3.14;
			ival % 12;			//正确：结果是6
			ival % dval;		//错误：运算对象是浮点类型
	在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++语言的早期版本结果为负值的商向上或向下取整数，C++11新标准规则规定商一律向0取整（即直接切除小数部分）。其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。

4.3	逻辑和关系运算符
	关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示真。
					逻辑运算符和关系运算符
		结合律		运算符		功能		用法
		  左          ！		   逻辑非	   ！expr
------------------------------------------------
		  左			  <			小于     expr<expr
		  左			  <=	   小于等于   expr<=expr
		  左			  >			 大于	expr>expr	
		  左			  >=		大于等于	expr>=expr
------------------------------------------------
		  左			  ==		  相等	expr == expr
		  左			  !=		 不相等	expr != expr
------------------------------------------------
		  左			  &&		 逻辑与	expr && expr
		  左		      ||		 逻辑或	expr || expr
------------------------------------------------
逻辑与和逻辑或运算符
	逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为短路求值。
	举一个使用逻辑或运算符的例子，假定有一个存储若干string对象的vector对象，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行，使用基于范围for循环处理string对象中的每个元素：
			for(const auto &s : text)
			{
				cout << s;
				if(s.empty() || s[s.size() - 1] == '.')
					cout << endl;
				else
					cout << " ";
			}
输出当前元素后检查是否需要换行。if语句的条件部分首先检查s是否是一个空的string，如果是，则不论左右侧运算符对象的值如何都应该换行。只有当string对象非空时才需要求第二个运算对象的值，也就是检查string对象是否以句号结束的。在这条表达式中，利用逻辑或运算符的短路求值策略确保只有当s非空时才会用下标运算符去访问它。
	值得注意的是，s被声明成了对常量的引用。因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝；又因为不需要对string对象做写操作，所以s被声明成对常量的引用！
小知识点：
		以后在使用范围for的时候，尽量使用引用，因为引用可以避免对长元素的拷贝操作！
4.4	赋值运算符
	C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：
					k = {3.14};		//错误：在列表初始化的时候，不能丢失原始数据的精度！
赋值运算符满足右结合律
	赋值运算符满足右结合律，这一点与其他二元运算符不太一样：
					int ival,jval;
					ival = jval = 0;	//正确，都被赋值为0
因为赋值运算符满足右结合律，所以靠右的赋值运算jval=0作为靠左运算符的右侧运算对象。又因为赋值运算返回的是其左侧运算对象，所以靠右的赋值运算的结果（jval)被赋值给了ival!

4.5	递增和递减运算符
	递增和递减运算符有两种形式：前置版本和后置版本。到目前为止，本书使用的都是前置版本，这种形式的运算符首先将运算对象加1（或减一），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减一），但是求值结果是运算对象改变之前的那个值的副本！！！：：注意是副本，返回的结果是副本！！！
				int i = 0,j;
				j = ++i;	//j = 1, i = 1;前置版本得到递增之后的值
				j = i++;	//j = 1, i = 2;后置版本得到递增之前的值。
这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。
注意：
		++这个运算符正如我上面的讲解是一样的，前置++,返回的是对象的引用，所以可以作为左值；后置++，返回的是原始对象的副本的值，所以只能作为右值。
---------
建议	除非必须，否则不用递增递减运算符的后置版本
	有C语言背景的读者可能对优先使用前置版本递增运算符有所疑问，其实原因很简单：前置版本的递增运算符避免了不必要的工作，它把加一后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便返回这个未改变的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。
	对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗大了。建议养成使用前置版本的习惯，这样不仅不需要担心性能的问题，而且更重要的是写出的代码会更符合编程的初衷。
---------
在一条语句中混用解引用和递增运算符
	举个例子，可以使用后置递归运算符来控制循环输出一个vector对象内容直至遇到（但不包括）第一个负值为止：
				auto pbeg = v.begin();//返回指向v的第一个元素的指针
				while(pbeg != v.end() && *pbeg >= 0)
					cout<<*pbeg++<<endl;
之所以可以那样写，是因为++运算符的优先级高于*的优先级。因此*pbeg++等价于*(pbeg++)。pbeg++把pbeg的值加1以后，返回pbeg的初始值的副本作为其求值的结果，此时解引用运算符的运算对象是pbeg未增加之前的值。最终，这条语句输出pbeg开始指向的那个元素，并将指针向前移动一个位置。

运算对象可以按任何顺序求值
	大多数运算符都没有规定运算对象的求值顺序，这在一般的情况下不会有什么影响。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。
	为了说明这一问题，我们将重写以前的程序：
				for(auto it = s.begin();it != s.end() && !isspace(*it); *it++)
					*it = toupper(*it);
如果用一个看似等价的while循环进行替代：
				while(it != s.end() && !isspace(*it))
					*it = toupper(*it++);
将产生未定义的行为。问题在于：赋值运算符左右两端的运算对象都用到了beg，并且右侧运算对象还改变了beg的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理该表达式：
					*beg = toupper(*beg);	//如果先求左侧的值
					*(beg + 1) = toupper(*beg);	//如果先求右侧的值

4.6	成员访问运算符
	点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*ptr).mem:
					string s1 = "a string",*p = &s1;
					auto n = s1.size();
					n = (*p).size();
					n = p->size();
因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没加括号，代码的含义就不大一样了。
	箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果就是右值。

4.7	条件运算符
		cond ? expr1 : expr2;
当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值！例如
				string finalgrade = (grade < 60) ? "fail" : "pass";
嵌套条件运算符
	允许在条件运算符的内部嵌套另外一个条件运算符。也就是说，条件表达式可以作为另外一个条件表达式的cond或者expr。举个例子
	finalgrade = (grade > 90) ? "high pass" : (grade < 60 ) ? "fail" : "pass";
	条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。因此在上面的代码中，靠右边的条件运算构成了靠左边的条件运算的分支！

在输出表达式中使用条件运算符
	条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式的时候，通常需要在它两端加上括号。例如，有时候需要根据条件值输出两个对象中的一个，如果写这条语句时没把括号写全就有可能产生意想不到的结果：
			cout<<((grade < 60) ? "fail" : "pass");//正常输出
			cout<<(grade<60) ? "fail" : "pass";	//输出 1 或 0
			cout<<grade < 60 ? "fail" : "pass";	//错误，试图比较cout和60

在第二条表达式中，grade和60的比较结果是<<运算符的运算对象，因此如果grade<60为真输出1，否则输出0.<<运算符的返回值是cout，接下来cout作为条件运算符的条件。也就是说，第二个表达式等价于：
			cout << (grade < 60);
			cout ? "fail":"pass";//	根据cout的值是true还是false产生对应的字面值
因为第三条表达式等价于：
			cout << grade;
			cout < 60 ? "fail" : "pass";
所以错误！

4.8	位运算符
						位运算符（左结合）
----------------------------------------------------
		运算符				功能					用法
----------------------------------------------------
		  ~				   按位取反				~expr
----------------------------------------------------
		  <<				 左移		         expr1 << expr2
		  >>				 右移		        expr1 >> expr2
----------------------------------------------------
		  &					 位与                 expr1 & expr2
----------------------------------------------------
		  ^					 位异或				 expr1 ^ expr2
----------------------------------------------------
		  |					  位或				 expr1 | expr2
注意：
	一般来说，如果运算对象是“小整型”，则它的值则会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值是负的，那么位运算符如何处理运算对象的符号位依赖于机器。
移位运算符
	这两种运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小鱼结果的位数，否则就会产生未定义的行为，二进制位数或向左移（<<）或者向右(>>)，移除边界之外的位数就被舍弃掉了。
				unsigned char bits = 0233;//10011011
				bits << 8;
	00000000 00000000 10011011 00000000
				bits << 31;
	10000000 00000000 00000000 00000000
				bits >> 3
	00000000 00000000 00000000 00010011
左移运算符(<<)在右侧插入值为0的二进制位。右移运算符的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或为0的二进制位。

位求反运算符
	位求反运算符(~)将运算对象逐位求反生成一个新值，将1置为0，将0置为1：
					unsigned char bits = 0227;
						10010111
					~bits
	 11111111 11111111 11111111 01101000
char类型的一般都是现需要提升到int类型！

位移运算符满足左结合律
	因为位移运算符满足左结合律，所以表达式：
			cout<<"hi"<<"there"<<endl;
的执行过程实际上等同于：
			((cout<<"hi")<<"there")<<endl
移位运算符的优先级不高不低，介于中间：比算术运算符的优先级地，但比关系运算符、赋值运算符和条件运算符高！

4.9	sizeof运算符
	sizeof运算符返回一条表达式或一个类型名字所占的字节数，sizeof运算符满足左结合律，其所得的值是一个size_t类型。运算符的运算对象有两种形式：
				sizeof(type)
				sizeof expr
在第二种形式中，sizeof返回的是表达式结果的类型的大小。与众不同的一点是,sizeof并不实际计算其运算对象的值！！
				Sales_data data,*p;
				sizeof(Sales_data);		//存储Sales_data类型的对象所占的空间的大小
				sizeof data ;			//data类型的大小，即sizeof(Sales_data)
				sizeof p;				//指针所占的空间大小
				sizeof *p;				//p所指类型的空间大小，即sizeof(Sales_data)
	这些例子中最有趣的一个是sizeof *p。首先，因为sizeof满足右结合律并且与*运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，它等价于sizeof(*p)。其次，因为sizeof不会实际求运算对象的值，所以即使p是一个无效的指针也不会有什么影响。在sizeof的运算对象中解引用一个无效的指针仍然是一种安全的行为。因为指针实际上并没有被真正使用，sizeof不需要真的解引用指针也能知道它所指对象的类型！
	sizeof运算符的结果部分地依赖于其作用的类型：
			>>>对char或者类型为char的表达式执行sizeof运算，结果得1
			>>>对引用类型执行sizeof运算得到被引用对象所占空间的大小
			>>>对指针执行sizeof运算得到指针本身所占的空间的大小
			>>>对指针解引用执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效（也就是不需要指向一个具体的对象！）
			>>>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。
			>>>对string或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用多少空间

逗号运算符
	逗号运算符含有两个运算对象，按照从左到右的顺序一次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序！！！
	对于逗号运算符来说，首先对左侧的表达式求值，然后将求值的结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值！

4.11	类型转换
	隐式转换的默认法则是，尽可能避免损失精度！所以表达式中如果有double和int，那么int就会变成double类型！
何时发送隐式转换：
			>>>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型！
			>>>在条件中，非布尔值转换成布尔类型
			>>>初始化过程中，初始值转成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
			>>>如果算术运算或关系运算的对象有多种类型，需要转换成同一种类型
			>>>函数调用时候也会发送类型转换
4.11.1	算术转换
整型提升
	整型提升负责把小整数类型转换成较大的整数类型。对于bool,char,signed char,unsigned char,short和unsigned short等类型来说，只要他们所有可能的值都能存在int里，他们就会提升成int类型；否则提升成unsigned int类型！
	较大的char类型提升成int,unsigned int,long,unsigned long,long long 和 unsigned long long中最小的一种类型。前提是转换成后的类型要能容纳的原类型所有可能的值！
请记住：一定要往大的类型转换，因为主要是为了不丢失精度，往大了不会丢失精度！

4.11.2	其他隐式转换
	数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：
			int ia[10];//
			int *ip = ia;//ia 转换成指向数组首元素的指针

当数组被用作decltype关键字的参数，或者作为取地址(&)、sizeof及typeid等运算对象时，上述转换不会发生。
	指针的转换：C++还规定了几种其他的指针转换方式，包括常量整数值0或者字面值nullptr能转换成任意指针类型！指向任意非常量的指针能转换成void *。指向任意对象的指针能转换成const void*。

转换成布尔型
	存在一种从算术类型或指针类型向布尔类型自动转换的机制如果指针或算术类型的值为0，转换结果是false；否则转换结果是true！
转换成常量
	允许将指向非常量类型的指针转换成相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用！
				int i;
				const int &j = i;	//非常亮可以转换成const int的引用
				const int *p = &i;	//非常量可以转换成const的地址
				int &r = j,*q = p;	//错误，不允许将const转换成非常量！！！

4.11.3	显式转换
命名的强制类型转换
	一个命名的强制类型转换具有如下形式：
					cast-name<type>(expression);
其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast,dynamic_cast,const_cast和reinterpret_cast中一种。

static_cast
	任何具有明确定义的类型转换，只要不包括底层const，都可以使用static_cast。例如，通过将一个运算对象强制转换成double类型就能使表达式执行浮点数除法：
				double slope = static_casr<double>(j) / i;
static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void *指针中的值：
			void *p = &d;	//正确，因为任何非常量对象的地址都能存入到void *中去。
			double *dp = static_cast<double *>(p);
当我们把指针存放在void *中，并且使用static_cast将其强制转换原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果！

const_cast
	const_cast只能改变运算对象的底层const，这里回顾下什么叫底层const!
				const char *pc;//这个const就叫做底层const。
底层const表示的是，你的指针指向的内容是常量，不能改变的！这里来区分一下三种情况下的const
				const char *pc;
				char const *pc;
				char *const pc;
其实区分这三种，只需要记住const的意义！const仅仅是一个修饰符，而且指针是一个复合类型即可！
	第一个根据优先级的原因，首先发现pc是一个*，也就是指针，然后接着往左看，发现是char，那么这个复合类型的指针就表示完整了，表示是一个指向char类型的指针。然后接着往左看，发现是const,那么发现const修饰的char，所以表示这个是一个指向常量char类型的指针。所以，就不可以通过p来改变被指向对象的值了！（也就是底层const)
	第二个，根据优先级发现也是一个指针，那么接下来就得找什么类型的指针，接着往左看，发现是const，这个时候注意，因为没有const *这种指针类型的，所以这个const修饰的肯定不是*那么只能是修饰的前面的类型，接着往左看，发现是char类型，所以发现这是一个char类型的指针，而且const修饰的是char，所以和第一个是一样的！
	第二个，根据优先级，发现const，所以这个const可以修饰pc，那么就说明这个pc是不能改变的！接着往左看，发现是*，好了，这他妈又是一个指针，那么接下来往左看，发现是char，好了这他妈实际上是一个指针，但是这个指针本身指向的的地址是不能改变的（这他妈就叫做顶层指针）！
	好了回到const_cast：
			const char *pc;
			char *p = const_cast<char *>(pc);	//正确：但是通过p写值是未定义的行为！！！因为这不符合底层const的本意！
对于将常量对象转换成非常量对象的行为，我们一般称其为”去掉const性质“。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果！
	注意，只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译错误。同样也不能使用const_cast改变表达式的类型！
			const char *cp;
			char *q = static_cast<char *>(cp);	//错误，static_cast不能去掉const性质
			static_cast<string>(cp);	//正确
			const_cast<string>(cp);	//错误:const_cast只能改变常量属性！
4.12	运算符优先级表
		结合律和运算符			功能				用法
---------------------------------------------------
		  左	   ::		  全局作用域          ::name
		  左	   ::          类作用域           class::name
		  左	   ::		 命名空间作用域	     namespace::name
---------------------------------------------------
		  左    .           成员选择           object.member
		  左    ->			成员选择		     pointer->member
		  左    []			  下标            expr[expr]
		  左    ()           函数调用		     name(expr_list)
		  左    ()			 类型构造			 type(expr_list)
---------------------------------------------------
		  右    ++          后置递增运算		 lvalue++
		  右    --          后置递减运算        lvalue--
		  右  typeid          类型ID	         typeid(type)
	      右  typeid			运行时类型ID	     typeid(expr)
          右 explicit cast    类型转换         cast_name<type>(expr)
---------------------------------------------------
		  右     ++			前置递增运算       ++lvalue
		  右     --          前置递减运算      --lvalue
	 	  右     ~             位求反         ~expr
		  右     !		       逻辑非        !expr
		  右     -            一元负号        -expr
		  右     +            一元正号        +expr
		  右     *             解引用         *expr
		  右     &             取地址         &lvalue
		  右     ()            类型转换        (type)expr
		  右    sizeof         对象的大小      sizeof expr
          右    sizeof         类型的大小      sizeof(type)
		  右    Sizeof...      参数包的大小     sizeof...(name)
		  右     new           创建对象        new type
          右     new[]         创建数组        new type[size]
		  右     delete        释放对象        delete expr
          右     delete[]      释放数组        delete[] expr
          右     noexcept     能否抛出异常      noexcept(expr)  
---------------------------------------------------
		  左     ->*         指向成员选择的指针  ptr->*ptr_to_member
          左      .*         指向成员选择的指针  obj.*ptr_to_member
---------------------------------------------------
	      左     *                乘法         expr*expr
		  左     /                除法         expr/expr
		  左     %              取摸(取余）     expr%expr
---------------------------------------------------
		  左     +                 加法        expr+expr
          左     -                 减法        expr-expr
---------------------------------------------------
		  左     <<               向左移位      expr<<expr
		  左     >>               向右移位      expr>>expr
---------------------------------------------------
          左     <                  小于       expr<expr
          左     <=                小于等于     expr<=expr
          左     >                   大于      expr>expr
          左     >=                 大于等于    expr>=expr
---------------------------------------------------
		  左     ==                  相等      expr==expr
          左     !=                 不相等     expr!=expr
---------------------------------------------------
		  左     &                    位与     expr&expr
          左     ^                   位异或    expr^expr
		  左     |                    位或     expr|expr
---------------------------------------------------
		  左     &&                   逻辑与   expr&&expr
		  左     ||                   逻辑或   expr||expr
---------------------------------------------------
          右     ?:                    条件    expr?expr:expr
---------------------------------------------------
          右     =                     赋值    lvalue=expr
----------------------------------------------------
          右    *=,/=,%=             复合赋值   lvalue+=expr等
			    +=,-=
                <<=,>>=
				&=,|=,^=
----------------------------------------------------
		   右    throw                抛出异常  throw expr
           左     ,                   逗号     expr,expr		  			
