					第19章	特殊工具与技术
内容
--------------------------------
	19.1	控制内存分配
	19.2	运行时类型识别
	19.3	枚举类型
	19.4	类成员指针
	19.5	嵌套类
	19.6	union:一种节省空间的类
	19.7	局部类
	19.8	固有的不可移植的特性
--------------------------------
	本书的前三部分讨论了C++语言的基本要素，这些要素绝大多数程序员都会用到。此外，C++还定义了一些
非常特殊的性质，对于很多程序员来说，它们一般很少会用到本章介绍的内容。
	C++语言的设计者希望它能处理各种各样的问题。因此，C++的某些特征可能对于一些特殊的应用非常重要，
而在另外一些情况下没有什么作用。本章将介绍C++语言的几种未被广泛使用的特征。

19.1	控制内存分配
	某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用于这些程序。他们常常
需要自定义内存分配的细节，比如使用过关键字new将对象放置在特定的内存空间中。为了实现这一目的，应用
程序需要重载new运算符和delete运算符以控制内存分配的过程。

19.1.1	重载new和delete
	尽管我们说能够"重载new和delete"，但是实际上重载这两个运算符与重载其他运算符的过程大不相同。
要想真正掌握重载new和delete的方法，首先要对new表达式和delete表达式的工作机理有更多了解。
	当我们使用一条new表达式时:
		//new表达式
		string *sp = new string("a value");	//分配并初始化一个string对象
		string *arr = new string[10];	//分配10个默认初始化的string对象
实际执行了三步操。第一步，new表达式调用一个名为operator　new(或者operator new[])的标准库
函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象(或者对象的数组)。第
二步，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完
成，返回一个指向该对象的指针。
	当我们使用一条delete表达式删除一个动态分配的对象时:
		delete sp;			//销毁*sp，然后释放sp指向的内存空间
		delete [] arr;		//销毁数组中的元素，然后释放对应的内存空间
实际执行了两步操作。第一步，对sp所指的对象或者arr所指的数组中元素执行对应的析构函数。第二步，编
译器调用名为operator delete(或者operator delete[])的标准库函数释放内存空间。
	如果应用程序希望空间内存分配的过程，则它们需要定义自己的operator　new函数和operator 
delete函数。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。编译器不会对这种
重复定义提出异议。相反，编译器将使用我们自定义的版本替换标准库定义的版本。
注意:
	当自定义了全局的operator new函数和operator　delete函数后，我们就担负起了控制动态内存分
配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。
应用程序可以在全局作用域中定义operator new函数和operator delete函数，也可以将它们定义为
成员函数。当编译器发现一条new表达式或delete表达式后，将在程序查找可供调用的operator函数。如果
被分配(释放)的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有operator new
成员或operator delete成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域查找匹配的
函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没有
找到，则使用标准库定义的版本。
	我们可以使用作用域运算符令new表达式或delete表达式忽略定义在类中的函数，直接执行全局作用域
中的版本。例如，::new只在全局作用域中查找匹配的operator　new函数，::delete与之类似。

operator new接口和operator delete接口
	标准库定义了operator new函数和operator delete函数的8个重载版本。其中前四个版本可能抛
出bad_alloc异常，后四个版本则不会抛出异常:
		//这些版本可能抛出异常
		void *operator new(size_t);		//分配一个对象
		void *operator new[](size_t);	//分配一个数组
		void *operator delete(void *)noexcept;	//释放一个对象
		void *operator delete[](void *)noexcept;//释放一个数组

		//这些版本承诺不会抛出异常
		void *operator new(size_t,nothrow_t &) noexcept;
		void *operator new[](size_t,nothrow_t &)noexcept;
		void *operator delete(size_t,nothrow_t &)noexcept;
		void *operator delete[](size_t,nothrow_t &)noexcept;
类型nothrow_t是定义在new头文件中的一个struct，在这个类型中不包含任何成员。new头文件还定义了一
个名为nothrow的const对象，用户可以通过这个对象请求new的非抛出版本。与析构函数类似，operator 
delete也不允许抛出异常。当我们重载这些运算符时，必须用noexcept异常说明符指定其不抛出异常。
	应用程序可以自定义上面的函数版本中任意一个，前提是自己定义的版本必须位于全局作用域或者类的作用
域中。当我们将上述运算符函数定义成类的成员时，它们是隐式静态的。我们无须显示地声明static，当然这
么做也不会引发错误。因为operator　new用在对象构造之前而operator delete用在对象销毁之后，
所以这两个成员(new和delete)必须是静态的，而且他们不能操作类的任何数据成员。
	对于operator new函数或者operator new[]函数来说，它的返回类型必须是void *，第一个形参的
类型必须是size_t且该形参不能含有默认实参。当我们为一个对象分配空间时使用operator new；为一个数
组分配空间时使用operator new[]。当编译器使用operator new时，把存储指定类型对象所需的字节
数传递给size_t形参；当调用operator new[]时，传入函数的则是存储数组所有元素所需的空间。
	如果我们想要自定义operator new函数，则可以为它提供额外的形参。此时，用到这些自定义函数的
new表达式必须用new的定位形式将实参传递给新增的形参。尽管在一般情况下我们可以自定义具有任何形参的
operator new，但是，下面这个函数却无论如不能被用户重载:
		void *operator new(size_t,void *);	///不允许被重新定义这个版本
这种形式只提供标准库使用，不能被用户重新定义。
	对于operator delete函数或者operator delete[]函数来说，它们的返回类型必须是void，第
一个形参的类型必须是void *。执行一条delete表达式将调用相应的operator函数，并用指向待释放内存
的指针来初始化void *形参。
	当我们将operator delete或operator delete[]定义成类的成员时，该函数可以包含另外一个类型
为size_t的形参。此时，该形参的初始值是第一个形参所指对象的字节数。size_t形参用于可删除继承体系
中的对象。如果基类有一个虚析构函数，则传递给operator delete的字节数将因为删除指针所指对象的动态
类型不同而有所区别。而且，实际运行的operator　delete函数版本也由对象的动态类型决定。
术语:new表达式与operator new函数
	标准库函数operator new和operator delete的名字容易让人误解。和其他operator函数不同(比如
operator=)。这两个函数并没有重载new表达式或delete表达式。实际上，我们根本无法自定义new表达式
或delete表达式的行为。
	一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然后在得到的内存空间中构
造对象。与之相反，一条delete表达式的执行过程总是先销毁对象，然后调用operator delete函数释放对象
所占的空间。
	我们提供新的operator new函数和operator delete函数的目的在于改变内存分配的方式，但是不管
怎样，我们都不能改变new运算符和delete运算符的基本含义。

malloc函数和free函数
	当你定义了自己的全局operator new和operator delete后，这两个函数必须以某种方式执行分配
内存与释放内存的操作。也许你的初衷仅仅是使用一个特殊定制的内存分配器。但是这两个函数还应该同时满足
某些测试目的。即检验其分配内存的方式是否与常规方式类似。
	为此我们可以使用名为malloc和free的函数，C++从C语言继承了这些函数，并将其定义在cstdlib头
文件中。
	malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。
free函数接受一void *，它是malloc返回的指针的副本，free将相关的内存返回给系统，调用free(0)
没有任何意义。
	如下所示是编写operator new和operator delete的一种简单方式，其它版本与之类似:
		void *operator new(size_t size){
			if(void *mem = malloc(size))
				return mem;
			else
				throw bad_alloc();
		}
		void operator delete(void *mem)noexcept {
			free(mem);
		}

19.1.2	定位new表达式
	尽管operator new函数和operator delete函数一般用于new表达式，然而它们毕竟是标准库的两个
的函数，因此普通的代码也可以直接调用它们。在C++早期的版本中，alloctor类还不是标准库的一部分。应用
程序如果想把内存分配与初始化分离开来的话，需要调用operator new和operator delete。这两个函数
的行为与allocator的allocate成员和deallocate成员非常类似。他们负责分配或释放内存空间，但是
不会构造或销毁对象。
	与allocator不同的是，对于operator new分配的内存空间来说我们无法使用construct函数构造
对象。相反，我们应该使用new的定位new形式构造对象。如我们所见，new的这种形式为分配函数提供了额外
的信息。我们可以定位new传递一个地址，此时定位new的形式如下所示:
		new (place_address) type
		new (place_address) type(initializers)
		new (place_address) type[size]
		new (place_address) type[size] {braced initializer list}
其中place_address必须是一个指针，同时在initializers中提供一个(可能为空的)以逗号分隔的初始值
列表，该初始值列表将用于构造新分配的对象。
	当仅通过一个地址调用时，定位new使用operator new(size_t,void*)分配它的内存。这是一个
我们无法自定义的operator new版本。该函数不分配任何内存，它只是简单的返回指针实参；然后由new
表达式负责在指定的地址初始化对象以完成整个工作。事实上，定位new允许我们在一个特定的，预先分配
的内存地址上构造对象。
注意:
	当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配对象。
尽管在很多时候使用定位new与allocator的construct成员非常类似，但在他们之间也有一个重要的区别。
我们传给construct的指针必须指向同一个allocator对象分配的空间，但是传给定位new的指针无须指向
operator new分配的内存。实际上如我们将在19.6节介绍的，传给定位new表达式的指针甚至不需要指向
动态内存。

显示的析构函数调用
	就像定位new与使用allocate类似一样，对析构函数的显示调用也与使用destroy很类似。我们既可
以通过对象调用析构函数，也可以通过对象的指针或引用调用析构函数，这与调用其他成员函数没什么区别:
				string *sp = new string("a value");	//分配并初始化一个string对象
				sp->~string();
在这里我们直接调用了一个析构函数。箭头运算符解引用指针sp以获得sp所指的对象，然后我们调用析构函
数，析构函数的形式是波浪线(~)加上类型的名字。
	和调用destroy类似，调用析构函数可以清除给定的对象但是不会释放该对象所在的空间。如果需要的
话，我们可以重新使用该空间。
注意:
	调用析构函数会销毁对象，但是不会释放内存。

19.2	运行时类型识别
	运行时类型识别(RTTI)的功能由两个运算符实现:
		>>>	typeid运算符，用于返回表达式的类型
		>>>	dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用
当我们将这两个运算符用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所
绑定对象的动态类型。
	这两个运算符特别适用于以下情况:我们想使用基类对象的指针或引用执行某个派生类操作并且该操作
不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义为虚函数时，编译器将根据对
象的动态类型自动地选择正确的函数版本。
	然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个RTTI运算符。
另一方面，与虚成员函数相比，使用RTTI运算符蕴含着更多潜在的风险:程序员必须清楚的知道转换目标类
型并且必须检查类型转换是否成功执行。
注意:
	使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。

19.2.1	dynamic_cast运算符
	dynamic_cast运算符(dynamic_cast operator)的使用形式如下所示:
		dynamic_cast<type*>(e)
		dynamic_cast<type&>(e)
		dynamic_cast<type&&>(e)
其中，type必须是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个
有效的指针；在第二种形式中，e必须是一个左值；在第三章形式中，e不能是左值。
	在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：e的类型是目标type的公有派生
类、e的类型是目标type的公有基类或者e的类型就是目标type。如果符合，则类型转换可以成功。否则
，转换失败。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标
是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。

指针类型的dynamic_cast
	举个简单的例子，假定Base类至少含有一个虚函数，Derived是Base的公有派生类。如果有一个
指向Base的指针bp，则我们可以在运行时将它转换成指向Derived的指针，具体代码如下:
			if(Derived *dp = dynamic_cast<Derived*>(bp))
			{
				//使用dp指向的Derived对象
			}
			else{
					//bp指向一个Base对象
					//使用bp指向的Base对象
			}
如果bp指向Derived对象，则上述的类型转换初始化dp并令其指向bp所指的Derived对象。此时，if语
句内部使用Derived操作的代码是安全的。否则，类型转换的结果为0，dp为0意味着if语句的条件失败，
此时else子句执行的Base操作。
注意:
	我们可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。
值得注意的一点是，我们在条件部分定义了dp，这样做的好处是可以在一个操作中同时完成类型转换和条件
检查两项任务。而且，指针dp在if语句外部是不可访问的。一旦转换失败，即使后续的代码忘了做相应的
判断，也不会接触到这个未绑定的指针，从而确保程序是安全的。
注意:
	在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。

引用类型的dynamic_cast
	引用类型的dynamic_cast与指针类型的dynamic_cast在表示错误发生的方式上略有不同。因为，
不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对引用的
类型转换失败时，程序抛出一个名为std::bad_cast的异常，该异常定义在ypeinfo标准库头文件中。
	我们可以按照如下形式改写之前的程序，令其使用引用类型:
			void f(const Base &b){
				try{
					const Derived &d = dynamic_cast<Derived &>(b);
					//使用b引用的Derived对象
				}catch(bad_cast){
					//处理类型转换失败的情况
				}
			}

19.2.2 typeid运算符
	为RTTI提供的第二个运算符是typeid运算符，它允许程序向表达式提问：你的对象是什么类型？
typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字。typeid操作的结果是
一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。
type_info类定义在typeinfo头文件中，19.2.4节中将介绍更多关于type_info的细节。
	typeid运算符可以作用于任意类型的表达式。和往常一样，顶层const被忽略，如果表达式是一
个引用，则typeid返回该引用所引对象的类型。不过当typeid作用于数组或函数时，并不会执行向
指针的标准类型转换。也就是说，如果我们对数组a执行typeid(a)，则所得的结果是数组类型而非
指针类型。
	当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象
的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求
得。

使用typeid运算符
	通常情况下，我们使用typeid比较两条表达式的类型是否相同，或者比较一条表达式的类型是否
与指定类型相同:
			Derived *dp = new Derived;
			Base *bp = dp;	//两个指针都指向Derived对象
			//在运行时比较两个对象的类型
			if(typeid(*bp) == typeid(*dp)){
				//bp和dp指向同一类型的对象
			}
			//检查运行时类型是否是某种指定的类型
			if(typeid(*bp) == typeid(Derived)){
				//bp实际指向Derived对象
			}
在第一个if语句中，我们比较bp和dp所指的对象的动态类型是否相同。如果相同，则条件成功。类似
的，当bp当前所指的是一个Derived对象时，第二个if语句的条件满足。
	注意，typeid应该作用于对象，因此我们使用*bp而非bp:
			//下面的检查永远是失败的:bp的类型是指向Base的指针
			if(typeid(bp) == typeid(Derived)){
				//此处的代码永远不会执行
			}
这个条件比较的类型是Base *和Derived。尽管指针所指的对象类型是一个含有虚函数的类，但是指
针本身并不是一个类类型的对象。类型Base *将在编译时求值，显然它与Derived不同，因此不论bp
所指的对象到底是什么类型，上面的条件都不会满足。
注意:
	当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型。
typeid是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表
达式求值。反之，如果类型不含有虚函数，则typeid返回表达式的静态类型；编译器无须对表达式
求值也能知道表达式的静态类型。
	如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返回的类型。
这条规则适用于typeid(*p)的情况。如果指针p所指的类型不含有虚函数，则p不必非得是一个有效
的指针。否则，*p将在运行时求值，此时p必须是一个有效的指针。如果p是一个空指针，则typeid
(*p)将抛出一个名为bad_typeid的异常。

19.2.3	使用RTTI
	在某些情况下RTTI非常有用，比如当我们想为具有继承关系的类实现相等运算符时。对于两个
对象来说，如果它们的类型相同并且对应的数据成员取值相同，则我们说这两个对象是相等的。在类
的继承体系中，每个派生类负责添加自己的数据成员，因此派生类的相等运算符必须把派生类的新成
员考虑起来。
	一种容易想到的解决方案是定义一套虚函数，令其在继承体系的各个层次上分别执行相等性判断。
此时，我们可以为基类的引用定义一个相等运算符，该运算符将它的工作委托给函数equal，由equal
负责实际的操作。
	遗憾的是，上述方案是很难奏效。虚函数的基类版本和派生类版本必须具有相同的形参类型。如果
我们想定义一个虚函数equal，则该函数的形参必须是基类的引用。此时，equal函数将只能使用基类
的成员，而不能比较派生类独有的成员。
	要想实现真正有效的相等比较操作，我们需要首先明白一个事实：即如果参与比较的两个对象类型
不同，则比较结果为false，例如，如果我们试图比较一个基类对象和一个派生类对象，则==运算符应
该返回false。
	基于上述推论，我们就可以使用RTTI解决问题了。我们定义的相等运算符的形参是基类的引用，
然后使用typeid检查两个运算对象的类型是否一致。如果运算对象的类型不一致，则==返回false；
类型一致才调用equal函数。每个类定义的equal函数负责比较类型自己的成员。这些运算符接受Base
&形参，但是在进行比较操作前先把运算对象转换成运算符所属的类类型。

类的层次关系
	为了更好的解释上述概念，我们定义两个示例类:
			class Base{
				friend bool operator==(const Base &,const Base &);
			public:
				//Base的接口成员
			protected:
				virtual bool equal(const Base&)const;
			};
			class Derived : public Base{
			public:
				//Derived的其他成员
			protected:
				bool equal(const Base &)const;
				//Derived的数据成员并和其他用于实现的成员
			};

类型敏感的相等运算符
	接下来介绍我们是如何定义整体的相等运算符的:
			bool operator==(const Base &lhs,const Base &rhs){
				//如果typeid不相同，返回false，否则虚调用equal
				return typeid(lhs)==typeid(rhs) && lhs.equal(rhs);
			}
在这个运算符中，如果运算对象的类型不同则返回false。否则，如果运算对象的类型相同，则运算符
将其工作委托给虚函数equal。当运算对象是Base的对象时，调用Base::equal；当运算对象是Derived
的对象时，调用Derived::equal。注意这里的一个细节：首先是先判断类型是否一样，然后再使用
equal。这里使用了&&的短路性质来的。

虚equal函数
	继承体系中的每个类必须定义自己的equal函数。派生类的所有函数还要做的第一件事都是相同
的，那就是将实参的类型转换为派生类类型:
			bool Derived::equal(const Base &rhs)const{
				//我们清楚这两个类型是相等的，所以转换过程不会抛出异常
				auto r = dynamic_cast<const Derived &>(rhs);
				//执行比较两个Derived对象的操作并返回结果
			}
上面的类型转换永远不会失败，因为毕竟我们只有在验证了运算对象的类型相同后才会调用该函数。然
而这样的类型转换是必不可少的，执行了类型转换后，当前函数才能访问右侧运算对象的派生类成员。

基类equal函数
	下面这个操作比其他的稍微简单一点:
			bool Base::equal(const Base &rhs)const{
				//执行比较Base对象的操作
			}
无须事先转换形参的类型。*this和形参都是Base对象，因此当前对象可用的操作对于形参类型同样
有效。

19.2.4	type_info类
	type_info类的精确定义随着编译器的不同而略有差异。不过，C++标准规定type_info类必须
定义在typeinfo头文件中，并且至少提供表19.1所列的操作。
				表19.1:		type_info的操作
		t1 == t2			如果type_info对象t1和t2表示同一种类型，返回true；否则
							返回false
		t1 != t2			如果type_info对象t1和t2表示不同的类型，返回true；否则
							返回false
		t.name()			返回一个C风格字符串，表示类型名字的可打印形式。类型名字的
							生成方式因系统而异
		t1.before(t2)		返回一个bool值，表示t1是否位于t2之前。before所采用的顺
							序关系是依赖于编译器的
除此之外，因为type_info类一般是作为一个基类出现，所以它还应该提供一个公有的虚析构函数。当
编译器希望提供额外的类型信息时，通常在type_info的派生类中完成。
	type_info类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义成删除的。
因此，我们无法定义或拷贝type_info类型的对象，也不能为type_info类型的对象赋值。创建type_info
对象唯一的途径是使用typeid运算符。
	type_info类的name成员函数返回一个C风格字符串，表示对象的类型名字。对于某种给定的类型
来说，name的返回值因编译器而异并且不一定与在程序中使用的名字一致。对于name返回值的唯一要求
是，类型不同则返回的字符串必须有所区别。例如:
		int arr[10];
		Derived d;
		Base *p = &d;
		cout << typeid(42).name()<<", "<< typeid(arr).name()<<", "
			 << typeid(Sales_data).name()<<", "<<typeid(std::string).name()<<","
			 << typeid(p).name()<<", "<<typeid(*p).name()<<endl;
		在本书的作者的计算机上运行的结果是:
				i,A10_i,10Sales_data,Ss,P4Base,7Derived
注意:
	type_info类在不同的编译器上有所区别。有的编译器提供了额外的成员函数以提供程序中所用类型
的额外信息。读者应该仔细阅读你所用编译器的使用手册，从而获取关于type_info的更多细节。

19.3	枚举类型
	枚举类型使我们可以将一组整型常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举
属于字面值常量类型。
	C++包含两种枚举：限定作用域的和不限定作用域的。C++11新标准引入了限定作用域的枚举类型。
定义限定作用域的枚举类型的一般形式是:首先是关键字enum class(或则等价的使用enum struct)，
随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员列表，最后是一个分号：
			enum class open_modes { input,output,append};
我们定义了一个名为open_mode的枚举类型，它包含了三个枚举成员:input,output,append。
	定义不限定作用域的枚举类型时省略掉关键字class或struct，枚举类型的名字是可选的:
			enum color{red,yellow,green};		//不限定作用域的枚举类型
			//未命名的、不限定作用域的枚举类型
			enum {floatPrec = 6,doublePrec=10,double_doublePrec=10};
如果enum是是未命名的，则我们只能在定义该enum时定义它的对象。和类的定义类似，我们需要在
enum定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表。

枚举成员
	在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外
是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域
相同:
			enum color{red,yellow,green};		//不限定作用域的枚举类型
			enum stoplight{red,yellow,green};	//错误：重复定义了枚举成员
			enum class peppers{red,yellow,green};//正确:枚举成员被隐藏了
			color eyes = green;		//正确：不限定作用域的枚举类型的枚举成员位于有效的作用域中
			peppers p = green;		//错误：peppers的枚举成员不在有效的作用域中
									//color::green在有效作用域中，但是类型错误
			color hair = color::red;		//正确：允许显示地访问枚举成员
			peppers p2 = peppers::red;		//正确：使用peppers的red
默认情况下，枚举值从0开始，依次加1。不过我们也能为一个或几个枚举成员指定专门的值:
			enum class intTypes{
				charTyp = 8,shortTyp = 16,intTyp = 16,
				longTyp = 32,long_longTyp = 64
			};
由枚举成员intTyp和shortTyp可知，枚举值不一定唯一。如果我们没有显示地提供初始值，则当前
枚举成员的值等于之前枚举成员的值加1。
	枚举成员是const，因此在初始化枚举成员时提供的初始值必须是常量表达式。也就是说，每个
枚举成员本身是就是一条常量表达式，我们可以在任何需要常量表达式的地方使用枚举成员。例如，我
们可以定义枚举类型的constexpr变量:
			constexpr intTypes charbits = intTypes::charTyp;
类似的，我们也可以将一个enum作为switch语句的表达式，而将枚举值作为case标签。出于同样的
原因，我们还可以将枚举类型作为一个非类型模板形参使用；或者在类的定义中初始化枚举类型的静态
数据成员。

和类一样，枚举也定义新的类型
	只要enum有名字，我们就能定义并初始化该类型的成员。要想初始化enum对象或者作为enum
对象赋值，必须使用该类型的一个枚举成员或者该类型的另一对象:
			open_modes om = 2;	//错误：2不属于类型open_modes
			om = open_modes::input;	//正确:input是open_modes的一个枚举成员
一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。因此，我们可以在任何需要整型
值的地方使用他们:
			int i = color::red;		//正确：不限定作用域的枚举类型的枚举成员隐式
									//地转换成int
			int j = peppers::red;	//错误：限定作用域的枚举类型不会进行隐式转换！！！！

指定enum的大小
	尽管在每个enum都定义了唯一的类型，但实际上enum是由某种整数类型表示的。在C++11新标准
中，我们可以在enum的名字后加上冒号以及我们想在该enum中使用的类型:
			enum intValues : unsigned long long {
				charTyp = 255,shortTyp = 65535,intTyp = 65535,longType=4294967295UL,
				long_longTyp = 18446744073709551615ULL
			};
如果我们没有指定enum的潜在类型，则默认情况下限定作用域的enum成员类型是int。对于不限定作
用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能够容纳
枚举值。如果我们指定了枚举成员的潜在类型（包括对限定作用域的enum的隐式指定），则一旦某个枚
举成员的值超出了该类型所能容纳的范围，将引发程序错误。
	指定enum潜在类型的能力使得我们可以控制不同实现环境中使用的类型，我们将可以确保在一种
实现环境中编译通过的程序所生成的代码与其他实现环境中生成的代码一致。

枚举类型的前置声明
	在C++11新标准中，我们可以提前声明enum。enum的前置声明（无论隐式地还是显示地）必须
指定其成员的大小：
			//不限定作用域的枚举类型intValues的前置声明
			enum intValues : unsigned long long;	//不限定作用域的，必须指定成员
													//类型
			enum class open_modes;		//限定作用域的枚举类型可以使用默认成员类型int
因为不限定作用域的enum未指定成员的默认大小，因此每个声明必须指定成员的大小。对于限定作用域的
enum来说，我们可以不指定其成员的大小，这个值被隐式地定义成int。
	和其他声明语句一样，enum的声明必须和定义必须匹配，这意味着在该enum的所有声明和定义中成
员的大小必须一致。而且，我们不能在同一个上下文中先声明一个不限定作用域的enum名字，然后在声明
一个同名的限定作用域的enum:
			//错误：所有的声明和定义必须对该enum是限定作用域的还是不限定作用域的保持一致。
			enum class intValues;
			enum intValues;				//错误：intValues已经被声明成限定作用域的enum
			enum intValues : long;		//错误:intValues已经被声明成int

形参匹配与枚举类型
	要想初始化一个enum对象，必须使用该enum类型的另一个对象或者它的一个枚举成员。因此，即使
某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参使用:
			//不限定作用域的枚举类型，潜在类型因机器而异
			enum Tokens { INLINE = 128,VIRTUAL = 129};
			void ff(TOkens);
			void ff(int);
			int main(){
				Tokens curTok = INLINE;
				ff(128);			//精确匹配ff(int);
				ff(INLINE);			//精确匹配ff(Tokens)
				ff(curTok);			//精确匹配ff(Tokens)
				return 0;
			}
尽管我们不能直接将整型值传递给enum形参，但是可以将一个不限定作用域的枚举类型的对象或枚举成员
传给整型形参。此时，enum的值提升成int或更大的整型，实际提升的结果由枚举类型的潜在类型决定:
			void newf(unsigned char);
			void newf(int);
			unsigned char uc = VIRTUAL;
			newf(VIRTUAL);				//调用newf(int)
			newf(uc);					//调用newf(unsigned char)
枚举类型Tokens只有两个枚举成员，其中较大的那个值是129。该枚举类型可以用unsigned char
来表示，因此很多编译器使用unsigned char作为Tokens的潜在类型。不管Tokens的潜在类型到底
是什么，它的对象和枚举成员都提升成int。尤其是，枚举成员永远不会提升成unsigned char，即
使枚举值可以用unsigned char存储也是如此。

19.4	类成员指针
	成员指针是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示
的是类的成员，而非类的对象。类的静态成员不属于任何对象，因此，无须特殊的指向静态成员的指针，
指向静态成员的指针与普通指针没有什么区别。
	成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的
某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。
	为了解释成员指针的原理，不妨使用7.3.1节的Screen类:
			class Screen{
			public:
				typedef std::string::size_type pos;
				char get_cursor() const {return contents[cursor];}
				char get()const;
				char get(pos ht,pos wd)const;
			private:
				std::string contents;
				pos cursor;
				pos height,width;
			};
19.4.1	数据成员指针
	和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。与普通指针不
同的是，成员指针还必须包含成员所属的类。因此，我们必须在*之前添加classname::以表示当前定义
的指针可以指向classname的成员。例如:
			//pdata可以指向一个常量(非常量)Screen对象的string成员
			const string Screen::*pdata;
上述语句将pdata声明成"一个指向Screen类的const string成员的指针"。常量对象的数据成员本身
也是常量，因此，将我们的指针声明成指向const string成员的指针意味着pdata可以指向任何Screen
对象的一个成员，而不管该Screen对象是否是常量。作为交换条件，我们只能使用pdata读取它所指的成
员，而不能向它写入内容。
	当我们初始化一个成员指针(或者向它赋值)时，需指定它所指的成员。例如，我们可以令pdata指向
某个非特定Screen对象的contents成员:
			pdata = &Screen::contents;
其中，我们将取地址运算符作用于Screen类的成员而非内存中的一个该类对象。当然，在C++11新标准中
声明成员指针最简单的方法是使用auto或decltype：
			auto pdata = &Screen::contents;
注意:
	一个成员指针，必须要包含两个属性：首先第一个是所属于那个类的成员的指针；第二个就是你这个
成员指向的类型是什么。也就是类的类型以及成员的类型！！！
使用数据成员指针
	读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。
成员指针指定了成员而非该成员所属的对象。只有当解引用成员指针时我们才提供对象的信息。
	与成员访问运算符.和->类似，也有两种成员指针访问运算符：.*和->*，这两个运算符使的我们可以
解引用指针并获得该对象的成员:
			Screen myScreen,*pScreen = &myScreen;
			//.*解引用pdata以获得myScreen对象的contents成员
			auto s = myScreen.*pdata;
			//->*解引用pdata以获得pScreen所指对象的contents成员
			s = pScreen->*pdata;
从概念上来说，这些运算符执行两步操作：它们首先解引用成员指针以获得所需的成员：然后像成员访问运算
符一样，通过对象(.*)或指针(->*)获取成员。
注意:
	其实初始化的时候，只是让成员指针指向了类的某个数据成员，但是使用的时候，你必须得明确指出
这个成员是类的哪个对象的数据成员！！所以.*和->*其实就是调用相应的指针指向的成员。
返回数据成员指针的函数
	常规的访问控制规则对成员指针同样有效。例如，Screen的contents成员是私有的，因此，之前对
于pdata的使用必须位于Screen类的成员或友元内部，否则程序将发生错误。
	因为数据成员一般情况下是私有的，所以我们通常不能直接获得数据成员的指针。如果一个像Screen这
样的类希望我们可以访问它的contens成员，最好定义一个函数，令其返回值是指向该成员的指针:
			class Screen{
			public:
				//data是一个静态成员，返回一个成员指针
				static const std::string Screen::*data(){
					return &Screen::contents;
				}
				//其他成员与之前的版本一致。
			};
我们为Screen类添加了一个静态成员，令其返回指向contents成员的指针。显然该函数的返回类型与最初
的pdata指针类型一致。从右向左阅读函数的返回类型，可知data返回的是一个指向Screen类的const string
成员的指针。函数体对contents成员使用了取地址运算符，因此函数将返回指向Screen类contents成员
的指针。
	当我们调用data函数时，将得到一个成员指针:
			//data()返回一个指向Screen类的contents成员的指针
			const string Screen::*pdata = Screen::data();
一如往常，pdata指向Screen类的成员而非实际数据。要想使用pdata，必须把它绑定到Screen类型的对
象上：
			//获得myScreen对象的contents成员
			auto s = myScreen.*pdata;

19.4.2	成员函数指针
	我们也可以定义指向类的成员函数的指针。与指向数据成员的指针类似，对于我们来说要想创建一个指
向成员函数的指针，最简单的方法就是使用auto来判断类型:
			//pmf是一个指针，它可以指向Screen的某个常量成员函数
			//前提是该函数不接受任何实参，并且返回一个char
			auto pmf = &Screen::get_cursor;
和指向数据成员的指针一样，我们使用classname::*的形式声明一个指向成员函数的指针。类似于任何其
他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表。如果成员函数是const成员
或者引用成员，则我们必须将const限定符或引用限定符包含进来。
	和普通的函数指针类似，如果成员存在重载的问题，则我们必须显示地声明函数类型以明确指出我们
想要使用哪个函数。例如，我们可以声明一个指针，令其指向含有两个形参的get:
			char (Screen::*pmf2)(Screen::pos,Screen::pos)const;
			pmf2 = &Screen::get;
出于优先级考虑，上述声明中Screen::*两端的括号必不可少。如果没有这对括号的话，编译器将认为该
声明是一个（无效的）函数声明:
			//错误：非成员函数p不能使用const限定符
			char Screen::*p(Screen::pos,Screen::pos)const;
这个声明试图定义一个名为p的普通函数，并且返回Screen类的一个char成员。因为它声明的是一个普通
函数，所以不能使用const限定符。
	和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则:
			//pmf指向一个Screen成员，该成员不接受任何实参且返回类型是char
			pmf = &Screen::get;		//必须显示地使用取地址运算符
			pmf = Screen::get;		//错误:在成员函数和指针之间不存在自动转换规则

使用成员函数指针
	和使用指向数据成员的指针一样，我们使用.*或者->*运算符作用于指向成员函数的指针，以调用
类的成员函数：
			Screen myScreen,*pScreen = &myScreen;
			//通过pScreen所指的对象调用pmf所指的函数
			char c1 = (pScreen->*pmf)();
			//通过myScreen对象将实参0,0传给含有两个形参的get函数
			char c2 = (myScreen.*pmf2)(0,0);
之所以(myScreen->*pmf)()和(pScreen.*pmf2)(0,0)的括号必不可少，原因是调用运算符优先级
要高于指向成员运算符的优先级。
	假设去掉括号的话，
			myScreen.*pmf();
其含义将等同于下面的式子:
			myScreen.*(pmf())
这行代码的意思是调用一个名为pmf的函数，然后使用该函数的返回值作为指针指向成员运算符(.*)的运
算对象。然而pmf并不是一个函数，因此代码将发生错误。
注意：
	因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这样的指针进行函数调用
时，括号必不可少：(C::*P)(parms)和(obj.*p)(args)。

使用成员指针的类型别名
	使用类型别名或typedef可以让成员指针更容易理解。例如，下面的类型别名将Action定义为两参数
get函数的同义词:
			//Action是一种可以指向Action成员函数的指针，它接受两个pos实参，返回一个char
			using Action = char (Screen::*)(Screen::pos,Screen::pos) const;
Action是某类型的另外一个名字，该类型是"指向Screen类的常量成员函数指针，其中这个成员函数
接受两个pos形参，返回一个char"。通过使用Action，我们可以简化指向get的指针定义:
			Action get = &Screen::get;		//get 指向Screen的get成员
和其他函数指针类似，我们可以将指向成员函数的指针作为某个函数的返回类型或形参类型。其中，指向成
员的指针形参也可以拥有默认实参:
			//action接受一个Screen的引用，和一个指向Screen成员函数的指针
			Screen &action(Screen &,Action=&Screen::get);
action是包含两个形参的函数，其中一个形参是Screen对象的引用，另一个形参是指向Screen成员函数
的指针，成员函数必须接受两个pos形参地址并返回一个char。当我们调用action时，只需要将Screen
的一个符合要求的函数指针或地址传入即可:
			Screen myScreen;
			//等价调用:
			action(myScreen);			//使用默认实参
			action(myScreen,get);		//使用我们之前定义的变量get
			action(myScreen,&Screen::get);	//显示地传入地址
注意:
	通过使用类型别名，可以令含有成员的指针的代码更容易读写

成员指针函数表
	对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数表当中。如果
一个类含有几个相同类型的成员，则这样一张表可以帮助我们从这些成员中选择一个。假定Screen类
含有几个成员函数，每个函数负责将光标向指定的方向移动:
			class Screen{
			public:
				//其他接口和实现成员之前一致
				Screen &home();		//光标移动函数
				Screen &forward();
				Screen &back();
				Screen &up();
				Screen &down();
			};
这几个新函数有一个共同点：它们都不接受任何参数，并且返回值是发生光标移动的Screen的引用。
	我们希望定义一个move函数，使其可以调用上面的任意一个函数并执行对应的操作。为了支持这个新
函数，我们将在Screen中添加一个静态成员，该成员是指向光标移动函数的指针的数组:
			class Screen{
			public:
				//其他接口和实现成员与之前一致
				//Action是一个指针，可以用任意一个光标移动函数对其赋值
				using Action = Screen &(Screen::*)();
				//指定具体要移动的方向，其中enum参见19.3节
				enum Directions { HOME,FORWARD,BACK,UP,DOWN};
				Screen &move(Directions);
			private:
				static Action Menu[];	//函数表
			};
数组Menu依次保存每个光标移动函数的指针，这些函数将按照Directions中枚举成员对应的偏移量
存储。move函数接受一个枚举成员并调用相应的函数:
			Screen &Screen::move(Directions cm){
				//运行this对象中索引值为cm的元素
				return (this->*Menu[cm])();		//Menu[cm]指向一个成员函数
			}
move中的函数调用的原理是:首先获取索引值为cm的Menu元素，该元素是指向Screen成员函数的指针。
我们根据this所指的对象调用该元素所指的成员函数。
	当我们调用move函数时，给它传入一个表示光标移动方向的枚举成员:
			Screen myScreen;
			myScreen.move(Screen::HOME);		//调用myScreen.home
			myScreen.move(Screen::DOWN);		//调用myScreen.down
剩下的工作就是定义并初始化函数本身了:
			Screen::Action Screen::Menu[] = {&Screen::home,&Screen::forward,
											 &Screen::back,&Screen::up,
											 &Screen::down,
											};

19.4.3	将成员函数用作可调用对象
	如我们所知，要想通过一个指向成员函数的指针进行函数调用，必须首先利用.*运算符或->*运算符
将该指针绑定到特定的对象上。因此与普通的函数指针不同，成员指针不是一个可调用对象。这样的指针
不支持函数调用运算符。
	因为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给算法。举个例子，
如果我们想在一个string的vector中找到第一个空string，显然不能使用下面的语句:
			auto fp = &string::empty;		//fp指向string的empty函数
			//错误，必须使用.*或->*调用成员指针
			find_if(svec.begin,svec.end(),fp);//fp不是可调用对象
find_if算法需要一个可调用对象，但我们提供给它的是一个指向成员函数的指针fp。因此在find_if
的内部将执行如下形式的代码，从而导致无法通过编译:
			//检查对当前元素的断言是否为真:
			if(fp(*it))		//错误L要想通过成员指针调用函数，必须使用->*运算符
显然该语句试图调用的是传入的对象，而非函数。

使用function生成一个可调用对象
	从指向成员函数的指针获取可调用对象的一种方法是使用标准库魔板function:
			function<bool(const string &) > fcn=&string::empty;
			find_if(svec.begin(),svec.end(),fcn);
我们告诉function一个事实:即empty是一个接受string参数并返回bool值的函数。通常情况下，
执行成员函数的对象将被传给隐式的this形参。当我们想要使用function为成员函数生成一个
可调用对象时，必须首先翻译该代码，使得隐式的形参变成显示的。
	当一个function对象包含一个指向成员函数的指针时，function类知道它必须使用正确的指向
成员的指针运算符来执行函数调用。也就是说，我们可以认为在find_if当中含有类似于如下形式
的代码:
			//假设it是find_if内部的迭代器，则*it是给定范围内的一个对象
			if(fcn(*it))				//假设fcn是find_if内部的一个可调用对象的名字
其中function将使用正确的指向成员的指针运算符。从本质上来看，function类将函数调用转换成了
如下形式:
			if(((*it).*p)())
当我们定义一个function对象时，必须指定该对象所能表示的函数类型，即可调用对象的形式。如果可调用
对象的形式。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个(一般是隐式的)对象上
执行的。同时，我们提供给function的形式中还必须指明对象是否以指针或引用的形式传入的。
	以定义fcn为例，我们想在string对象的序列上调用find_if，因此我们要求function生成一个接受
string对象的可调用对象。又因为我们的vector保存的是string的指针，所以必须指定function接受的
指针:
			vector<string *>pvec;
			function<bool (const string *)> fp = &string::empty;
			//fp接受一个指向string的指针，然后使用->*调用empty
			find_if(pvec.begin(),pvec.end(),fp);
			
使用mem_fn生成一个可调用对象
	通过上面的介绍可知，要想使用function，我们必须提供成员的调用形式。我们也可以采取另外一种
方法，通过使用标准库功能men_fn来让编译器负责推断成员的类型。和function一样，mem_fn也定义在
functional头文件中，并且可以从成员指针生成一个可调用对象；和function不同的是，mem_fn可以
根据成员指针的类型推断可调用对象的类型，而无须用户显示地指定:
			find_if(svec.begin(),svec.end(),mem_fn(&string::empty));
我们使用mem_fn(&string::empty)生成一个可调用对象，该对象接受一个string实参，返回一个bool
值。
	mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用:
			auto f = mem_fn(&string::empty);		//f接受一个string或者一个string *
			f(*svec.begin());			//正确：传入一个string对象，f使用.*调用empty
			f(&svec[0]);				//正确：传入一个string的指针，f使用->*调用empty
实际上，我们可以认为mem_fn生成的可调用对象含有一对重载的函数调用运算符:一个接受string*,另一个
接受string&。

使用bind生成一个可调用对象
	出于完整性的考虑，我们还可以使用bind从成员函数生成一个可调用对象:
			//选择范围中的每个string，并将其bind到empty的第一个隐式实参上
			auto it = find_if(svec.begin(),svec.end(),bind(&string::empty,_1));
和function类似的地方是，当我们使用bind时，必须将函数中用于执行对象的隐式形参转换成显示的。和mem_fn
类似的地方是，bind生成的可调用对象的第一个实参既可以是string的指针，也可以是string的引用:
			auto f = bind(&string::empty,_1);
			f(*svec.begin());		//正确:实参是一个string，f使用.*调用empty
			f(&svec[0]);			//正确:实参是一个string的指针，f使用->*调用empty
			
19.5	嵌套类
	一个类可以定义在另一个类的内部，前者称为嵌套类或嵌套类型。嵌套类常用于定义作为实现部分的类，比如
我们在文本查询示例中使用的QueryResult类。
	嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套类的对象是相互独立的。在
嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层类的对象中也不包含任何嵌套类定义的成员。
	嵌套类的名字在外层作用域中是可见的，在外层类作用域之外不可见。和其他嵌套的名字一样，嵌套类的名字
不会和别的作用域中的同一个名字冲突。嵌套类中成员的种类与非嵌套类是一样的。和其他类类似，嵌套类也使用
访问限定符来控制外界对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类
的成员也没有特殊的访问权限。
	嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类决定。位于外层类
public部分的嵌套类实际上定义了一种可以随处访问的类型；位于外层protected部分的嵌套类定义的类型只
能被外层类及其友元和派生类访问；位于外层private部分的嵌套类定义的类型只能被外层类的成员和友元访问。

声明一个嵌套类
	我们为12.3.2节的TextQuery类定义了一个名为QueryResult的配套类，这两个类密切相关。QueryResult
类的主要作用是表示TextQuery对象上Query操作的结果，显然将QueryResult用作其他目的没有任何意义。
为了充分体现这种紧密的相关性，我们可以把QueryResult定义成TextQuery的成员。
			class TextQuery{
			public:
				class QueryResult;		//嵌套类稍后定义
				//其他成员与12.3.2节一致
			};
我们只需对原来的TextQuery类做一处改动，即将QueryResult声明成嵌套类。因为QueryResult是一个
类型成员，所以我们必须对它先声明后使用，有其是必须先声明QueryResult，再将它作为query成员的
返回类型。类的其他成员没有任何变化。

在外层类之外定义一个嵌套类
	我们在TextQuery内声明了QueryResult，但是没有给出它的定义。和成员函数一样，嵌套类必须
声明在类的内部，但是可以定义在类的内部或者外部。
	当我们在外层类之外定义一个嵌套类时，必须以外层类的名字限定嵌套类的名字:
			//QueryResult是TextQuery的成员，下面的代码负责定义QueryResult
			class TextQuery::QueryResult{
				//位于类的作用域内，因此，我们不必对QueryResult形参进行限定
				friend std::ostream & print(std::ostream &,const QueryResult &);
			public:
				//无须定义QueryResult::line_no
				//嵌套类可以直接使用外层类的成员，无须对该成员的名字进行限定
				QueryResult(std::string,std::shared_ptr<std::set<line_no>>,
							std::shared_ptr<std::vector<std::string>>);
				//其他成员与12.3.2节一致
			};
和原来的类相比唯一的改动是，我们无须在QueryResult内定义line_no成员了。因为该成员属于TextQuery，
所以QueryResult可以直接访问它而不必再定义一次。
注意:
	在嵌套类在其外层之外完成真正的定义之前，它都是一个不完全类型

定义嵌套类的成员
	在这个版本的QueryResult类中，我们并没有在类的内部定义其构造函数。要想为其定义构造函数，必须
指明QueryResult是嵌套在TextQuery的作用域之内的。具体做法是使用外层类的名字限定嵌套类的名字:
			//	QueryResult类嵌套在TextQuery类中
			//下面的代码为QueryResult类定义名为QueryResult的成员
			TextQuery::QueryResult::QueryResult(string s,shared_ptr<set<line_no>>p,
												shared_ptr<vector<string>>f):
										sought(s),lines(p),file(f){}
从右向左阅读函数的名字可知我们定义的是QueryResult类的构造函数，而QeuryResult类是嵌套在TextQuery
类中的。该构造函数除了把实参值赋给对应的数据成员外，没有做其他工作。

嵌套类的静态成员定义
	如果QueryResult声明了一个静态成员，则该成员的定义将位于TextQuery的作用域之外。例如，假设
QueryResult有一个静态成员，则该成员的定义将形如:
			//QueryResult类嵌套在TextQuery类中
			//下面的代码为QueryResult定义一个静态成员
			int TextQuery::QueryResult::static_mem = 1024;

嵌套类作用域中的名字查找
	名字查找的一般规则在嵌套类中同样适用。当然，因为嵌套类本身是一个嵌套作用域，所以还必须查找嵌套类
的外层作用域。这种作用域嵌套的性质正好可以说明为什么我们不在QueryResult的嵌套版本中定义line_no。
原来的QueryResult类定义了该成员，从而使其成员可以避免使用TextQuery::line_no的形式。然而
QueryResult的嵌套类版本本身就是定义在TextQuey中的，所以我们不需要再使用typedef。嵌套的QueryResult
无须说明line_no属于TextQuery就可以直接使用它。
	如我们所知，嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何其他类型成员一样使用嵌套
类的名字。因为，QueryResult嵌套在TextQuery中，所以TextQuery的query成员可以直接使用名字
QueryResult:
			//返回类型必须指明QueryResult是一个嵌套类
			TextQuery::QueryResult TextQuery::query(const string &sought)const{
				//如果我们没有找到sought，则返回set的指针
				static shared_ptr<set<line_no>>nodata(new set<line_no>);
				//使用find而非下标以避免向wm中添加单词
				auto loc = wm.find(sought);
				if(loc == wm.end())
					return QueryResult(sought,nodata,file);	//没有找到
				else
					return QueryResult(sought,loc->second,file);
			}
和过去一样，返回类型不在类的作用域中，因此我们必须指明函数的返回值是TextQuery::QueryResult类型。不过
在函数体内部我们可以直接访问QueryResult，比如上面的return语句就是这样。

嵌套类和外层类是相互独立的
	尽管嵌套类定义在其外层类的作用域中，但是读者必须谨记外层类的对象和嵌套类的对象没有任何关系。嵌套类
的对象只包含嵌套类定义的成员；同样，外层类的对象只包含外层了类定义的成员，在外层类对象中不含有任何嵌套
类的成员。
	说的再具体一些，TextQuery::query的第二条return语句
			return QueryResult(sought,loc->second,file);
使用了TextQuery对象的数据成员，而query正是用它们来初始化QueryResult对象的。因为在一个QueryResult
对象中不包含其外层类的成员，所以我们必须使用上述成员构造我们返回的QueryResult对象。

19.6	union:一种节省空间的类
	联合(union)是一种特殊的类。一个union可以有多个数据成员，但是在任意时刻只有一个数据成员可以
有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配一个union
对象的存储空间至少要能容纳它的最大的数据成员。和其他类一样，一个union定义了一种新类型。
	类的某些特性对union同样适用，但并非所有特性都如此。union不能含有引用类型的成员，除此之外，
它的成员可以是绝大多数类型。在C++11新标准中，含有构造函数或析构函数的类类型也可以作为union的成员
类型。union的成员都是公有的，这一点与struct相同。
	union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能
作为基类使用，所以在union中不能含有虚函数。

定义union
	union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值。举个例子，假设我们需要
处理一些不同类的数字数据和字符数据，则此过程中可以定义一个union来报存这些值:
			//Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种
			union Token{
				//默认情况下成员是公有的
				char cval;
				int ival;
				double dval;
			};
在定义一个union时，首先是关键字union，随后是该union的(可选的)名字以及花括号内的一组成员声明。上面的
代码定义了一个名为Token的union，它可以保存一个值，这个值的类型可能是char、int或double中的一种。

使用union类型
	union的名字是一个类型名。和其他内置类型一样，默认情况下union是未初始化的。我们可以像显示地
初始化聚合类一样使用一堆花括号内的初始值显示地初始化一个union:
			Token first_token = {'a'};			//初始化cval成员
			Token last_token;					//未初始化的Tokend对象
			Token *pt = new Token;				//指向一个未初始化的Tokend对象的指针
如果提供了初始值，则该初始值被用于初始化第一个成员。因此，first_token的初始化过程实际上是给
cval成员赋予了一个初值。
	我们使用通用的成员访问运算符访问一个union对象的成员:
			last_token.cval = 'z';
			pt->ival = 42;
为union的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用union时，必须清楚地
知道当前存储在union中的值到底是什么类型。如果我们使用错误的数据成员或者为错误的数据成员赋值，则
程序可能崩溃或出现异常行为，具体情况根据成员的类型而有所不同。

匿名union
	匿名union是一个未命名的union，并且在右花括号和分号之间没有任何声明。一旦我们定义了一个匿名
union，编译器就自动地为该union创建一个未命名的对象:
			union {
				char cavl;
				int ival;
				double dval;
			};	//定义一个未命名的对象，我们可以直接访问它的成员
			cval = 'c';			//为刚刚定义的未命名的匿名union对象赋一个新值
			ival = 42;			//该对象当前保存的值是42
在匿名union的定义所在的作用域内该Union的成员都是可以直接访问的。
注意:
	匿名union不能包含受保护的成员或私有成员，也不能定义成员函数

含有类类型成员的union
	C++的早期版本规定，在union中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11新标准
取消了这一限制。不过，如果union的成员类型定义了自己的构造函数和/或拷贝控制成员，则该union的用法
要比只含有内置类型成员的union复杂的多。
	当union包含的是内置类型的成员时，我们可以使用普通的赋值语句改变union保存的值。但是对于含有
特殊类类型成员的union就没这么简答了。|||如果我们想将union的值改为类类型成员对应的值，或者将类类
型成员的值改为一个其他值，则必须分别构造或析构该类类型的成员：当我们将union的值改为类类型成员对应
的值时，必须运行该类型的析构函数。|||||
	当union包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。但是
如果union含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为union合成对应
的版本并将其声明为删除的。
	例如，string类定义了五个拷贝控制成员以及一个默认构造函数。如果union含有string类型的成员，并且
没有自定义默认构造或某个拷贝控制成员，则编译器将合成缺少的成员并将其声明成删除的。如果在某个类中含有一
个union成员，而且该union含有删除的拷贝控制成员，则该类与之对应的拷贝控制操作也将是删除的。

使用类管理的union成员
	对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此我们通常把含有类类型成员的
union内嵌在另一个类当中。这个类可以管理并控制与union的类类型成员有关的状态转换。举个例子，我们为
union添加一个string成员，并将我们的union定义成匿名union，最后将它作为Token类的一个成员。此时，
Token类将可以管理union的成员。
	为了追踪union中到底存储了什么类型的值，我们通常会定义一个独立的对象，该对象称为union的判别式。
我们可以使用判别式辨认union存储的值。为了保持union与判别式同步，我们将判别式也作为Token的成员。
我们的类将定义一个枚举的成员来追踪其union成员的状态。
			class Token{
			public:
				//因为union含有一个string成员，所以Token必须定义拷贝控制成员
				//定义移动构造函数和移动赋值运算符的任务留待本节练习完成
				Token():tok(INT),ival{0}{}
				Token(const Token &t) : tok(t.tok){copyUinon(t);}
				Token &operator=(const Token &);
				//如果union含有一个string成员，则我们必须销毁它，
				~Token(){if(tok==STR) sval.~string();}
				//下面的赋值运算符负责设置union的不同成员
				Token &operator=(const std::string &);
				Token &operator=(char);
				Token &operator=(int);
				Token &operator=(double);
			private:
				enum {INT,CHAR,DBL,STR}tok;	//判别式
				union {//匿名union
					char cval;
					int ival;
					double dval'
					std::string sval;
				};	//每个Token对象含有一个该未命名union类型的未命名成员
				//检查判别式，然后酌情拷贝union成员
				void copyUnion(const Token&);
			};
我们的类定义了一个嵌套的、未命名的、不限定作用域的枚举类型，并将其作为tok成员的类型。其中，tok
的声明位于枚举类型定义的右侧花括号之后，以及表示该枚举类型定义结束的分号之前，因此，tok的类型就
是当前这个未命名的enum类型。
	我们使用tok作为判别式。当union存储的是一个int值时，tok的值是INT；当union存储的是一个sting值
时，tok的值是STR；依次类推。
	类的默认构造函数初始化判别式以及union成员，令其保存int值0。因为我们的union含有一个定义了析构
函数的成员，所以必须为union也定义一个析构函数以销毁string成员。和普通的类类型成员不一样，作为
union组成部分的类成员无法自动销毁。因为析构函数不清楚union存储的值是什么类型，所以它无法确定应该
销毁哪个成员。
	我们的析构函数检查被销毁的对象中是否存储着string值。如果有，则类的析构函数显示地调用string
的析构函数释放该string使用的内存；反之，如果union存储的值是内置类型，则类的析构函数什么也不做。

管理判别式并销毁string
	类的赋值运算符将负责设置tok并为union的相应成员赋值。和析构函数一样，这些运算符在为union
赋新值前必须首先销毁string:
			Token &Token::operator=(int i){
				if(tok == STR) sval.~string();		//如果当前存储的是string,释放它
				ival = i;			//为成员赋值
				tok = INT;			//更新判别式
				return *this;
			}
如果union的当前值是string，则我们必须先调用string的析构函数销毁这个string，然后再为union赋新值。
清除了string成员后，我们将给的的值赋给与运算符形参类型相匹配的成员。在此例中，形参类型是int，所以我
们赋值给ival。随后更新判别式并返回结果。
	double和char版本的赋值运算符与int赋值运算符非常相似。读者可以在本节的练习中尝试使用这两个运算符。
string版本与其他几个有所区别，原因是string版本必须管理与string类型有关的转换:
			Token &Token::operator=(const std::string &s){
				if(tok == STR)
					sval = s;
				else
					new(&sval) string(s);		//需要先构造一个string
				tok = STR;
				return *this;
			}
在此例中，如果union当前存储的是string，则我们可以使用普通的string赋值运算符直接为其赋值。如果union
当前存储的不是string，则我们找不到一个已存在的string对象供我们调用赋值运算符。此时，我们必须先利用定
位new表达式在内存中为sval构造一个string，然后将该string初始化为string形参的副本，最后更新判别式并
返回结果。

管理需要拷贝控制的联合成员
	和依赖于类型的赋值运算符一样，拷贝构造函数和赋值运算符也需要先检验判别式以明确拷贝所采用的方式。为
了完成这一任务，我们定义一个名为copyUnion的成员。
	当我们在拷贝构造函数中调用copyUnion时，union成员将被默认初始化，这意味着编译器会初始化union的第
一个成员。因为string不是一个成员，所以显然union成员保存的不是string。在赋值运算符中情况有些不一样，
有可能union已经存储了一个string。我们将在赋值运算符中直接处理这种情况。copyUnion假设如果它的形参存储了
string，则它一定会构造自己的string:
			void Token::copyUnion(const Token &t){
				switch(t.tok){
					case Token::INT: ival = t.ival;break;
					case Token::CHAR: cval=t.cval;break;
					case Token::DBL: dval = t.dval;break;
					//要想拷贝一个string可以使用定义new表达式构造它
					case Token::STR: new(&sval) string(t.sval); break;
					default: break;
				}
			}
该函数使用一个switch语句检验判别式。对于内置类型来说，我们把值直接赋给对应的成员；如果拷贝的是一个
string，则需要构造它。
	赋值运算符必须处理string成员的三种可能情况：左侧运算对象和右侧运算对象都是string、两个运算对象
都不是string、只有一个运算对象是string:
			Token &Token::operator=(const Token &t){
				//如果此对象的值是string而t的值不是，则我们必须释放原来的string
				if(tok == STR && t.tok != STR)sval.~string();
				if(tok == STR && t.tok = STR)
					sval = t.sval;		//无须构造一个新string
				else//如果左边的不是string
					copyUnion(t);		//如果t.tok是STR，则需要构造一个string
				tok = t.tok;
				return *this;
			}
如果作为左侧运算对象的union的值是string但右侧运算对象的值不是，则我们必须先释放原来的string
再给union成员赋一新值。如果两侧运算对象的值都是string，则我们可以使用普通的string赋值运算符完
成拷贝。否则，我们调用copyUnion进行赋值。在copyUnion内部，如果右侧运算对象是string，则我们在
左侧运算对象的union成员内构造一个新string；如果两端都不是string，则直接执行普通的赋值操作就可
以了。

19.7	局部类
	类可以定义在某个函数的内部，我们称这样的类为局部类。局部类定义的类型只在定义它的作用域内可见。
和嵌套类不同，局部类的成员受到严格限制。
注意:
	局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差
很远。
	在实际编程的过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。
局部类的成员函数一般只有几行代码，否则我们就很难读懂它了。类似的，在局部类中也不允许声明静态数据
成员，因为我们没法定义这样的成员。

局部类不能使用函数作用域中的变量
	局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域定义的类型名、静态
变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用:
			int a,val;
			void foo(int val){
				static int si;
				enum Loc{a=1024,b};
				//Bar是foo的局部类
				struct Bar{
					Loc locVal;				//正确：使用一个局部类型名
					int barVal;
					void fooBar(Loc l = a)	//正确:默认实参是Loc::a
					{
						barVal = val;	//错误：val是foo的局部变量
						barVal = ::va;l;//正确:使用一个全局对象
						barVal = si;	//正确:使用一个局部静态对象
						locVal = b;		//正确:使用一个枚举成员
					}
				};
				//....
			}
常规的访问保护规则对局部类同样适用
	外层函数对局部类的私有成员没有任何访问特权。当然，局部类可以将外层函数声明为友元；或者更常见
的情况是局部类将其成员声明为公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数作用
域中。通过信息隐藏进一步封装就显得没什么必要了。

局部类中的名字查找
	局部类内部的名字查找次序与其他类相似。在声明类的成员时，必须先确保用到的名字位于作用域中，然后
再使用该名字。定义成员时用到的名字可以出现在类的任意位置。如果某个名字不是局部类的成员，则继续在外层
函数作用域中查找；如果还没有找到，则在外层函数所在的作用域中查找。

嵌套的局部类
	可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在
与局部类相同的作用域中。
			void foo()
			{
				class Bar{
				public:
					//...
					class Nested;	//声明Netsed类
				};
				//定义Nested类
				class Bar::Netsed{
					//...
				};
			}
和往常一样，当我们在类的外部定义成员时，必须指明该成员所属的作用域。因此在上面的例子中，Bar::Nested的
意思是Nested是定义在Bar的作用域内的一个类。
	局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。嵌套类的所有成员都必须定义在嵌套类内部。
	
19.8	固有的不可移植性
	为了支持低层编程，C++定义了一些固有的不可移植性。所谓不可移植特性是指因机器而异的特性，当我们将含
有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。算术类型的大小在不同机器上
不一样，这是我们使用过的不可移植特性的一个典型示例。
	本届将介绍C++从C语言继承而来的另外两种不可移植的特性:位域和volatitle限定符。此外，我们还将介绍
链接指示，它是C++新增的一种不可移植的特性。

19.8.1	位域
	类可以将其(非静态)数据成员定义成位域，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序
或硬件设备传递二进制数据时，通常会用到位域。
注意:
	位域在内存中的布局是与机器相关的。
位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号
类型保存一个位域。位域的声明形式是在成员之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的
二进制位数:
			typedef unsigned int Bit;
			class File{
				Bit mode : 2;		//mod占2位
				Bit modified : 1;	//modified占1位
				Bit prot_owner : 3;	//prot_owner占3位
				Bit prot_group : 3;	//prot_group占3位
				Bit prot_world : 3;	//prot_world占3位
				//File的操作和数据成员
			public:
				//文件类型以八进制的形式表示
				enum modes {READ = 01,WRITE = 02,EXECUTE=03};
				File &open(modes);
				void close();
				void write();
				bool isRead() const;
				void setWrite();
			};
mode位域占2个二进制位，modified只占1位，其他成员则各占3个。如果可能的话，在类的内部连续定义的位域
压缩在同一整数的相邻位，从而提供存储压缩。例如在之前的声明中，五个位域可能会存储在同一个unsigned int
中。这些二进制位是否能压缩到一个整数中以及如何压缩是与机器相关的。
	取地址运算符(&)不能作用于位域，因此任何指针都无法指向类的位域。
注意:
	通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。

使用位域
	访问位域的方式与访问类的其他数据成员的方式非常相似:
			void File::write(){
				modified = 1;
				//....
			}
			void File::close(){
				if(modified)
					//保存内容
			}
通常使用内置的位运算符操作超过1位的位域:
			File &File::open(Fill::modes m){
				mode | READ;		//按默认的方式设置READ
				//其他处理
				if(m&WRITE)			//如果打开了READ和WRITE
				///按照读/写方式打开文件
				return *this;
			}
如果一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的值:
			inline bool File::isRead()const {return mode & READ;}
			inline void File::setWrite() {mode | WRITE;}

19.8.2	volatile限定符
注意：
	volatile的确切含义与机器无关，只能通过阅读编译器文档来理解。要想让使用了volatile的程序在移植
到新机器或新编译器后任然有效，通常需要对该程序进行某些改变。
	直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包
含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile。
关键字volatile告诉编译器不应对这样的对象进行优化。
	volatile限定符的用法和const很相似，它起到对类型额外修饰的作用:
			volatile int display_register;		//该int值可能会发生改变
			volatile Task *curr_task;			//curr_task指向一个volatile对象
			volatile int iax[max_size];			//iax的每个元素都是volatile
			volatile Screen bitmapBuf;			//bitmapBuf的每个成员都是volatile
const和volatile限定符互相没什么影响，某种类型可能既是const的也是volatile的，此时它同时具有
二者的属性。
	就像一个类可以定义const成员函数一样，它也可以定义成volatile的。只有volatile的成员函数才
能被volatile的对象调用。
	2.4.2节描述了const限定符和指针的相互作用，在volatile限定符和指针之间也存在类似的关系。
我们可以声明volatile指针、指向volatile对象的指针以及指向volatile对象的volatile指针:
			volatile int v;			//v是一个volatile int
			int *volatile vip;		//vip是一个volatile指针，它指向int
			volatile int *ivp;		//ivp是一个指向volatile int的指针
			//vivp是一个volatile指针，指向一个volatile int
			volatile int *volatile vivp;
			int *ip = &v;		//错误:必须使用指向volatile的指针
			ivp = &v;			//正确:ivp是一个指向volatile的指针
			vivp = &v;			//正确:vivp是一个指向volatile int的volatile指针跟const是一样的
和const一样，我们只能将一个volatile对象的地址(或者拷贝一个指向指向volatile类型的指针)赋给一个指向
volatile的指针。同时，只有当某个引用是volatile的时，我们才能使用一个volatile对象初始化该引用。

合成的拷贝对volatile对象无效
	const和volatile的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋值运算符初始化volatile对象
或从volatile对象赋值。合成的成员接受的形参类型是(非volatile)常量引用，显然我们不能把一个非volatile
引用绑定到一个volatile对象上。
	如果一个类希望拷贝、移动或赋值它的volatile对象，则该类必须自定义拷贝或移动操作。例如，我们可以将
形参类型指定为const volatile引用，这样我们就能利用任意类型的Foo进行拷贝或赋值操作了:
			class Foo{
			public:
				Foo(const volatile Foo&);		//从一个volatile对象进行拷贝
				//将一个volatile对象赋给一个非volatile对象
				Foo &operator=(volatile const Foo&);//只能是一个非volatile对象调用
				//将一个volatile对象赋给一个volatile对象
				Foo &operator=(volatile const Foo&)volatile;	//只能是volatile对象调用
				//Foo类的剩余部分
			};
尽管我们可以为volatile对象定义拷贝和赋值操作，但是一个更深层次的问题是拷贝volatile对象是否有意义呢？不同
程序使用volatile的目的各不相同，对上述问题的回答与具体的使用目的密切相关。

19.8.3	链接指示:extern "C"
	C++程序有时需要调用其他语言编写的函数，最常见的是调用C语言编写的函数。像所有其他名字一样，其他语言中的
函数名字也必须在C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查
其调用方式与处理普通C++函数的方式相同，但是生成的代码有所区别。C++使用链接指示指出任意非C++函数所用的语言。
注意:
	要想把C++代码和其他语言(包括C语言)编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个
编译器与当前的C++编译器是兼容的。

声明一个非C++的函数
	链接指示可以有两种形式:单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在
函数的每个声明中都出现。举个例子，接下来的声明显示了cstring头围巾啊的某些C函数是如何声明的:
			//可能出现在C++头文件<cstring>中的链接指示
			//但语句链接指示
			extern "C" size_t strlen(const char *);
			//复合语句链接指示
			extern "C"{
				int strcmp(const char *,const char*);
				char *strcat(char *,const char*);
			}
链接指示的第一种形式包含一个关键字extern，后面是一个字符串字面值常量以及一个"普通的"函数声明。
	其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持对C语言的链接指示。此外，编译器也可能
会支持其他语言的链接指示，比如extern "Ada"、extern "FORTRAN"等。

链接指示与头文件
	我们可以理工链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个链接。花括号的作用是将
适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽略，花括号中声明的函数名字就是可见的，就好像在
花括号之外声明的一样。
	多重声明的形式可以应用于整个头文件。例如，C++的cstring头文件可能形如:
			//复合语句链接指示
			extern "C"{
				#include <string.h>			//操作C风格字符串的C函数
			}
当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言
编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。
注意:
	C++从C语言继承的标准库函数可以定义成C函数，但并非必须：决定使用C还是C++实现C标准库是每个C++实现的事情。

指向extern "C"函数的指针
	编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的
链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示:
			//pf指向一个C函数，该函数接受一个int返回void
			extern "C" void (*pf)(int);
当我们使用pf调用函数时，编译器认定当前调用的是一个C函数。
	指向C函数的指针与指向C++函数的指针是不一样的类型。一个指向C函数的指针不能用在指向初始化或赋值操作后指向C++
函数，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生
错误:
			void (*pf1)(int);			//指向一个C++函数
			extern "C" void (*pf2)(int);//指向一个C函数
			pf1 = pf2;			//错误:pf1和pf2的类型不同
注意:
	有的C++编译器会接受之前的这种赋值操作并将其作为语言的扩展，尽管从严格意义上来看它是非法的。
	
链接指示对整个声明都有效
	当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效:
			//f1是一个C函数，它的形参是一个指向C函数的指针
			extern "C" void f1(void(*)(int));
这条声明语句指出f1是一个不返回任何值的C函数。它有一个类型是函数指针的形参，其中的函数接受一个int形参返回为空。这个
链接指示不仅对f1有效，对函数指针同样有效。当我们调用f1时，必须传给它一个C函数的名字或者指向C函数的指针。
	因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给C++函数传入一个指向C函数的指针，则必须使用
类型别名:
			//FC是一个指向C函数的指针
			extern "C" typedef void FC(int);
			//f2是一个C++函数，该函数的形参是指向C函数的指针
			void f2(FC *);
			
导出C++函数到其他语言
	通过使用链接指示对函数进行定义，我们可以令一个C++函数在其他语言编写的程序中可用:
			//calc函数可以被C程序调用
			extern "C" double calc(double dparm){/*....*/}
编译器将为该函数生成适合于指定语言的代码。
	值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，我们不太可能把一个C++对象传
给C程序，因为C程序根本无法理解构造函数、析构函数以及其他类特有的操作。
对链接到C的预处理器的支持
	有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C++版本的程序时预处理器定义__cplusplus(两个
下划线)。利用这个变量，我们可以在编译C++程序的时候有条件地包含进来一些代码:
			#ifdef __cplusplus
			//正确:我们正在编译C++程序
			extern "C"
			#endif
			int strcmp(const char *,const char *);
			
重载函数与链接指示
	链接指示与重载函数的相互作用依赖于目标语言。如果目标语言支持重载函数，则为该语言实现链接指示的编译器很
可能也支持重载这些C++函数。C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能说明一组重载函数中
的某一个了:
			//错误:两个extern "C"函数的名字相同
			extern "C" void print(const char *);
			extern "C" void print(int);
如果在一组重载函数中有一个是C函数，则其余的必定都是C++函数:
			class SmallInt{/*...*/};
			class BigNum{/*...*/};
			//C函数可以在C或C++程序中调用
			//C++函数重载了该函数，可以在C++中调用
			extern "C" double calc(double);
			extern SmallInt calc(const SmallInt&);
			extern BigNum calc(const BigNum&);
C版本的calc函数可以在C或C++中调用，而使用了类类型形参的C++函数只能在C++程序中调用。上述性质与声明的顺序
无关。
