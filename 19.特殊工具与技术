					第19章	特殊工具与技术
内容
--------------------------------
	19.1	控制内存分配
	19.2	运行时类型识别
	19.3	枚举类型
	19.4	类成员指针
	19.5	嵌套类
	19.6	union:一种节省空间的类
	19.7	局部类
	19.8	固有的不可移植的特性
--------------------------------
	本书的前三部分讨论了C++语言的基本要素，这些要素绝大多数程序员都会用到。此外，C++还定义了一些
非常特殊的性质，对于很多程序员来说，它们一般很少会用到本章介绍的内容。
	C++语言的设计者希望它能处理各种各样的问题。因此，C++的某些特征可能对于一些特殊的应用非常重要，
而在另外一些情况下没有什么作用。本章将介绍C++语言的几种未被广泛使用的特征。

19.1	控制内存分配
	某些应用程序对内存分配有特殊的需求，因此我们无法将标准内存管理机制直接应用于这些程序。他们常常
需要自定义内存分配的细节，比如使用过关键字new将对象放置在特定的内存空间中。为了实现这一目的，应用
程序需要重载new运算符和delete运算符以控制内存分配的过程。

19.1.1	重载new和delete
	尽管我们说能够"重载new和delete"，但是实际上重载这两个运算符与重载其他运算符的过程大不相同。
要想真正掌握重载new和delete的方法，首先要对new表达式和delete表达式的工作机理有更多了解。
	当我们使用一条new表达式时:
		//new表达式
		string *sp = new string("a value");	//分配并初始化一个string对象
		string *arr = new string[10];	//分配10个默认初始化的string对象
实际执行了三步操。第一步，new表达式调用一个名为operator　new(或者operator new[])的标准库
函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象(或者对象的数组)。第
二步，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完
成，返回一个指向该对象的指针。
	当我们使用一条delete表达式删除一个动态分配的对象时:
		delete sp;			//销毁*sp，然后释放sp指向的内存空间
		delete [] arr;		//销毁数组中的元素，然后释放对应的内存空间
实际执行了两步操作。第一步，对sp所指的对象或者arr所指的数组中元素执行对应的析构函数。第二步，编
译器调用名为operator delete(或者operator delete[])的标准库函数释放内存空间。
	如果应用程序希望空间内存分配的过程，则它们需要定义自己的operator　new函数和operator 
delete函数。即使在标准库中已经存在这两个函数的定义，我们仍旧可以定义自己的版本。编译器不会对这种
重复定义提出异议。相反，编译器将使用我们自定义的版本替换标准库定义的版本。
注意:
	当自定义了全局的operator new函数和operator　delete函数后，我们就担负起了控制动态内存分
配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。
应用程序可以在全局作用域中定义operator new函数和operator delete函数，也可以将它们定义为
成员函数。当编译器发现一条new表达式或delete表达式后，将在程序查找可供调用的operator函数。如果
被分配(释放)的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有operator new
成员或operator delete成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域查找匹配的
函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没有
找到，则使用标准库定义的版本。
	我们可以使用作用域运算符令new表达式或delete表达式忽略定义在类中的函数，直接执行全局作用域
中的版本。例如，::new只在全局作用域中查找匹配的operator　new函数，::delete与之类似。

operator new接口和operator delete接口
	标准库定义了operator new函数和operator delete函数的8个重载版本。其中前四个版本可能抛
出bad_alloc异常，后四个版本则不会抛出异常:
		//这些版本可能抛出异常
		void *operator new(size_t);		//分配一个对象
		void *operator new[](size_t);	//分配一个数组
		void *operator delete(void *)noexcept;	//释放一个对象
		void *operator delete[](void *)noexcept;//释放一个数组

		//这些版本承诺不会抛出异常
		void *operator new(size_t,nothrow_t &) noexcept;
		void *operator new[](size_t,nothrow_t &)noexcept;
		void *operator delete(size_t,nothrow_t &)noexcept;
		void *operator delete[](size_t,nothrow_t &)noexcept;
类型nothrow_t是定义在new头文件中的一个struct，在这个类型中不包含任何成员。new头文件还定义了一
个名为nothrow的const对象，用户可以通过这个对象请求new的非抛出版本。与析构函数类似，operator 
delete也不允许抛出异常。当我们重载这些运算符时，必须用noexcept异常说明符指定其不抛出异常。
	应用程序可以自定义上面的函数版本中任意一个，前提是自己定义的版本必须位于全局作用域或者类的作用
域中。当我们将上述运算符函数定义成类的成员时，它们是隐式静态的。我们无须显示地声明static，当然这
么做也不会引发错误。因为operator　new用在对象构造之前而operator delete用在对象销毁之后，
所以这两个成员(new和delete)必须是静态的，而且他们不能操作类的任何数据成员。
	对于operator new函数或者operator new[]函数来说，它的返回类型必须是void *，第一个形参的
类型必须是size_t且该形参不能含有默认实参。当我们为一个对象分配空间时使用operator new；为一个数
组分配空间时使用operator new[]。当编译器使用operator new时，把存储指定类型对象所需的字节
数传递给size_t形参；当调用operator new[]时，传入函数的则是存储数组所有元素所需的空间。
	如果我们想要自定义operator new函数，则可以为它提供额外的形参。此时，用到这些自定义函数的
new表达式必须用new的定位形式将实参传递给新增的形参。尽管在一般情况下我们可以自定义具有任何形参的
operator new，但是，下面这个函数却无论如不能被用户重载:
		void *operator new(size_t,void *);	///不允许被重新定义这个版本
这种形式只提供标准库使用，不能被用户重新定义。
	对于operator delete函数或者operator delete[]函数来说，它们的返回类型必须是void，第
一个形参的类型必须是void *。执行一条delete表达式将调用相应的operator函数，并用指向待释放内存
的指针来初始化void *形参。
	当我们将operator delete或operator delete[]定义成类的成员时，该函数可以包含另外一个类型
为size_t的形参。此时，该形参的初始值是第一个形参所指对象的字节数。size_t形参用于可删除继承体系
中的对象。如果基类有一个虚析构函数，则传递给operator delete的字节数将因为删除指针所指对象的动态
类型不同而有所区别。而且，实际运行的operator　delete函数版本也由对象的动态类型决定。
术语:new表达式与operator new函数
	标准库函数operator new和operator delete的名字容易让人误解。和其他operator函数不同(比如
operator=)。这两个函数并没有重载new表达式或delete表达式。实际上，我们根本无法自定义new表达式
或delete表达式的行为。
	一条new表达式的执行过程总是先调用operator new函数以获取内存空间，然后在得到的内存空间中构
造对象。与之相反，一条delete表达式的执行过程总是先销毁对象，然后调用operator delete函数释放对象
所占的空间。
	我们提供新的operator new函数和operator delete函数的目的在于改变内存分配的方式，但是不管
怎样，我们都不能改变new运算符和delete运算符的基本含义。

malloc函数和free函数
	当你定义了自己的全局operator new和operator delete后，这两个函数必须以某种方式执行分配
内存与释放内存的操作。也许你的初衷仅仅是使用一个特殊定制的内存分配器。但是这两个函数还应该同时满足
某些测试目的。即检验其分配内存的方式是否与常规方式类似。
	为此我们可以使用名为malloc和free的函数，C++从C语言继承了这些函数，并将其定义在cstdlib头
文件中。
	malloc函数接受一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。
free函数接受一void *，它是malloc返回的指针的副本，free将相关的内存返回给系统，调用free(0)
没有任何意义。
	如下所示是编写operator new和operator delete的一种简单方式，其它版本与之类似:
		void *operator new(size_t size){
			if(void *mem = malloc(size))
				return mem;
			else
				throw bad_alloc();
		}
		void operator delete(void *mem)noexcept {
			free(mem);
		}

