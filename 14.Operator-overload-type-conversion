						第14章	重载运算与类型转换
内容
--------------------------------
	14.1	基本概念
	14.2	输入和输出运算符
	14.3	算术和关系运算符
	14.4	赋值运算符
	14.5	下标运算符
	14.6	递增和递减运算符
	14.7	成员访问运算符
	14.8	函数调用运算符
	14.9	重载、类型转换与运算符
---------------------------------
	在第四章中我们看到，C++语言定义了大量运算符以及内置类型的自动转换规则。这些特性使得程序员能编写出形式
丰富、含有多种混合类型的表达式。
	当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义；同时，我们也能定义类类型之间的转换规则。
和内置类型转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。
	当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义。明智地使用运算符重载能令我
们的程序更易于编写和阅读。举个例子，因为在Sales_item类中定义了输入、输出和加法运算符，所以可以通过下述形式
输出两个Sales_item的和:
		cout<<item1 + item2;	//输出两个Sales_item的和
相反的，由于我们的Sales_data类还没有重载这些运算符，因此它的加法代码显得比较冗长而不清晰:
		print(cout,add(data1,data2));	//输出两个Sales_data的和

14.1	基本概念
	重载的运算符是具有特殊名字的函数:它们的名字由关键字operator和其后要定义的运算符号共同组成。重载的运算符
也包含返回类型、参数列表以及函数体。重载运算符函数的参数数量与该运算对象数量一样多，一元运算符有一个参数，二元
运算符有两个，对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数
调用运算符operator()之外，其他重载运算符不能含有默认实参。
	如果一个运算符函数是成员函数，则它的第一个(左侧)运算对象绑定到隐式的this指针上，因此，成员运算符函数的(
显示)参数数量比运算符的运算对象总数少一个。
注意:
	当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显示)参数数量比运算对象的数量
少一个。

对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数:
		//错误:不能为int重定义内置的运算符
		int operator+(int,int);
这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变运算符的含义。
	我们可以重载大多数(但不是全部)运算符。表14.1指明了哪些运算符可以被重载哪些不行。我们将在19.1.1节介绍重
载new和delete的方法。我们只能重载已有的运算符，而无权发明新的运算符号。例如，我们不能提供operator**来执
行幂操作。有四个符号(+,-,*,&)既是一元运算符，也是二元运算符，所有这些运算符能被重载，从参数的数量我们可以推
断出到底定义的是哪种运算符。
	对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致，不考虑运算对象类型的话:
		x == y + z;
永远等价于x == (y + z);
				表14.1	运算符
					可以被重载的运算符
		+	-	*	/	%	^	&	|	~	!
		,	=	<	>	<=	>=	++	--	<<	>>
		==	!=	&&	||	+=	-=	/=	%=	^=	&=
		|=	*=	<<=	>>=	[]	()	->	->*	new	new[]
		delete	delete[]
					不能被重载的运算符
		::	.*	.	? :

直接调用一个重载的运算符函数
	通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式"调用"重载的运算符。然而，我们也能像调用
普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参:
		//一个非成员运算符函数的等价调用
		data1 + data2;			//普通的表达式
		operator+(data1,data2);	//等价的函数调用
这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。我
们调用其他成员函数一样显示地调用成员函数。具体做法是，首先指定运行函数的对象(或指针)的名字，然后使用点运算符(或
箭头运算符)访问希望调用的函数:
		data1 += data2;			//基于"调用"的表达式
		data1.opertor+=(data2);	//对成员运算符函数的等价调用
这两条语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。

某些运算符不应该被重载
	回忆之前介绍过的，某些运算符指定了运算对象的求值顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关
于运算对象求值顺序的规划无法应用到重载的运算符上。特别是，逻辑与运算符，逻辑或运算符和逗号运算符的运算对象求值
顺序规则无法保留下来。除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被
求值。
	因为上述运算符的重载版本无法保留求值顺序和取地址运算符:C++语言已经定义了这两种运算符用于类类型对象时特殊含
义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则他们的行
为将异于常态，从而导致类的用户无法适应。
注意:
	通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符

使用与内置类型一致的含义
	当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需要哪些操作之后，才能思考到底应该把每
个类操作设成普通函数还是重载运算符。如果某些操作在逻辑上与运算符相关，则他们适合于定义成重载的运算符:
		>>>	如果类执行IO操作，则定义意味运算符使其与内置类型的IO保持一致
		>>>	如果类的某个操作是检查相等性，则定义operator==;如果类有了operator==，意味着它通常也应该有
operator!=。
		>>>	如果类包含一个内在的单序比较操作，则定义operator<；如果类有了operator<，则它应该也定义
含有其他关系操作。
		>>>	重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，
算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。
提示:尽量明智的使用运算符重载
	每个运算符在用于内置类型时都有比较明确的含义。以二元+运算符为例，它明显执行的是加法操作。因此，把二元+运算符
映射到类类型的一个类似操作上可以极大简化记忆。例如，对于标准库类型string来说，我们就会使用+把一个string对象连接
到另一个后面，很多编程语言都有类似的用法。
	当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果最好。此时，使用重载的运算符显然比另
一个名字更自然也更直观。不过，过分滥用运算符重载也会使我们的类变得难以理解。
	在实际编程过程中，一般没有特别明显的滥用运算符重载的情况。例如，一般来说没有哪个程序员会定义operator+并让它
执行减法操作。然而经常发生的一种情况是，程序员可能会强行扭曲运算符的"常规"含义使得其适应某种给定的类型，这显然是我
们不希望发生的。因此我们的建议是:只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不
同的理解，则使用这样的运算符将产生二义性。

赋值和复合赋值运算符
	赋值运算符的行为与复合版本的类似:赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回左侧运算对象
的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。如果类含有算术运算符或者位运算符，则最好也提供对应的复
合赋值运算符。无须赘言，+=运算符的行为显然应该与其内置版本一致，即先执行+，再执行=。

选择作为成员或者非成员
	当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通非成员函数。在某些时候我们别无
选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。
	下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择:
		>>>	赋值(=)、下标([])、调用(())和成员访问箭头(->)运算符必须是成员。
		>>>	复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。
		>>>	改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
		>>>	具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因为它们通常应
该是普通的非成员函数。
	程序员希望在含有混合类型的表达式中使用对称性运算符。例如，我们能求一个int和double的和，因为它们中的任意一
个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定
义成非成员函数。
	当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。例如:
		string s = "world";
		string t = s + "!";	//正确:我们能把一个const char *加到一个string对象中
		string u = "hi" + s;//如果+是string的成员，则产生错误
如果operator+是string类的成员，则上面的第一个加法等价于s.opertor("!")。同样的，"hi"+s等价于
"hi".operator+(s)。显然"hi"的类型是const char *，这是一种内置类型，根本就没有成员函数。所以+不是string的
成员运算符。因为"hi"+s;也是可以成立的。
	因为string将+定义成了普通的非成员函数，所以"hi"+s等价于operattor("hi",s)。和任何其他函数调用一样，
每个实参都是能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成
string。

14.2	输入和输出运算符
	如我们所知，IO标准库分别使用>>和<<执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型
的版本，而类则需要自定义适合其对象的新版本以支持IO操作。
14.2.1	重载输出运算符<<
	通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入
内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。
	第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复
制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。
	为了与其他输出运算符保持一致，operator<<一般需要返回它的ostream形参。

Sales_data的输出运算符
	举个例子，我们按照如下形式编写Sales_data的输出运算符:
		ostream &operator<<(ostream &os,const Sales_data &item)
		{
			os << item.isbn()<<" "<<item.units_sold<<" "
			   << item.revenue<< " "<<item.avg_price();
			return os;
		}
除了名字之外，这个函数与之前的print函数完全一样。打印一个Sales_data对象意味着要分别打印它的三个数据
成员以及通过计算得到的平均销售价格，每个元素以空格隔开。完成输出后，运算符返回刚刚使用的ostream的引用。

输出运算符尽量减少格式化操作
	用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符
打印了换行符，则用户就无法在对象的同一行内接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使
用户有权控制输出的细节。
注意:
	通常，输出运算符应该主要负责打印对象的内容而菲菲控制格式，输出运算符不应该打印换行符。

输入输出运算符必须是非成员函数
	与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则它们的左侧运算对象
将是我们的类的一个对象:
		Sales_data data;
		data<<cout;		//如果operator<<是Sales_data的成员
假设输入输出运算符是某个类的成员，则它们必须是istream或ostream的成员。然而这两个类属于标准库，并且我们
无法给标准库中的类添加任何成员。
	因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然,IO运算符通常需要读写类的非公有数据
成员，所以IO运算符一般被声明为友元。

14.2.2	重载输入运算符>>
	通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用。
该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这
个对象中。

Sales_data的输入运算符
	举个例子，我们将按照如下形式编写Sales_data的输入运算符:
		istream &operator>>(istream &is,Sales_data &item)
		{
			double price;
			is >> item.bookNo >> item.units_sold>>price;
			if(is)	//检查输入是否成功
				item.revenue = item.units_sold * price;
			else
				item = Sales_data();	//输入失败：对象
			return is;
		}
除了if语句之外，这个定义与之前的read函数完全一样。if语句检查读取操作是否成功，如果发生了IO错误，则运算符将给定
的对象重置为空Sales_data，这样可以确保对象处于正确的状态。
注意:
	输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

输入时的错误
	在执行输入运算符时可能发生下列错误:
		>>>	当流含有错误类型的数据时读取操作可能失败。例如在读取完bookNo后，输入运算符假定接下来读入的是两个
数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都失败。
		>>>	当读取操作到达文件中末尾或者遇到输入流的其他错误时也会失败。
在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据后赶在使用这些数据前一次性检查:
		if(is)			//检查输入是否成功
			item.revenue = item.units_sold * price;
		else
			item = Sales_data(();	//输入失败:对象被赋予默认状态
如果读取操作失败，则price的值将是未定义的。因此，在使用price前我们需要首先检查输入流的合法性，然后才能执行计算
并将结果存入revenue。如果发生了错误，我们无须在意到底是哪部分输入失败，只要将一个新的默认初始化的Sales_data对
象赋予item从而将其重置为空Sales_data就可以了。执行这样的赋值后，item的bookNo成员将是一个空string，
revenue和units_sold成员等于0。
	如果在发生错误前，已经有部分被改变，则适时地将对象置为合法状态显得异常重要。例如在这个输入运算符中，我们
可能在成功读取新的bookNo后遇到错误，这意味着对象的units_sold和revenue成员并没有改变，因此有可能会将这两
个数据与一条完全不匹配的bookNo组合在一起。
	通过将对象置为合法的状态，我们能(略微)保护使用者免于收到输入错误的影响。此时的对象出于可用状态，即它的成
员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是一体的。
注意:
	当读取操作发生错误时，输入运算符应该负责从错误中恢复。

标示错误
	一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查bookNo是否符合规范的格式。在这
样的例子中，即使从技术上来看IO是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算
符只设置failbit。除此之外，设置eofbit标示文件耗尽，而设置badbit表示流被破坏。最好的方式是由IO标准库自己
来标示这些错误。

14.3	算术和关系运算符
	通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不
需要改变运算对象的状态，所以形参都是常量的引用。
	算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，
操作完成后返回该局部变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此
时，最有效的方式是使用复合赋值来定义算术运算符:
		//假设两个对象指向同一本书
		Sales_data operator+(const Sales_data &lhs,const Sales_data &rhs)
		{
			Sales_data sum = lhs;	//把lhs的数据成员拷贝给sum
			sum += rhs;		//将rhs加到sum中
			return sum;
		}
这个定义由于原来的add函数是完全等价的。我们lhs拷贝给局部变量sum，然后使用Sales_data的复合赋值运算符将
rhs的值加到sum中，最后返回sum的副本。
注意:
	如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。

14.3.1相等运算符
	通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员。
只有当所有对应的成员都相等的时候才认为两个对象相等。依据这一思想，我们的Sales_data类的相等运算符不但应该
比较bookNo,还应该比较具体的销售数据:
		bool operator==(const Sales_data &lhs,const Sales_data &rhs)
		{
			return lhs.isbn() == rhs.isbn() &&
				   lhs.units_sold == rhs.units_sold &&
				   lhs.revenue == rhs.revenue;
		}
		bool operator!=(const Sales_data &lhs,const Sales_data &rhs)
		{
			return !(lhs == rhs);
		}
就上面这些函数的定义本身而言，它们似乎比较简单，也没什么价值，对于我们来说重要的是从这些函数中体现出来的设计
准则:
		>>>	如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的
命名函数；因为用户肯定希望使用==比较对象，所以提供了==就意味着用户无须再费力并记忆一个全新函数的名字。此外，
类定义了==运算符之后也更容易地使用标准库容器和算法。
		>>>	如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据。
		>>>	通常情况下，相等运算符应该具有传递性，换句话说，如果a==b和b==c都为真，则a==c也应该为真。
		>>>	如果类定义了operator==,则这个类也应该定义为operator!=。对于用户来说，当它们能使用==时
肯定也希望能使用!=，反之亦然。
		>>>	相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较
对象的工作，而另一个运算符则只是调用那个真正工作的运算符。
注意:
	如果某个类在逻辑上有相等的含义，则该类应该定义operator==，这样做可以使得用户更容易呀使用标准
库算法来处理这个类。

14.3.2	关系运算符
	定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以
定义operator会比较有用。通常情况下关系运算符应该:
		>>>	1.定义顺序关系，令其与关联容器中对关键字的要求一致；并且
		>>>	如果类同时也包含有==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是!=的，那么
一个对象应该<另外一个。
尽管我们可能会认为Sales_data类应该支持关系运算符，但事实证明并非如此，其中的缘由比较微妙，值的读者深思。
	一开始我们可能会认为应该像compareIsbn那样定义<，该函数通过比较ISBN来实现对两个对象的比较。然而，尽管
compareIsbn提供的顺序关系符合要求1，但是函数得到的结果显然与我们定义的==不一致，因此它不满足要求2(主要是因
为不能只通过compareIsbn就去代表整个Sales_data)。
	对于Sales_data的==运算符来说，如果两笔交易的revenue和units_sold成员不同，那么即使它们的ISBN相同
也无济于事，它们仍然是不等的。如果我们定义的<运算符仅仅比较ISBN成员，那么将发生这样的情况:两个ISBN相同但
revenue和units_sold不同的对象经比较是不相等的，但是其中的任何一个都不比另一个小。然而实际情况是，如果我们有
两个对象并且哪个都不比另一个小，则从道理上来讲这两个对象是相等的。
	基于上述分析我们也许会认为，只要让operator<比较每个数据元素就能解决问题了，比方说让operator<先比较isbn，
相等的话继续比较units_sold，还相当继续比较revenue。然而，这样的排序没有必要。根据将来使用Sales_data类的实
际需要，我们可能会希望先比较units_sold，也可能先比较revenue。有的时候，我们希望units_sold少的对象"小于"
units_sold的对象，另一些时候，则可能希望revenue少的对象"小于"revenue多的对象。
	因此对于Sales_date类来说，不存在一种逻辑可靠的<定义，这个类不定义<运算符也许更好(注意这个是站在类的设计
者的角度去思考的，如果你设计的类单单只有你自己用的话，就得另一种设计思路了！)
注意:
	如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和
==定义产生的结果一致的时候才定义<运算符。

14.4	赋值运算符
	之前已经介绍过拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给类的另一个对象。。此外，类还可以定义其
它赋值运算符以使用别的类型作为右侧运算对象。
	举个例子，在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算符接受花括号内的
元素列表作为参数。我们能以如下的形式使用该运算符:
		vector<string> v;
		v = {"a","an","the"};
同样，也可以把这个运算符添加到StrVec类中:
		class StrVec{
		public:
			StrVec &operator=(std::initializer_list<std::string>);//initializer_list是一个包含未知数量的一个容器
		};
为了与内置类型的赋值运算符保持一致(也与我们已经定义的拷贝赋值和移动赋值运算一致)，这个新的赋值运算符将返回其
左侧运算对象的引用。
		StrVec &StrVec::operator=(initializer_list<string> il)
		{
			//alloc_n_copy分配的内存空间并从给定范围内拷贝元素
			auto data = alloc_n_copy(il.begin(),il.end());
			free();	//释放掉原先的内存空间
			elements = data.first;
			first_free = data.second;
			return *this;
		}
和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间。不同之处是，这个运算符无须检查对
象向自身赋值，这是因为它的形参initializer_list<string>确保il与this所指的不是同一个对象
注意:
	我们可以重载运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。

复合赋值运算符
	复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算符都定义在类的内部。为了与
内置类型的复合赋值保持一致，类中复合赋值运算符也要返回其左侧运算对象的引用。例如，下面是Sales_data类中复合赋值
运算符的定义:
		//作为成员的二元运算符:左侧运算对象绑定到隐式的this指针
		//假定两个对象表示的是同一本书
		Sales_data &Sales_data::operator+=(const Sales_data &rhs)
		{
			units_sold += rhs.units_sold;
			revenue += rhs.revenue;
			return *this;
		}
注意:
	赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

14.5	下标运算
	表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。
注意:
	下标运算符必须是成员函数
为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的
任意一端。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量
引用以确保我们不会给返回的对象赋值。
注意:
	如果一个类包含下标运算符，则它通常会定义两个版本:一个返回普通引用，另一个是类的常量成员并返回常量引用。

	举个例子，我们按照如下形式定义StrVec的下标运算符:
		class StrVec{
		public:
			std::string &operator[](std::size_t n)
			{
				return elements[n];
			}
			std::string &operator[](std::size_t n)const
			{
				return elements[n];
			}
			//其他成员与前面的定义一致
		private:
			std::string *elements;	//指向数组首元素的指针
		};
上面这两个下标运算符的用法类似与vector或者数组中的下标。因为下标运算符返回的是元素的引用，所以当StrVec是非
常量时，我们可以给元素赋值，而当我们对常量对象取下标时，不能为其赋值:
		//假设svec是一个StrVec对象
		const StrVec cvec = svec;		//把svec的元素拷贝到cvec中
		//如果svec中含有元素，对第一个元素运行string的empty函数
		if(svec.size() && svec[0].empty()){
			svec[0] = "zero";		//正确:下标运算符返回string的引用
			cvec[0]	= "zip";		//错误:对cvec取下标返回的是常量引用
		}

14.6	递增和递减运算符
	在迭代器类中通常会实现递增运算符(++)和递减运算符(--)，这两种运算符使得类可以在元素的序列中前后移动。C++
语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。
	对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算
符。接下来我们首先介绍前置版本，然后实现后置版本。
注意:
	定义递增和递减运算符的类应该同时定义前置和后置版本。这些运算符通常应该被定义成类的成员。

定义前置递增/递减运算符
	为了说明递增和递减运算符，我们不妨在StrBlobPtr类中定义它们:
		class StrBlobPtr{
		public:
			//递增和递减运算符
			StrBlobPtr &operator++();		//前置运算符
			StrBlobPtr &operator--();		//前置运算符
			//其他成员和之前的版本一致
		};
注意:
	为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。

递增和递减运算符的工作机理非常相似:它们首先调用check函数检验StrBlobPtr是否有效，如果是，接着检查给定的索引
值是否有效。如果check函数没有抛出异常，则运算符返回对象的引用。
	在递增运算符的例子中，我们把curr的当前值传递给check函数。如果这个值小于vector的大小，则check正常返回，否
则，如果curr已到达了vector的末尾，check将抛出异常:
		//前置版本:返回递增/递减对象的引用
		StrBlobPtr &StrBlobPtr::operator++()
		{
			//如果curr已经指向了容器的尾后位置，则无法递增它
			check(curr,"increment past end of StrBlobPtr");
			++curr;	//将curr在当前状态下向前移动一个元素
			return *this;
		}
		StrBlobPtr &StrBlobPtr::operator--()
		{
			//如果curr是0，则继续递减它将产生一个无效下标
			--curr;
			check(curr,"decrement past begin of StrBlobPtr");
			return *this;
		}
递减运算符首先递减curr，然后调用check函数。此时，如果curr(一个无符号数)已经是0了，那么我们传递给check的值
将是一个表示无效下标的非常大的正数值。

区分前置和后置运算符
	要想同时定义前置和后置运算符，必须是偶先解决一个问题，即普通重载形式无法区别这两种情况。前置版本使用的是同一
个符号，意味其他重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同。
	为了解决这个问题，后置版本接受一个额外的(不被使用)int类型的形参。当我们使用后置运算符时，编译器为这个形参
提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参
的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。
	接下来我们为StrBlobPtr添加后置运算符:
		class StrBlobPtr{
		public:
			//递增和递减运算符
			StrBlobPtr operator++(int);		//后置运算符
			StrBlobPtr operator--(int);		//后置运算符
			//其他成员和之前版本一致
		};
注意:
	为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用。
对于后置版本来说，在递增对象之前需要首先记录对象的状态:
		//后置版本:递增/递减对象的值但是返回原值
		StrBlobPtr StrBlobPtr::operator++(int)
		{
			//此处无须检查有效，调用前置版本运算时才需要检查
			StrBlobPtr ret = *this;
			++*this;	//向前移动一个元素，前置++需要检查递增的有效性,注意这是使用前置版本来检查有效性了
			return ret;
		}
		StrBlobPtr StrBlobPtr::operator--(int)
		{
			//此处无须检查有效，调用前置版本运算时才需要检查
			StrBlobPtr ret = *this;
			--*this;	//向后移动一个元素，前置--需要检查递减的有效性
			return ret;
		}
由上可知，我们的后置运算符调用各自的前置版本来完成实际的工作。例如后置递增运算符执行:
		++*this
该表达式调用前置递增运算符，前置递增运算符首先检查递增操作是否安全，根据检查的结果抛出一个异常或者执行递增curr
的操作。假定通过了检查，则后置函数返回事先存好的ret的副本。因此最终的效果是，对象本身向前移动了一个元素，而返回
的结果仍然反映对象在未递增之前原始的值。
注意:
		因为我们不会使用到int参数，所以无须为其命名

显示地调用后置运算符
	如在第491页介绍的，可以显示地使用一个重载运算符，其效果与在表达式中以运算符号的形式使用它完全一样。如果我们
想通过函数调用的方式使用后置版本，则必须为它的整形参数传递一个值:
		StrBlobPtr p(a1);			//p指向a1中的vector
		p.operator++(0);			//调用后置版本的operator++
		p.operator++();				//调用前置版本的operator++
尽管传入的值通常会被运算符函数忽略，但却必不可少，因为编译器只有通过它才能知道应该使用后置版本。

14.7	成员访问运算符
	在迭代器类及智能指针类中常常用到解引用运算符(*)和箭头运算符(->)。我们以如下形式向StrBlobPtr类添加这两种
运算符:
		class StrBlobPtr{
		public:
			std::string &operator*() const
			{
				auto p = check(curr,"dereference past end");
				return (*p)[curr];	//(*p)是对象所指向的vector，所以先获得vector，再去获取相应位
									//置的元素数据
			}
			std::string *operator->()const
			{
				//将实际工作委托给引用运算符
				return & this->operator*();
			}
			//其他成员与之前的版本一致
		};
解引用运算符首先检查curr是否仍在作用范围内，如果是，则返回curr所指元素的一个引用。箭头运算符不执行任何自己的操
作，而是调用解引用运算符并返回解引用结果元素的地址。
注意:
	箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。
值得注意的是，我们将这两个运算符定义成了const成员，这是因为它与递增和递减运算符不一样，获取一个元素并不会改变
StrBlobPtrr对象的状态。同时，它们的发返回值是非常量string的引用或指针，因为一个StrBlobPtr只能绑定到非常量的
StrBlob对象。
	这两个运算符的用法与指针或者vector迭代器的对应操作完全一致:
		StrBlob al = {"hi","bye","now"};
		StrBlobPtr p(a1);		//p指向a1中的vector
		*p = "okay";		//给a1的首元素赋值,
		cout<<p->size()<<endl;		//打印4，这是a1首元素的大小。也就是"okay"字符的大小
		//首先p->获取的得结果是(*p)[curr]的一个指针，该元素是一个string　*，所以可以使用size()操作
		//所以结果是4
		cout<<(*p).size()<<endl;	//等价于p->size()

对箭头运算符返回值的限定
	和大多数其他运算符一样(尽管这么做不大好)，我们能令operator*完成任何我们指定的操作。换句话说，我们可以
让operator*返回一个固定值42，或者打印对象的内容，或者其他。箭头运算符则不是这样，它永远不能丢掉成员访问这个最
基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象获取成员，而箭头获取成员这一事实则永远不变。
	对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一个重载了opertor->的类的对象。根据
point类型的不同，point->mem分别等价于:
		(*point).mem;		//point是一个内置的指针类型
		point.operator()->mem;	//point是类的一个对象
除此之外，代码都将发生错误。point->mem的执行过程如下:
		1.	如果point是指针，则我们应该用内置的箭头运算符，表达式等价于(*point).mem。首先解引用该指针，然后
从所得的对象获取指定的成员。如果point所指的类型没有名为mem的成员，程序会发生错误。
		2.	如果point是定义了operator->的类的一个对象，则我们使用point.operator->()的结果来获取mem。其
中，如果该结果是一个指针，则执行第一步:如果该结果本身含有重载的operator->()，则重复调用当前步骤。最终，当这一过
程结束时，程序或者返回了所需的内容，或者返回一些表示程序错误的信息。
注意:
	重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象！！！(一般返回相对应的指针)
小结一下->和*运算符
	如果一个类对象本身就是一个指针的话，那么它就会有内置的->和*运算操作。但是如果是一个类对象的话，那么其本身是没有
->和*运算符的，所以你要想使用的话，就得自己去重载该运算符了。
14.8	函数调用运算符反
	如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函
数相比它们更加灵活。举个简单例子，下面这个名为absInt的struct含有一个调用运算符，该运算符负责返回其参数的绝对值:
		struct absInt{
			int operator()(int val)const{
				return val < 0 ? -val : val;
			}
		};
这个类只定义了一种操作:函数调用运算符，它负责接受一个int类型的实参，然后返回该实参的绝对值。
	我们使用调用运算符的方式是令一个absInt对象作用于一个实参列表，这一过程看起来非常像调用函数的过程:
		int i = -42;
		absInt absObj;		//含有函数调用运算符的对象
		int ui = absObj(i);	//将i传递给absObj.operator()
即使absObj只是一个对象而非函数，我们也能"调用"该对象。调用对象实际上是在运行重载的调用运算符。在此例中，该
运算符接受一个int值并返回其绝对值。
注意:
	函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间对应该参数数量或类型上有所区别。
如果类定义了调用运算符，则该类的对象称作函数对象。因为可以调用这种对象，所以我们说这些对象的"行为像函数一样"。
注意:
	含有调用运算符重载类的对象被称为函数对象！！！

含有状态的函数对象类
	和其他类一样，函数对象类除了operator()之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被
用于定制调用运算符中的操作。
	举个例子，我们将定义一个打印string实参内容的类。默认情况下，我们的类会将内容写入到cout中，每个string
之间之间以空格隔开。同时也允许类的用户提供其他可写入的流及其他分割符。我们将该类定义如下:
		class PrintString{
		public:
			PrintString(ostream &o = cout,char c=' '):os(o),sep(c){}
			void operator()(const string &s)const{os<<s<<sep;}
		private:
			ostream os;
			char sep;
		};
我们的类有一个构造函数，它接受一个输出流的引用以及一个用于分割的字符，这两个形参的默认实参分别是cout和空格。之后
的函数调用运算符使用这些成员协助打印给定的string。
	当定义PrintString的对象时，对于分割符及输出流既可以使用默认值也可以提供我们自己的值:
		PrintString printer;	//使用默认值，打印到cout
		printer(s);				//在cout中打印s，后面跟一个空格
		PrintString errors(cerr,'\n');
		errrors(s);				//在cerr中打印s，后面跟一个换行符
函数对象常常作为泛型算法的实参。例如，可以使用标准库for_each算法和我们自己的PrintString类来打印容器的内容:
		for_each(vs.begin(),vs.end(),PrintString(cerr,'\n'));
for_earch的第三个实参是类型PrintString的一个临时对象，其中我们用cerr和换行符初始化了该对象。当程序调用
for_each时，将会把vs中的每个元素依次打印到cerr中，元素之间以换行符分隔。

14.8.1	lambda是函数对象
	在前一节中，我们使用一个PrintString对象作为调用for_each的实参，这一用法类似于我们在10.3.2节中编写的
lambda表达式的程序。当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名对象。在lambda表达式产生的类中
含有一个重载的函数调用运算符，例如，对于我们传递给stable_sort作为其最后一个实参的lambda表达式来说:
		//根据单词的长度对其进行排序，对于长度相同的单词按照欧字母顺序排序
		stable_sort(words.begin(),words.end(),
					[](const string &a,const string &b)
					{return a.size()<b.size();});
其行为类似于下面这个类的一个未命名对象:
		class ShortString{
		public:
			bool operator()(const string &s1,const string &s2)const
			{
				return s1.size() < s2.size();
			}
		};
产生的类只有一个函数调用运算符成员，它负责接受两个string并比较它们的长度，它的形参列表和函数与lambda表达式
完全一样。如我们在10.3.3节所见，默认情况下lambda不能改变它捕获的变量。因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员。如果lambda被声明为可变的，
则调用运算符就不是const的了！！！
	用这个类代替lambda表达式以后，我们可以重写并重新调用stable_sort:
		stable_sort(words.begin(),words.end(),ShortString());
第三个实参是新构建的ShortString的对象，当stable_sort内部的代码每次比较两个string时就会"调用"这一对象，
此时该对象将调用运算符的函数体，判断第一个string的大小小于第二个时返回true。

表示lambda及相应捕获行为的类
	如我们所知，当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。
因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。
	相反，通过值捕获的变量被拷贝到lambda中。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，
同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。举个例子，在10.3.2节中有一个lambda，它的作用是找到第
一个长度不小于给定值的string对象:
		//获得第一个指向满足条件元素的迭代器，该元素满足size() is >= sz
		auto wc = find_if(words.begin(),words.end(),
						  [sz](const string &s)
						  {return a.size() >= sz;});
该lambda表达式产生的类将形如:
		class SizeComp{
		public:
			SizeComp(size_t n):sz(n){}		//该形参对应的捕获的变量
			//该调用运算符反的返回类型、形参和函数体都与lambda一致
			bool operator()(const string &s)const
			{
				return s.size() >= sz;
			}
		private:
			size_t sz;		//该数据成员对应通过值捕获的变量
		};
和我们的ShortString类不同，上面这个类含有一个数据成员以及一个用于初始化该成员的构造函数。这个合成的类不含有默认
构造函数，因此要向使用这个类必须提供一个实参:
		//获得第一个指向满足条件元素的迭代器，该元素满足size() is >= sz
		auto wc = find_if(words.begin(),words.end(),SizeComp(sz));
	lambda表达式产生的类不含默认构造函数、赋值运算符以及默认析构函数:它是否含有默认拷贝/移动构造函数则通常要
视捕获的数据成员类型而定。
注意:
	这里的lambda表达式产生的类不含默认析构函数、构造函数以及赋值运算符，是因为lambda表达式产生的类中它要自己
生成的，就像是上面所描述的类一样，lambda表达式生成的未知名的类，就是等价于那些类的！！！所以没有默认的构造函数、
析构函数以及赋值运算符的。

14.8.2	标准库定义的函数对象
	标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。
例如，plus类定义了一个函数调用运算符用于对一对运算对象执行+的操作；modulus类定义了一个调用运算符执行二元的
%操作;equal_to类执行==，等等。
	这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，plus<string>
令string加法运算符作用于string对象；plus<int>的运算对象是int;plus<Sales_data>对Sales_data对象
执行加法运算，依次类推:
		plus<int> intAdd;		//可执行int加法的函数对
		negate<int> intNegate;	//可对int值取反的函数对象
		//使用intAdd::operator(int,int)求10和20的和
		int sum = intAdd(10,20);	//等价于sum = 30
		sum = intNegate(intAdd(10,20));	//等价于对sum取反,也就是-30
		//使用intNegate::operator(int)生成-10
		//然后将-10作为intAdd::operator(int,int)的第二个参数
		sum = intAdd(10,intNegate(10));	//sum = 0
表14.2所列的类型定义在functional头文件中。
					表14.2:		标准库函数对象
		算术					关系						逻辑
	plus<Type>			equal_to<Type>			logical_and<Type>
	minus<Type>			not_equal_to<Type>		logical_or<Type>
	multiplies<Type>	greater<Type>			logical_not<Type>
	divides<Type>		greater_equal<Type>
	modulus<Type>		less<Type>
	negate<Type>		less_equal<Type>

在算法中使用标准库函数对象
	表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况下排序算法使用operator<将序列
按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。该类将产生一个调用运算符并负责执行排
序类型的大于运算。例如，如果svec是一个vector<string>.
		//传入一个临时的函数对象用于执行两个string对象的>比较运算
		sort(svec.begin(),svec.end(),greater<string>());
则上面的语句将按照降序对svec进行排序。第三个实参是greater<string>类型的一个未命名的对象，因此当
sort比较元素时，不再是使用默认的<运算符，而是调用给定的greater函数对象。该对象负责在string元素之间执行>比较运
算。
	需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过比较两个无关指针将产生未定义的行为，
然而我们可能会希望通过比较指针的内存地址来sort指针的vector。直接这么做将产生未定义的行为，因此我们可以使用一个
标准库函数对象来实现该目的:
		vector<string *>nameTable;		//指针的vector
		//错误:nameTable中的指针彼此之间没有关系，所以<将产生未定义的行为
		sort(nameTable.begin(),nameTable.end(),[](string *a,string *b){return a < b;});
		//正确:标准库规定指针的less是定义良好的
		sort(nameTable.begin(),nameTable.end(),less<string *>());
关联容器使用less<key_type>对元素排序，因此我们可以定义一个指针的set或者在map中使用指针作为关键值而无须直接
声明less。（因为set或map中会自动对这些进行排序)。

14.8.3	可调用对象与function
	C++语言中有几种可调用的对象:函数，函数指针、lambda表达式、bind创建的对象，以及重载了函数调用运算符的
类。
	和其他对象一样，可调用的对象也有类型。例如，每个lambda有它自己唯一的(未命名)类类型；函数及函数指针的类型
则由其返回值类型和实参类型决定，等等。
	然而，两个不同类型的可调用对象却可能共享同一种调用形式。调用形式指明了调用返回的类型以及传递给调用的实参类型。
一种调用形式对应一个函数类型，例如:
		int(int,int);
是一个函数类型，它接受两个int、返回一个int。

不同类型可能具有相同的调用形式
	对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的
可调用对象:
		//普通函数
		int add(int i,int j){return i+j;}
		//lambda,其产生一个未命名的函数对象
		auto mod = [](int i,int j){return i + j;};
		//函数对象类
		struct divide{
			int operator()(int denominator,int divisor){
				return denominator / divisor;
			}
		};
上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式:
		int(int,int)
我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义有一个函数表(function table)
用于存储指向这些可调用对象的"指针"。当程序需要执行某个特定的操作时，从表中查找该调用的函数。
	C++语言中，函数表很容易通过map来实现。对于此例来说，我们使用一个表示运算符符号的string对象作为关键字；使用
实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引map，然后调用找到的那个元素。
	假定我们的所有函数都相互独立，并且只处理关于int的二元运算，则map可以定义成如下形式:
		//构建从运算符得到函数指针的映射关系，其中函数接受两个int，返回一个int
		map<string,int (*)(int,int)>binops;
我们可以按照下面的形式将add的指针添加到binops中:
		//正确:add是一个指向正确类型函数的指针
		binops.insert({"+",add});	//{"+",add}是一个pair
但是我们不能将mod或者divide存入binops:
		binops.insert({"%",mod});	//错误:mod不是一个函数指针
问题在于mod是个lambda表达式，而每个lambda有它自己的类类型，该类型与存储在binops中的值类型不匹配。。
注意:
	调用形式和一个可调用函数的本身类型不是一回事。调用形式，是指的你的调用的时候需要的实参以及返回值的类型。
但是lambda表达式这种也可以是相应的实参以及返回类型，但是其本身却是一个类。

标准库function类型
	我们可以使用一个名为function的新标准库类型解决上述问题，function定义在functional头文件中，表14.3
列举出了function定义的操作：
			表14.3：function的操作
	function<T>	f;			f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该
							与函数类型T相同(即T是retType(args))
	function<T>	f(nullptr)	显示地构造一个空function
	function<T>	f(obj)		在f中存储可调用对象obj的副本
	f						将f作为条件：当f含有一个可调用对象时为真；否则为假
	f(args)					调用f中的对象，参数是args
	定义为function<T>的成员类型
	result_type				该function类型的可调用对象返回的类型

	argument_type			当T有一个或两个实参时定义的类型，如果T只有一个实参，则
	first_argument_type		argument_type是该类型的同义词；如果T有两个实参，则
	second_argument_type	first_argument_type和second_argument_type
							分别代表两个实参的类型
function是一个模板，和我们使用过的其他模板一样，当创建一个具体的function类型时我们必须提供额外的信息。
在此例中，所谓额外的信息是指该function类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指
定类型:
		function<int(int,int)>
在这里我们声明一个function类型，它可以表示接受两个int、返回一个int的可调用对象。因此，我们可以用这个
新声明的类型表示任意一种桌面计算器用到的类型:
		function<int(int,int)> f1 = add;	//函数指针
		function<int(int,int)> f2 = divide();//函数对象类的对象
		function<int(int,int)> f3 = [](int i,int j){return i * j;};	//lambda
		cout<<f1(4,2)<<endl;		//打印6
		cout<<f2(4,2)<<endl;		//打印2
		cout<<f3(4,2)<<endl;		//打印8
使用这个function类型我们可以重新定义map:
		//列举了可调用对象与二元运算符对应关系的表格
		//所有可调用对象都必须接受两个int、返回一个int
		//其中的元素可以是函数指针、函数对象或者lambda
		map<string,function<int(int,int)>> binops;
我们把所有可能调用对象，包含函数指针、lambda或者函数对象在内，都添加到这个map中:
		map<string,function<int(int,int)>> binops = {
			{"+",add},							//函数指针
			{"-",std::minus<int>()},			//标准库函数对象
			{"/",divide()},						//用户定义的函数对象
			{"*",[](int i,int j){return i*j;},	//未命名的lambda
			{"%",mod}							//命令了的lambda对象
};

我们的map中包含5个元素，尽管其中的可调用对象的类型各不相同，我们仍然能够把所有这些类型都存储在同一个
function<int(int,int)>类型中。
	一如往常，当我们索引map时得到的关联值的一个引用。如果我们索引binops，将得到function对象的引用。function
类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象:
		binops["+"](10,5);		//调用add(10,5);
		binops["-"](10,5);		//调用minus<int>>对象的调用运算符
		binops["/"](10,5);		//调用divide对象的调用运算符
		binops["*"](10,5);		//调用lambda函数对象
		binops["%"](10,5);		//调用lambda函数对象
我们依次调用了binops中存储的每个操作。在第一个调用中，我们获得的元素存放着一个指向add函数的指针，因此调用
binops["+"](10,5)实际上是使用该指针调用add,并传入10,5。下面的调用都是同样的道理。

重载的函数与function
	我们不能(直接)将重载函数的名字存入function类型的对象中:
		int add(int i,int j){return i + j;}
		Sales_data add(const Sales_data&,const Sales_data &);
		map<string,function<int(int,int)>> binops;
		binops.insert({"+",add});	//错误:哪个add?这样会导致找不到相应的add版本
解决上述二义性问题的一条路径是存储函数指针而非函数的名字:
		int (*fp)(int,int) = add;
		binops.insert({"+",fp});		//正确:fp指向一个正确的add版本
同样，我们也能使用lambda来消除二义性:
		//正确:使用lambda来指定我们希望使用的add版本
		binops.insert({"+",[](int a,int b){return add(a,b);});
lambda内部的函数调用传入了两个int，因此该调用只能匹配接受两个int的add,而这也正是执行lambda时真正调用
的函数。
注意:
	新版本标准库中的function类与旧版本的unary_function和binary_function没有关联，后两个类已经被
更适用的bind函数替代了。

14.9	重载、类型转换与运算符
	在7.5.4节中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对
象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类
型转换运算符共同定义了类类型转换，这样的转换有时也被称作用户定义的类型转换。

14.9.1	类型转换运算符
	类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下
所示:
		operator type()const;
其中type表示某种类型。类型转换运算符可以面向任意类型(除了void)进行定义，只要该类型能作为函数的返回类型。因
此我们不允许转换成数组或函数类型，但允许转换成指针(包括数组指针及函数指针)或者引用类型。
	类型转换运算符既没有显示地返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变
待转换对象的内容，因此，类型转换运算符一般被定义成const成员。
注意:
	一个；类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须是空的。类型转换函数通常应该是const。

定义含有类型转换运算符的类
	举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数:
		class SmallInt{
		public:
			SmallInt(int i=0):val(i)
			{
				if(i<0 || i > 255)
					throw std::out_of_range("Bad SamllInt value");
			}
			operator int() const { return val;}
		private:
			std::size_t val;
		};
我们的SmallInt类既定义了向类类型的转换，也定义从类类型向其他类型的转换。其中，构造函数将算术类型的值转换成
SmallInt对象，而类型转换运算符将SmallInt对象转换成int:
		SmallInt si;
		si = 4;				//首先将4隐式地转换成SmallInt，然后调用SmallInt::operator=
		si + 3;				//首先将si隐式地转换成int,然后执行整数的加法。
	尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准(内置)类型转换
之前或之后，并与其一起使用。因此，我们可以将任何算术类型传递给SmallInt的构造函数。类似的，我们也能使用
类型转换运算符将一个SmallInt对象转换成int，然后再将所得的int转换成任何其他算术类型:
		//内置类型转换将double实参转换成int
		SmallInt si = 3.14;	//调用SmallInt(int)构造函数
		//SmallInt的类型转换运算符将si转换成int
		si + 3.14;		//内置类型转换将所得的int继续转换成double
因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。
同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值:
		class SmallInt;
		operator int(SmallInt &);		//错误:不是成员函数，并且有形参
		class SmallInt{
		public:
			int operator int() const;		//错误:指定了返回类型
			operator int(int = 0) const;	//错误:参数列表不为空
			operator int*()const {return 42;}//错误:42不是一个指针

提示:避免过度使用类型转换函数
	和使用重载运算符的经验一样，明智地使用类型转换运算符也能极大地简化类设计者的工作，同时使得使用类更加容
易。然而，如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。
	例如，假设某个类表示Date，我们也许会为它添加一个从Date到int的转换。然而，类型转换函数的返回值应该
是什么?一种可能解释是，函数返回一个十进制数，依次表示年、月、日。例如，July 30,1989　可能转换为int值
是19890730。同时，还存在另一种合理的解释。即类型转换运算符返回的int表示从某个时间节点(比如January 1,
1970)开始经过的天数。显然这两种理解都合情合理，毕竟从形式上看它们产生的效果都是越靠后的日期对应的整数值
越大，而且两种转换都有实际的用处。
	问题在于Data类型的对象和int类型的值之间不存在明确的一对一映射关系。因此在此例中，不定义该类型转换运
算符也许会更好。作为替代的手段，类可以定义一个或多个普通的成员函数以从不同形式中提取所需的信息。

类型转换运算符可能产生意外结果
	在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感觉比较意外，而不
是感觉受到了帮助。然而这条经验法则存在一种例外情况:对于类来说，定义向bool的类型转换还是比较普通的现象。
	在C++标准的早期版本中，如果类想定义一个向bool的类型转换，则它常常遇到一个问题：因为bool是一种算术类
型，所以类类型的对象转换成bool后就能被用在任何需要算数类型的上下文中。这样的类型转换可能引发意想不到的结
果，特别是当istream含有向bool的类型转换时，下面的代码将编译通过:
		int i =42;
		cin << i;			//如果向bool的类型转换不是显示的，则该代码在编译器看来将是合法的。
这段程序试图将输出运算符作用于输入流。因为istream本身并没有定义<<，所以本来代码应该产生错误。然而，该代
码能使用istream的bool类型转换运算符将cin转换成bool，而这个bool值接着会被提升成intt并用作内置的左移
运算符的左侧运算对象。这样一来，提升后的bool值最终会被左移42个位置。这一结果显然与我们的预期大相径庭。

显示的类型转换运算符
	为了防止这样的异常情况发生，C++11新标准引入了显示的类型转换运算符:
		class SmallInt{
		public:
			//编译器不会自动执行这一类型转换
			explicit operator int() const { return val; }
			//其他成员与之前的版本一致
		};
和显示的构造函数一样，编译器(通常)也不会将一个显示的类型转换运算符用于隐式类型转换:
		SmallInt si = 3;		//正确:SmallInt的构造函数不是显示的
		si + 3;		//错误:此处需要隐式的类型转换，但类的运算符是显示的
		static_cast<int>{si} + 3;	//正确:显示地请求类型转换
当类型转换运算符是显示的时，我们也能执行类型转换，不过必须通过显示的强制类型转换才可以。
	该规定存在一个例外，即如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。换句话说，当表达式出
现在下列位置时，显示的类型转换将被隐式地执行:
		>>>	if、while 及 do 语句的条件部分
		>>>	for 语句头的条件表达式
		>>>	逻辑非运算符(!)、逻辑或运算符(||)、逻辑与运算符(&&)的运算对象
		>>>	条件运算符(? :)的条件表达式。

转换为bool
	在标准库的早期版本中，IO类型定义向void*的转换规则，以求避免上面提到的问题。在C++11新标准下，IO标准库
通过定义一个向bool的显式类型转换实现同样的目的。无论我们什么时候在条件中使用流对象，都会使用为IO类型定义的
operator　bool。例如:
		while(std::cin >> value)
while语句的条件执行输入运算符，它负责将数据读入到value并返回cin。为了对条件求值，cin被istream operator bool
类型转换函数隐式地执行了转换。如果cin的条件状态是good，则该函数返回为真；否则该函数返回为假。
注意:
	向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的

14.9.2	避免有二义性的类型转换
	如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写
的代码将很可能会具有二义性。
	在两种情况下可能产生多重转换路径。第一种情况是两个类提供相同的类型转换:例如，当A类定义了一个接受B类对象的
转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说它们提供了相同的类型转换。
	第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算
术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。
注意:
	通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。

实参匹配和相同类型转换
	在下面的例子中，我们定义了两种B转换成A的方法：一种使用B的类型转换运算符、另一种使用A的以B为参数的构造函数:
		struct B;
		struct A{
			A() = default;
			A(const B&);	//把一个B转换成A
			//其他数据成员
		};
		struct B{
			operator A() const;	//也是把一个B转换成A
			//其他数据成员
		};
		A f(const A&);
		B b;
		A a = f(b);		//二义性错误:含义是f(B::operator A())
						//还是f(A::A(const B&))?
因为同时存在两种由B获得A的方法，所以造成编译器无法判断应该运行哪个类型转换，也就是说，对f的调用存在二义性。
该调用可以使用以B为参数的A的构造函数，也可以使用B当中把B转换成A的类型转换运算符。因为这两个函数效果相当，
难分伯仲，所以该调用将产生错误。
	如果我们确实想执行上述的调用，就不得不显示地调用类型转换运算符或者构造函数:
		A a1 = f(b.operator A());		//正确:使用B的类型转换运算符
		A a2 = f(A(b));					//正确:使用A的构造函数
值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。

二义性与转换目标为内置类型的多重类型转换
	另外如果类定义了一组类型转换，它们的转换源(或者转换目标)类型本身可以通过其他类型转换联系在一起，则同样会
产生二义性的问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算
术类型的类型转换运算符。
	例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型:
		struct A{
			A(int = 0);		//最好不要创建两个转换源都是算术类型的类型转换
			A(double);	
			operator int() const;//最好不要创建两个转换对象都是算术类型的类型转换
			operator double() const;
			//其他成员
		};
		void f2(long double);
		A a;
		f2(a);		//二义性错误:含义是f(A::operator int())
					//还是f(A::operator double())?
		long lg;
		A a2(lg);	//二义性错误:含义是A::A(int)还是A::A(double)?
在对f2的调用中，哪个类型转换都无法精确匹配long double。然而这两个类型转换都可以使用，只要后面再执行一次生成
long double的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。
	当我们试图使用long初始化a2时也遇到了同样的问题，哪个构造函数都无法精确匹配long类型。它们在使用构造函数前
都要求先将实参进行类型转换:
		>>>	先执行long到double的标准类型转换，再执行A(double)
		>>>	先执行long到int的标准类型转换，再执行A(int)
编译器没办法区分这两种转换序列的好坏，因此该调用将产生二义性。
	调用f2及初始化a2的过程之所以会产生二义性，根本原因是它们所需的标准类型转换级别一致。当我们使用用户定义的
类型转换时，如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程:
		short s = 42;
		//把short提升成int优于把short转换成double
		A a3(s);			//使用A:A(int)
在此例中，把short提升成int的操作要优于把short转换成double的操作，因此编译器将使用A::A(int)构造函数构造
a3，其中实参是s(提升后的)的值。
注意:
	当我们使用两个用户定义的类型转换时，如果转换函数之前或之后在标准类型转换，则标准类型转换将决定最佳匹配到底
是哪个。
提示:类型转换与运算符
	要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。尤其是当类同时定义了类型转换运算符
及重载运算符时特别容易产生二义性。以下的经验规则可能对你有所帮助:
		>>>	不要令两个类执行相同类型转换:如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换
目标是Foo类的类型转换运算符
		>>>	避免转换目标是内置算术类型的类型转换，特别是当你已经定义了一个转换成算术类型的类型转换时，接下来:
		----不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符，则类型转换操作将转换你的类型对象，
然后使用内置的运算符
		----不要定义转换到多种算术类型的类型转换。让标准类型转换成向其他算术类型转换的工作。
一言以蔽之:除了显示地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些"显然正确"的非显示
构造函数。

重载函数与转换构造函数
	当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一个可行
匹配，则这些类型转换一样好。
	举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将
进一步提升:
		struct C{
			C(int);
			//其他成员
		};
		Struct D{
			D(int);
			//其他成员
		};
		void mainp(const C&);
		void mainp(const D&);
		mainp(10);		//二义性错误:含义是mainp(C(10))还是mainp(D(10))
其中C和D都包含接受int的构造函数，两个构造函数各自匹配mainp的一个版本。因为此调用将具有二义性:它的含义可能
是把int转换成C，然后调用mainp的第一个版本，然后调用mainp的第一个版本；也可能是把int转换成D，然后调用
mainp的第二个版本。
	调用者可以显示地构造正确的类型从而消除二义性:
	mainp(C(10));		//正确:调用mainp(const C&);
注意:
	如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。

重载函数与用户定义的类型转换
	当调用重载函数时，如果两个(或多个)用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个
过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数通过同一个类型转换函数得到匹配时，我们才会考
虑其中出现的标准类型转换。
	例如当我们调用mainp时，即使其中一个类定义了需要对实参进行标准类型转换的构造函数，这次调用仍然会具有二义性。
		struct E{
			E(double);
			//其他成员
		};
		void mainp2(const C&);
		void mainp2(const E&);
		//二义性错误:两个不同的用户定义的类型转换都能用在此处
		mainp2(10);	//含义是mainp2(C(10))还是mainp2(double(10));
在此例中，C有一个转换源为int的类型转换，E有一个转换源为double的类型转换。对于mainp2(10)来说，两个mainp2
函数都是可行的:
		>>>	mainp2(const C&)是可行的，因为C有一个接受int的转换构造函数，该构造函数与实参精确匹配。
		>>>	mainp2(const E&)是可行的，因为E有一个接受double的转换构造函数，而且为了使用该函数
我们可以利用标准类型转换把int转换成所需的类型。
因为调用重载函数所请求的用户定义的类型转换不止一个且彼此不同，所以该调用具有二义性。即使其中一个调用需要额外
的标准类型转换而另一个调用可能精确匹配，编译器也会将该调用标示为错误。

注意:
	在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型
转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。

14.9.3	函数匹配与重载运算符
	重载的运算符也是重载的函数。因此，通用的函数匹配规则同样适用于判断给定的表达式中到底应该使用内置运算符
还是重载的运算符。不过当运算符函数出现在表达式中时，候选函数集的规模比我们使用调用运算符调用函数时更大。如
果a是一种类类型，则表达式a sym b可能是:
		a.operator sym(b);			//a有一个operatorr sym成员函数
		operator sym(a,b);			//operator sym是一个普通函数
和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。(比如说a+b，这个就不知
道是成员函数还是非成员函数)
	当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，
如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内。
	当我们调用一个命名的函数时，具有改名字的成员函数和非成员函数不会彼此重载。这是因为我们调用命名函数的语法
形式对于成员函数和非成员函数来说是不相同的。当我们通过类类型的对象(或者该对象的指针及引用)进行函数调用时，只
考虑该类的成员函数还是非成员函数，因此二者都应该在考虑的范围之内。
注意:
	表达式中运算符的候选函数集应该包括成员函数，也应该包括非成员函数。
举个例子，我们为SmallInt类定义一个加法运算符:
		class SmallInt{
			friend SmallInt operator+(const SmallInt &,const SmallInt &);
		public:
			SmallInt(int = 0);			//转换源为int的类型转换
			operator int() const { return val;}	//转换目标为int的类型转换
		private:
			std::size_t val;
		};
可以使用这个类将两个SmallInt对象相加，但如果我们试图执行混合模式的算术运算，就将遇到二义性的问题:
		SmallInt s1,s2;
		SmallInt s3 = s1 + s2;		//使用重载的operator+
		int i = s3 + 0;		//二义性错误
	第一条加法语句接受两个SmallInt值并执行+运算符的重载版本。第二条加法语句具有二义性:因为我们可以把
0转换成SmallInt，然后使用SmallInt的+;或者把s3转换成int，然后对于两个int执行内置的加法运算。
注意:
	如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置
运算符的二义性问题。
