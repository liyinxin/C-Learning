						第14章	重载运算与类型转换
内容
--------------------------------
	14.1	基本概念
	14.2	输入和输出运算符
	14.3	算术和关系运算符
	14.4	赋值运算符
	14.5	下标运算符
	14.6	递增和递减运算符
	14.7	成员访问运算符
	14.8	函数调用运算符
	14.9	重载、类型转换与运算符
---------------------------------
	在第四章中我们看到，C++语言定义了大量运算符以及内置类型的自动转换规则。这些特性使得程序员能编写出形式
丰富、含有多种混合类型的表达式。
	当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义；同时，我们也能定义类类型之间的转换规则。
和内置类型转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。
	当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义。明智地使用运算符重载能令我
们的程序更易于编写和阅读。举个例子，因为在Sales_item类中定义了输入、输出和加法运算符，所以可以通过下述形式
输出两个Sales_item的和:
		cout<<item1 + item2;	//输出两个Sales_item的和
相反的，由于我们的Sales_data类还没有重载这些运算符，因此它的加法代码显得比较冗长而不清晰:
		print(cout,add(data1,data2));	//输出两个Sales_data的和

14.1	基本概念
	重载的运算符是具有特殊名字的函数:它们的名字由关键字operator和其后要定义的运算符号共同组成。重载的运算符
也包含返回类型、参数列表以及函数体。重载运算符函数的参数数量与该运算对象数量一样多，一元运算符有一个参数，二元
运算符有两个，对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数
调用运算符operator()之外，其他重载运算符不能含有默认实参。
	如果一个运算符函数是成员函数，则它的第一个(左侧)运算对象绑定到隐式的this指针上，因此，成员运算符函数的(
显示)参数数量比运算符的运算对象总数少一个。
注意:
	当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显示)参数数量比运算对象的数量
少一个。

对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数:
		//错误:不能为int重定义内置的运算符
		int operator+(int,int);
这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变运算符的含义。
	我们可以重载大多数(但不是全部)运算符。表14.1指明了哪些运算符可以被重载哪些不行。我们将在19.1.1节介绍重
载new和delete的方法。我们只能重载已有的运算符，而无权发明新的运算符号。例如，我们不能提供operator**来执
行幂操作。有四个符号(+,-,*,&)既是一元运算符，也是二元运算符，所有这些运算符能被重载，从参数的数量我们可以推
断出到底定义的是哪种运算符。
	对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致，不考虑运算对象类型的话:
		x == y + z;
永远等价于x == (y + z);
				表14.1	运算符
					可以被重载的运算符
		+	-	*	/	%	^	&	|	~	!
		,	=	<	>	<=	>=	++	--	<<	>>
		==	!=	&&	||	+=	-=	/=	%=	^=	&=
		|=	*=	<<=	>>=	[]	()	->	->*	new	new[]
		delete	delete[]
					不能被重载的运算符
		::	.*	.	? :

直接调用一个重载的运算符函数
	通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式"调用"重载的运算符。然而，我们也能像调用
普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参:
		//一个非成员运算符函数的等价调用
		data1 + data2;			//普通的表达式
		operator+(data1,data2);	//等价的函数调用
这两次调用是等价的，它们都调用了非成员函数operator+，传入data1作为第一个实参、传入data2作为第二个实参。我
们调用其他成员函数一样显示地调用成员函数。具体做法是，首先指定运行函数的对象(或指针)的名字，然后使用点运算符(或
箭头运算符)访问希望调用的函数:
		data1 += data2;			//基于"调用"的表达式
		data1.opertor+=(data2);	//对成员运算符函数的等价调用
这两条语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。

某些运算符不应该被重载
	回忆之前介绍过的，某些运算符指定了运算对象的求值顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关
于运算对象求值顺序的规划无法应用到重载的运算符上。特别是，逻辑与运算符，逻辑或运算符和逗号运算符的运算对象求值
顺序规则无法保留下来。除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被
求值。
	因为上述运算符的重载版本无法保留求值顺序和取地址运算符:C++语言已经定义了这两种运算符用于类类型对象时特殊含
义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则他们的行
为将异于常态，从而导致类的用户无法适应。
注意:
	通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符

使用与内置类型一致的含义
	当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需要哪些操作之后，才能思考到底应该把每
个类操作设成普通函数还是重载运算符。如果某些操作在逻辑上与运算符相关，则他们适合于定义成重载的运算符:
		>>>	如果类执行IO操作，则定义意味运算符使其与内置类型的IO保持一致
		>>>	如果类的某个操作是检查相等性，则定义operator==;如果类有了operator==，意味着它通常也应该有
operator!=。
		>>>	如果类包含一个内在的单序比较操作，则定义operator<；如果类有了operator<，则它应该也定义
含有其他关系操作。
		>>>	重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，
算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。
提示:尽量明智的使用运算符重载
	每个运算符在用于内置类型时都有比较明确的含义。以二元+运算符为例，它明显执行的是加法操作。因此，把二元+运算符
映射到类类型的一个类似操作上可以极大简化记忆。例如，对于标准库类型string来说，我们就会使用+把一个string对象连接
到另一个后面，很多编程语言都有类似的用法。
	当在内置的运算符和我们自己的操作之间存在逻辑映射关系时，运算符重载的效果最好。此时，使用重载的运算符显然比另
一个名字更自然也更直观。不过，过分滥用运算符重载也会使我们的类变得难以理解。
	在实际编程过程中，一般没有特别明显的滥用运算符重载的情况。例如，一般来说没有哪个程序员会定义operator+并让它
执行减法操作。然而经常发生的一种情况是，程序员可能会强行扭曲运算符的"常规"含义使得其适应某种给定的类型，这显然是我
们不希望发生的。因此我们的建议是:只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不
同的理解，则使用这样的运算符将产生二义性。

赋值和复合赋值运算符
	赋值运算符的行为与复合版本的类似:赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回左侧运算对象
的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。如果类含有算术运算符或者位运算符，则最好也提供对应的复
合赋值运算符。无须赘言，+=运算符的行为显然应该与其内置版本一致，即先执行+，再执行=。

选择作为成员或者非成员
	当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通非成员函数。在某些时候我们别无
选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。
	下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择:
		>>>	赋值(=)、下标([])、调用(())和成员访问箭头(->)运算符必须是成员。
		>>>	复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。
		>>>	改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
		>>>	具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因为它们通常应
该是普通的非成员函数。
	程序员希望在含有混合类型的表达式中使用对称性运算符。例如，我们能求一个int和double的和，因为它们中的任意一
个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定
义成非成员函数。
	当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。例如:
		string s = "world";
		string t = s + "!";	//正确:我们能把一个const char *加到一个string对象中
		string u = "hi" + s;//如果+是string的成员，则产生错误
如果operator+是string类的成员，则上面的第一个加法等价于s.opertor("!")。同样的，"hi"+s等价于
"hi".operator+(s)。显然"hi"的类型是const char *，这是一种内置类型，根本就没有成员函数。所以+不是string的
成员运算符。因为"hi"+s;也是可以成立的。
	因为string将+定义成了普通的非成员函数，所以"hi"+s等价于operattor("hi",s)。和任何其他函数调用一样，
每个实参都是能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成
string。

14.2	输入和输出运算符
	如我们所知，IO标准库分别使用>>和<<执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型
的版本，而类则需要自定义适合其对象的新版本以支持IO操作。
14.2.1	重载输出运算符<<
	通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量是因为向流写入
内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。
	第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复
制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。
	为了与其他输出运算符保持一致，operator<<一般需要返回它的ostream形参。

Sales_data的输出运算符
	举个例子，我们按照如下形式编写Sales_data的输出运算符:
		ostream &operator<<(ostream &os,const Sales_data &item)
		{
			os << item.isbn()<<" "<<item.units_sold<<" "
			   << item.revenue<< " "<<item.avg_price();
			return os;
		}
除了名字之外，这个函数与之前的print函数完全一样。打印一个Sales_data对象意味着要分别打印它的三个数据
成员以及通过计算得到的平均销售价格，每个元素以空格隔开。完成输出后，运算符返回刚刚使用的ostream的引用。

输出运算符尽量减少格式化操作
	用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符
打印了换行符，则用户就无法在对象的同一行内接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使
用户有权控制输出的细节。
注意:
	通常，输出运算符应该主要负责打印对象的内容而菲菲控制格式，输出运算符不应该打印换行符。

输入输出运算符必须是非成员函数
	与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则它们的左侧运算对象
将是我们的类的一个对象:
		Sales_data data;
		data<<cout;		//如果operator<<是Sales_data的成员
假设输入输出运算符是某个类的成员，则它们必须是istream或ostream的成员。然而这两个类属于标准库，并且我们
无法给标准库中的类添加任何成员。
	因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然,IO运算符通常需要读写类的非公有数据
成员，所以IO运算符一般被声明为友元。

14.2.2	重载输入运算符>>
	通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用。
该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这
个对象中。

Sales_data的输入运算符
	举个例子，我们将按照如下形式编写Sales_data的输入运算符:
		istream &operator>>(istream &is,Sales_data &item)
		{
			double price;
			is >> item.bookNo >> item.units_sold>>price;
			if(is)	//检查输入是否成功
				item.revenue = item.units_sold * price;
			else
				item = Sales_data();	//输入失败：对象
			return is;
		}
除了if语句之外，这个定义与之前的read函数完全一样。if语句检查读取操作是否成功，如果发生了IO错误，则运算符将给定
的对象重置为空Sales_data，这样可以确保对象处于正确的状态。
注意:
	输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

输入时的错误
	在执行输入运算符时可能发生下列错误:
		>>>	当流含有错误类型的数据时读取操作可能失败。例如在读取完bookNo后，输入运算符假定接下来读入的是两个
数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都失败。
		>>>	当读取操作到达文件中末尾或者遇到输入流的其他错误时也会失败。
在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据后赶在使用这些数据前一次性检查:
		if(is)			//检查输入是否成功
			item.revenue = item.units_sold * price;
		else
			item = Sales_data(();	//输入失败:对象被赋予默认状态
如果读取操作失败，则price的值将是未定义的。因此，在使用price前我们需要首先检查输入流的合法性，然后才能执行计算
并将结果存入revenue。如果发生了错误，我们无须在意到底是哪部分输入失败，只要将一个新的默认初始化的Sales_data对
象赋予item从而将其重置为空Sales_data就可以了。执行这样的赋值后，item的bookNo成员将是一个空string，
revenue和units_sold成员等于0。
	如果在发生错误前，已经有部分被改变，则适时地将对象置为合法状态显得异常重要。例如在这个输入运算符中，我们
可能在成功读取新的bookNo后遇到错误，这意味着对象的units_sold和revenue成员并没有改变，因此有可能会将这两
个数据与一条完全不匹配的bookNo组合在一起。
	通过将对象置为合法的状态，我们能(略微)保护使用者免于收到输入错误的影响。此时的对象出于可用状态，即它的成
员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是一体的。
注意:
	当读取操作发生错误时，输入运算符应该负责从错误中恢复。

标示错误
	一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查bookNo是否符合规范的格式。在这
样的例子中，即使从技术上来看IO是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算
符只设置failbit。除此之外，设置eofbit标示文件耗尽，而设置badbit表示流被破坏。最好的方式是由IO标准库自己
来标示这些错误。

14.3	算术和关系运算符
	通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不
需要改变运算对象的状态，所以形参都是常量的引用。
	算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，
操作完成后返回该局部变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此
时，最有效的方式是使用复合赋值来定义算术运算符:
		//假设两个对象指向同一本书
		Sales_data operator+(const Sales_data &lhs,const Sales_data &rhs)
		{
			Sales_data sum = lhs;	//把lhs的数据成员拷贝给sum
			sum += rhs;		//将rhs加到sum中
			return sum;
		}
这个定义由于原来的add函数是完全等价的。我们lhs拷贝给局部变量sum，然后使用Sales_data的复合赋值运算符将
rhs的值加到sum中，最后返回sum的副本。
注意:
	如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。

14.3.1相等运算符
	通常情况下，C++中的类通过
