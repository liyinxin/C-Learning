						第17章	标准库特殊设施
	第IV部分将介绍C++和标准库的一些附加特性，虽然这些特性在特定情况下很有用过，但并非每个C++程序员
都需要它们。这些特性分类两类:一类对于求解大规模的问题很有用；另一类适用于特殊问题而非通用问题。针对特
殊问题的特性既有属于C++语言的，也有属于标准库的。
	在第十七章中我们介绍四个具有特殊目的的标准库设施:bitset类和三个新标准库设施(tuple、正则表达
式和随机数)。我们还将介绍IO库中某些不常用的部分。
	第18章中介绍异常处理、命名空间和多重继承。这些特性在设计大型程序时是最有用的。
	即使是一个程序员就能编写的足够简单的程序，也能从异常处理机制受益，这也是为什么我们在第5章介绍了
异常处理的基本知识的原因。但是，对于需要大型团队才能够完成的程序设计问题，运行时错误处理才显得更为
重要也更难于管理。在第18章中，我们会额外介绍一些有用的异常处理设施。我们还将详细讨论异常是如何处理
的，并展示如何定义和使用自己的异常类。这一章还会介绍新标准中异常处理方面的改进－－如何指出一个特定
函数不会抛出异常。
	大型应用程序通常会使用来自多个提供商的代码。如果提供商不得不将他们定义的名字放置在单一的命名空
间中，那么将多个独立开发的库组合起来是很困难的(如果能组合的话)。独立开发的库几乎必然会使用与其它库
相同的名字:对于某个库中定义的名字，如果另一个库中使用了相同的名字，就会引起冲突。为了避免名字冲突，
我们可以在一个namespace中定义名字。
	无论何时我们使用一个来自标准库的名字，实际上都是在使用名为std的命名空间中的名字。第18章中将
会展示如何定义我们自己的命名空间。
	第19章介绍几种用于特定类别问题的特殊工具和技术，包括如何重定义内存分配机制:C++对运行时类型识别
(RTTI)的支持－－允许我们在运行时才确定一个表达式的实际类型；以及如何定义和使用指向类成员的指针。类成
员指针不同于普通数据或函数指针。普通指针仅根据对象或函数的类型而变化，而类成员指针还必须反映成员所属
的类。我们还将介绍三种附加的聚合类型:联合、嵌套类和局部类。这一章最后将简要介绍一组本质上不可移植的语
言特性:volatile修饰符、位域以及链接指令。

内容
-------------------------------
	17.1	tuple类型
	17.2	bitset类型
	17.3	正则表达式
	17.4	随机数
	17.5	IO库再探
-------------------------------
最新的C++标准极大扩充了标准库的规模和范围。实际上，从1998年的第一版标准到2011年的最新标准，标准库部
分的篇幅增加了两倍以上。因此，介绍所有C++标准库类的知识大大超出了本书的范围。但是，有4个标准库设施，
虽然它们比我们已经介绍的其他标准库设施更特殊，但也足够通用，应该放在一本入门书籍中进行介绍。这4个标准
库设施是:tuple、bitset、随机数生成以及正则表达式。此外，我们还将介绍IO库中一些具有特殊目的的部分。
	标准库占据了新标准文本将近三分之一的篇幅。虽然我们不能详细介绍所有标准库设施。但仍有一些标准库设
施在很多应用中都是有用的:tuple、bitset、正则表达式以及随机数。我们还将介绍一些附加的IO库功能:格式
控制、未格式化IO和随机访问。

17.1	tuple类型
	tuple是类似pair的模板。每个pair的成员类型都不相同，但每个pair都恰有两个成员。不同tuple类型的
成员也不相同，但一个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple
类型的成员数目可以与另一个tuple类型不同。
	当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非
常有用的。表17.1列出了tuple支持的操作。tuple类型及其伴随类型和函数都定义在tuple头文件中。

				表17.1:		tuple支持的操作
tuple<T1,T2,....,Tn>t;				t是一个tuple，成员数为n，第i个成员的类型为Ti
									所有成员都进行值初始化
tuple<T1,T2,....,Tn<t(v1,v2,...,vn)	t是一个tuple，成员类型为T1...Tn，每个成员用
									对应的初始值vi进行初始化。此构造函数是explicit的
make_tuple(v1,v2,....,vn)			返回一个给定初始值初始化的tuple。tuple的类型
									从初始值的类型推断
									
									当两个tuple具有相同数量的成员且成员对应相等时，
	t1 == t2						两个tuple相等。这两个操作使用成员的==运算符来
	t1 != tw						完成。一旦发现某对成员不等，接下来的成员就不用
									比较了
	t1 relop t2						tuple的关系运算使用字典序。两个tuple必须具有
									相同数量的成员，使用<运算符比较t1的成员和t2的
									对应的成员

	get<i>(t)						返回t的第i个数据成员的引用；如果t是一个左值，
									结果是一个左值引用；否则，结果是一个左值引用。
									tuple的所有成员都是public的

									一个类模板，可以通过一个tuple类型来初始化。它
	tuple_size<tupleType>::value	有一个名为value的public　constexpr static
									数据成员，类型为size_t，表示给定tuple类
									型中成员的数量

tuple_element<i,tupleType>::type	一个类模板，可以通过一个整型常量和一个tuple类型
									来初始化。它有一个名为type的public成员，表示给
									定tuple类型中指定成员的类型
注意:
	我们可以将tuple看作一个"快速而随意"的数据结构。

17.1.1	定义和初始化tuple
	当我们定义一个tuple时，需要指出每个成员的类型:
		tuple<size_t,size_t,size_t>threeD;	//三个成员都设置为0
		tuple<string,vector<double>,int,list<int>> 
			someVal("constants",{3.14,2.718},42,{0,1,2,3,4,5})
当我们创建一个tuple对象时，可以使用tuple的默认构造函数，他会对每个成员进行值初始化；也可以像本例中
初始化someVal一样，为每个成员提供一个初始值。tuple的这个构造函数是explicit的，因此我们必须使用直
接初始化语法:
		tuple<size_t,size_t,size_t> threeD = {1,2,3};	//错误，拷贝初始化
		tuple<size_t,size_t,size_t>threeD(1,2,3);	//正确：使用构造函数
	类似make_pair函数，标准库定义了make_tuple函数，我们还可以用它来生成tuple对象:
		//表示书店交易记录的tuple，包含:ISBN、数量和每册书的价格
		auto item = make_tuple("0-999-22334-X",3,20.00);
类似make_pair,make_tuple函数使用初值的类型来推断tuple的类型。在本例中，item是一个tuple，类
型为tuple<const char*,int,double>。

访问tuple的成员
	一个pair总是有两个成员，这样，标准库就可以为他们命名first和second。但这种命名方式对tuple是
不可能的，因为一个tuple类型的成员数目是没有限制的。因此，tuple的成员都是未命名的。要访问一个tuple
的成员，就要使用一个名为get的标准库函数模板。为了使用get，我们必须指定一个显示模板实参，它指出我们
想要访问第几个成员。我们传递给get一个tuple对象，它返回指定成员的引用:
		auto book = get<0>(item);	//返回item的第一个成员
		auto cnt = get<1>(item);	//返回item的第二个成员
		auto price = get<2>(item)/cnt;	//返回item的最后一个成员
		get<2>(item) *= 0.8;		//打折20%
尖括号中的值必须是一个整型常量表达式。与往常一样，我们从0开始计数，意味这get<0>是第一个成员。
	如果不知道一个tuple准确的类型细节信息，可以用两个辅助类模板来查询tuple成员的数量和类型:
		typedef decltype(item) trans;
		//返回trans类型对象中成员的数量
		size_t sz = tuple_size<trans>::vlaue;	//返回3
		//cnt的类型与item中第二个成员相同
		tuple_element<1,trans>::type cnt = get<1>(item);	//cnts是一个int
为了使用tuple_size或tuple_element，我们需要知道一个tuple对象的类型。与往常一样，确定一个对象
的类型的最简单的方法就是使用decltype。在本例中，我们使用decltype来为item类型定义一个类型别
名，用它来实例化两个模板。
	tuple_size有一个名为value的public static数据成员，它表示给定tuple中成员的数量。tuple_element
模板除了一个tuple类型外，还接受一个索引值。它有一个名为type的public类型成员，表示给定tuple类型
中指定成员的类型。类似get，tuple_element所使用的索引也是从0开始计数的。

关系和相等运算符
	tuple的关系和相等运算符的行为类型容器的对应操作。这些运算符逐对比较左侧tuple和右侧tuple的成
员。只有两个tuple具有相同数量的成员时，我们才可以比较它们。而且，为了使用tuple的相等或不等运算符，
对没对成员使用==运算符必须都是合法的:为了使用关系运算符，对每对成员使用<必须都是合法的。例如:
		tuple<string,string>duo("1","2");
		tuple<size_t,size_t>twoD(1,2);
		bool b = (duo == twoD);	//错误;不能比较size_t和string
		tuple<size_t,size_t,size_t>threeD(1,2,3);
		b = (twoD < threeD);	//错误:成员数量不同
		tuple<size_t,size_t> origin(0,0);
		b = (origin<twoD);	//正确:bool为true
注意:
	由于tuple定义了<和==运算符，我们可以将tuple序列传递给算法，并且可以在无序容器中将tuple作
为关键字类型。

17.1.2	使用tuple返回多个值
	tuple的一个常见用途是从一个函数返回多个值。例如，我们的书店可能是多家连锁书店中的一家。每家书
店都有一个销售记录文件，保存每本书近期的销售数据。我们可能希望在所有书店中查询某本书的销售情况。
	假定每家书店都有一个销售记录文件。每个文件都将每本书的所有销售记录存放在一起。进一步假定已有一
个函数可以读取这些销售记录文件，为每个书店创建一个vector<Sales_data>，并将这些vector
保存在vector的vector中:
		//files中的每个元素保存一家书店的销售记录
		vector<vector<Sales_data>>files
我们将编写一个函数，对于一本给定的书，在files中搜索出售过这本书的书店。对每家有匹配销售记录的书店，
我们将创建一个tuple来保存这家书店的索引和两个迭代器。索引指出了书店在files中的位置，而两个迭代器
则标记了给定书籍在此书店的vector<Sales_data>中第一条销售记录和最后一条销售记录之后的位置。

返回tuple的函数
	我们首先编写查找给定书籍的函数，此函数的参数是刚刚提到的vector的vector以及一个表示书籍
ISBN的string。我们的函数将返回一个tuple的vector，凡是销售了给定书籍的书店，都在vector中有对
应的一项:
		//matches有三个成员:一家书店的索引和两个指向书店vector中元素的迭代器
		typedef tuple<vector<Sales_data>>::size_type,
					  vector<Sales_data>::const_iterator,
					  iterator<Sales_data>::const_iterator>> matches;
		//files保存每家书店的销售记录
		//findBook返回一个vector，每家销售了给定书籍的书店在其中都有一项
		vector<matches> findBook(const vector<vector<Sales_data>> &files,
								 const string &book)
		{
			vector<matches> ret;	//初始化为空vector
			//对于每家书店，查找与给定书籍匹配的记录范围(如果存在的话)
			for(auto it = files.cbegin();it != files.cend();++it)
			{
				//查找具有相同ISBN的Sales_data范围
				auto found = equal_range(it->cbegin(),it->cend(),book,compareIsbn);
				if(found.first != found.second)	//此书店销售了给定书籍
					ret.push_back(make_tuple<it-files.cbegin().found.first,found.second));
			}
			return ret;	//如果没有找到匹配记录的话，则ret为空
		}
for循环遍历files中的元素，每个元素都是一个vector。在for循环内，我们调用了一个名为equal_range
的标准库算法，它的功能与关联容器的同名成员类似。equal_range的前两个实参是表示输入序列的迭代器。第
三个参数是一个值。默认情况下，equal_range使用<运算符来比较元素。由于Sales_data没有<运算符，因
此我们传递给它一个指向compareIsbn函数的指针。
	equal_range算法返回一个迭代器pair，表示元素的范围。如果未找到book，则两个迭代器相等，表示
空范围。否则，返回的pair的first成员将表示第一条匹配的记录，second则表示匹配的尾后位置。

使用函数返回的tuple
	一旦我们创建了vector保存包含匹配的销售记录的书店，就需要处理这些记录了。在此程序中，对每家包
含匹配销售记录的书店，我们将打印其汇总销售信息:
		void reportResults(istream &in,ostream &os,
							const vector<vector<Sales_data>> &files)
		{
			string s;	//要查找的书
			while(in >> s){
				auto trans = findBook(files,s);	//销售了这本书的书店
				if(trans.empty()){
					cout<< s << "not found in any stores"<<endl;
					continue;	//获得下一本要查找的书，返回到while
				}
				for(const auto &store : trans)
					os<<"store "<<get<0>(store)<<" sales: "
					   <<accumulate(get<1>(store),
									get<2>(store),
									Sales_data(s))<<endl;
			}
		}
while循环反复读取名为int的istream来获得下一本要处理的书。我们调用findBook来检查s是否存在，并
将结果赋予trans。我们使用auto来简化trans类型的代码编写，它是一个tuple的vector。
	如果trans为空，表示没有关于s的销售记录。在此情况下，我们打印一条信息并返回，执行下一步while
循环来获取下一本要查找的书。
	for循环将store绑定到trans中的每个元素。由于不希望改变trans中的元素，我们将store声明为const
的引用。我们使用get来打印相关数据:get<0>表示对应书店的索引、get<1>表示第一次交易记录的迭代器、
get<2>表示尾后位置的迭代器。
	由于Sales_data定义了加法运算符，因此我们可以用标准库的accumulate算法来累加销售记录。我
们用Sales_data的接受一个string参数的构造函数来初始化一个Sales_data对象，将此对象传递给
accumulate作为求和的起点。此构造函数用给定的string初始化bookNo，并将units_sold和revenue
成员置为0。
accumulate函数的第三个参数是作为计算的起始点的:
		int sum = accumulate(vec.begin() , vec.end() , 42);
比方说这个，其中vec是int类型的vector，那么得到的结果就是42+vector中所有的int类型的数据
		string sum = accumulate(v.begin() , v.end() , string(" ")); 
这个的话，就是相应的v中所有的字符串连接起来了。
所以这里使用Sales_data(s)创建一个bookNo是s的对象，然后使用Sales_data中的加法函数，去把所有
bookNo是s的对象全部加起来。但是用Sales_data()的话，就不可以了，因为加法是用bookNo相同的才去加
的，所以必须得使用bookNo为s的对象才可以。

17.2	bitset
	在4.8节中我们介绍了将整型运算对象当作二进制位集合处理的一些内置运算符。标准库还定义了bitset
类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。bitset类定义在头文件bitset
中。

17.2.1	定义和初始化bitset
	表17.2列出了bitset的构造函数。bitset类是一个类模板，它类似array类，具有固定的大小。当我
们定义一个bitset时，需要声明它包含多少个二进制位:
		bitset<32> bitvec(10);	//32位:低位为1，其他位为0
大小必须是一个常量表达式。这条语句定义bitvec为一个包含32位的bitset。就像vector包含未命名的元
素一样，bitset中的二进制位也是未命名的，我们通过位置来访问它们。二进制位的位置是从0开始编号的。
因此，bitvec包含编号从0到31的32个二进制位。编号从0开始的二进制位被称为低位(low-order)，编号到
31结束的二进制位被称为高位。
			17.2:	初始化bitset的方法
	bitset<n> b;					b有n位:每一位为0。此构造函数是一个constexpr

									b是unsigned long long值u的n位的拷贝。如果n大于
	bitset<n> b(u);					unsigned long long的大小，则b中超出unsigned
									long long的高位被置为0。此构造函数是一个constexpr

									b是string　s从位置pos开始m个字符的拷贝。s只能包含字符
	bitset<n>b(s,pos,m,zero,one)	zero或one；如果s包含其他字符，构造函数会抛出
									invalid_argument异常。字符在b中分别保存为zero
									和one。pos默认为0，m默认为string::npos,zero默认为
									'0'，one默认为'1'
									与上一个构造函数相同，但从cp指向的字符数组中拷贝字符。
									如果未提供m，则cp必须指向一个C风格字符串。如果提供了
	bitset<n>b(cp,pos,m,zero,one)	m,则从cp开始必须至少有m个zero或one字符，因为未提供
									m的话，必须得有终止的地方，所以cp指向C风格的字符串，
									可以有\0结尾。
接受一个string或一个字符指针的构造函数是explicit的。在新标准中增加了为0和1指定其他字符的功能。

用unsigned值初始化bitset
	当我们使用一个整型值来初始化bitset时，此值将被转换为unsigned long long类型并被当做位
模式来处理。bitset中的二进制位将是此模式的一个副本。如果bitset的大小大于一个unsigned long
long中的二进制位数，则剩余的高位被置为0。如果bitset大大小小于一个unsigned long long中的二进制
位数，则只使用给定值中的低位，超出bitset大小的高位被丢弃。
		//bitvecl比初始值小了初始值中的高位被丢弃
		bitset<13>bitvecl(0xbeef);	//二进制位序列为1111011101111，本来的是1011 1110 1110 1111
		//bitvec2比初始化值大；它的高位被置为0
		bitset<20> bitvec2(0xbeef);	//二进制位序列为0000 1011 1110 1110 1111
		//在64位机器中，long long 0UUL是64个比特，因此!~0ULL是64个1
		bitset<128> bitvec3(~0ULL);	//0-63为为1;63-127位为0

从一个string初始化bitset
	我们可以从一个string或一个字符数组指针来初始化bitset。两种情况下，字符都直接表示位模式。与往
常一样，当我们使用字符串表示数时，字符串中下标最小的字符对应高位，反之亦然:
		bitset<32> bitvec4("1100");	//2、3位为1剩余两位为0
如果string包含的字符数比bitset少，则bitset的高位被置位0。
注意:
	string的下标编号习惯与bitset恰好相反；string中下标最大的字符(最右字符)用来初始化bitset
中的低位(下标为0的二进制位)。当你用一个string初始化一个bitset时，要记住这个差别。
	我们不必使用整个string来作为bitset的初始值，可以只用一个子串作为初始值:
		string str("1111111000000011001101");
		bitset<32> bitvec5(str,5,4);	//从str[5]开始的四个二进制位，1100
		bitset<32> bitvec6(str,str.size()-4);//使用最后四个字符
此处，bitvec5用str中从str[5]开始的长度为4的子串进行初始化。与往常一样，子串的最右字符表示最低
位。因此，bitvec5中第3位到第0位被设置为1100，剩余位被设置为0。传递给bitvec6的初始值是一个
string和一个开始位置，因此bitvec6用str中倒数第四个字符开始的子串进行初始化。bitvec6中剩余二
进制位被初始化为0。下图说明了这两个初始化过程。
		从str拷贝的元素								用str初始化
	str											bitvec5
    |1||1||1||1||1||1||1||0||0||0||...|			|....||0||0||0||1||1||0||0|
				    |		 	|							 |           | 
				(首元素)str[5] str[5+4](尾元素)			  bitvec5[4]  bitvec[0]

17.2.2	bitset操作
	bitset操作定义了多种检测或设置一个或多个二进制位的方法。bitset类还支持我们在4.8节中介绍
过的位运算符。这些运算符用于bitset对象的含义与内置运算符用于unsigned运算对象相同。
			表17.3:	bitset操作
	b.any()					b中是否存在置位的二进制位
	b.all()					b中所有位置都置位了吗
	b.none()				b中不存在置位的二进制位吗
	b.count()				b中置位的位数
	b.size()				一个constexpr函数，返回b中的位数
	b.test(pos)				若pos位置的位是置位的，则返回true，否则返回false
	b.set(pos,v)			将位置pos处的位置设置为bool值v。v默认为true。如果
	b.set()					未传递实参，则将b中所有位置位

	b.reset(pos)			将位置pos出的复位或将b中所有位复位
	b.reset()

	b.flip(pos)				改变位置pos处的位的状态或改变b中每一位的状态
	b.flip()

	b[pos]					访问b中位置pos处的位：如果b是const的，则当
							该位置时b[pos]返回一个bool值true，否则返回flase

	b.to_ulong()			返回一个unsigned long或一个unsigned long的值
	b.to_ullong()			其位模式与b相同。如果b中位模式不能放入指定的结果类
							型。则抛出一个overflow_error异常

	b.to_string(zero,one)	返回一个string，表示b中的位模式。zero和one的默认
							值分别为0和1，用来表示b中的0和1
	os<<b					将b中二进制位打印为字符1或0。打印到流os
	is>>b					从is读取字符存入b。当下一个字符不是1或0时，或是已
							经读入b.size()个位时，读取过程停止。
	count、size、all、any和none等几个操作都不接受参数，返回整个bitset的状态。其他操作---set、
reset和flip则改变bitset的状态。改变bitset状态的成员函数都是重载的。对每个函数，不接受参数的版本对
整个集合执行给定的操作:接受一个位置参数的版本则对指定位执行操作:
		bitset<32> bitvec(1U);		//32位:低位为1，剩余位为0
		bool is_set = bitvec.any();		//true，因为有1位置位
		bool is_not_set = bitvec.none();//false,因为有1位置位了
		bool all_set = bitvec.all();	//false，因为只有1位置位
		size_t onBits = bitvec.count();	//返回1
		size_t sz = bitvec.size();		//返回32
		bitvec.flip();					//翻转bitvec中的所有位
		bitvec.reset();					//将所有位复位
		bitvec.set();					//将所有位置位
当bitset对象的一个多个位置位(即，等于1)时，操作any返回true。相反，当所有位复位时，none返回true。
新标准引入了all操作，当所有位置位时返回true。操作count和size返回size_t类型的值，分别表示对象中
置位的位数或总位数。函数size是一个constexpr函数，因此可以用在要求常量表达式的地方。
	成员flip、set、reset及test允许我们读写指定位置的位:
		bitvec.flip(0);	//翻转第一位
		bitvec.set(bitvec.size()-1);//置位最后一位
		bitvec.set(0,0);	//复位第一位
		bitvec.reset(i);	//复位第i位
		bitvec.test(0);	//返回flase，因为第一位是复位的
下标运算符对const属性进行了重载。const版本的下标运算符在指定位置位时返回true，否则返回false。非
const版本返回bitset定义的一个特殊类型，它允许我们操作指定位的值:
		bitvec[0]= 0;		//将第一位复位
		bitvec[31]=bitvec[0];	//将最后一位设置为与第一位一样
		bitvec[0].flip();	//翻转第一位
		~bitvec[0];			//等价操作，也是翻转第一位
		bool b = bitvec[0];	//将bitvec[0]的值转换为bool类型

提取bitset的值
	to_ulong和to_ullong操作都返回一个值，保存了与bitset对象相同的位模式。只有当bitset的大小
小于等于对应大小(to_ulong为unsigned long,to_ullong为unsigned long lon)时，我们才能
使用这两个操作:
		unsigned long ulong = bitvec3.to_ulong();
		cout<<"ulong = "<<ulong<<endl;
注意:
	如果bitset中的值不能放入给定类型中，则这两个操作会抛出一个overflow_error异常。

bitset的IO运算符
	输入运算符从一个输入流读取字符，保存到一个临时的string对象中。直到读取的字符数达到对应bitset
的大小时，或是遇到不是1或0的字符时，或是遇到文件尾或输入错误时，该读取过程才停止。随即用临时string
对象来初始化bitset。如果读取的字符数小于bitset的大小，则与往常一样，高位将被置为0。
	输出运算符打印一个bitset对象中的位模式:
		bitset<16> bits;
		cin >> bits;	//从cin读取最多16个0或1
		cout<<"bits :"<< bits<<endl;	//打印刚刚读取的内容

使用bitset
	为了说明如何使用bitset，我们重新实现4.8节中的评分程序，用bitset替代unsigned long表示30
个学生的测验结果---"通过/失败":
		bool status;
		//使用位运算符的版本
		unsigned long quizA = 0;		//此值被当作位集合使用
		quizA |= 1UL << 27;		//指出第27个学生通过了测验
		status = quizA & (1UL << 27);	//检查第27个学生是否通过了测验
		quizA &= ~(1UL<<27);	//第27个学生未通过测验
		//使用标准库类bitset完成等价的工作
		bitset<30> quizB;		//每个学生分配一位，所有位都被初始化为0
		quizB.set(27);			//指出第27个学生通过了测验
		status = quizB[27];		//检查第27个学生是否通过了测验
		quizB.reset(27);		//第27个学生未通过测验

17.3	正则表达式
	正则表达式(regular expression)是一种描述字符序列的方法，是一种极其强大的计算工具。但是，
用于定义正则表达式的描述语言已经大大超出了本书的范围。因此，我们重点介绍如何使用C++正则表达式库(
RE库),它是新标准库的一部分。RE库定义在头文件regex中，它包含多个组件，列于表17.4中:
				表17.4:正则表达式库组件
	regex			表示有一个正则表达式的类
	regex_match		将一个字符序列与一个正则表达式匹配
	regex_search	寻找第一个与正则表达式匹配的子序列
	regex_replace	使用给定格式替换一个正则表达式
	sregex_iterator	迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串
	smatch			容器类，保存在string中搜索的结果
	ssub_match		string中匹配的子表达式的结果
regex类表示一个正则表达式。除了初始化和赋值外，regex还支持其他一些操作。表17.6列出了regex支持
的操作。
	函数regex_match和regex_search确定一个给定字符序列与一个给定regex是否匹配。如果整个输入序
列与表达式匹配，则regex_match函数返回true；如果输入序列中一个子串与表达式匹配，则regex_search
函数返回true。还有一个regex_replace函数，我们将在17.3.4中介绍。
	表17.5列出了regex的函数的参数。这些函数都返回bool值，且都被重载了:其中一个版本接受一个类型
为smatch的附加参数。如果匹配成功，这些函数将成功匹配的相关信息保存在给定的smatch对象中。
		表17.5:		regex_search和regex_match的参数
注意:这些操作返回bool值，指出是否找到匹配
							在字符序列seq中查找regex对象r中的正则表达式。seq可以是一个
		(seq,r,mft)			string、表示范围的一对迭代器以及一个指向空字符结尾的字符数组
							的指针
		(seq,m,r,mft)		m是一个match对象，用来保存匹配结果的相关细节。m和seq必须具
							有兼容的类型
							mft是一个可选的regex_constant::match_flag_type值。表
							17.13描述了这些值，它们会影响匹配过程

17.3.1	使用正则表达式库
	我们从一个非常简单的例子开始－－查找违反众所周知的拼写规则"i除非在c之后，否则必须在e之前"的
单词:
		//查找不在字符c之后的字符串ei
		string pattern("[^c]ei");
		//我们需要包含pattern的整个单词
		pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
		regex r(pattern);		//构造一个用于查找模式的regex
		smatch results;			//定义一个对象保存搜索结果
		//定义一个string保存与模式匹配和不匹配的文本
		string test_str = "recepit freind theif receive";
		//用r在test_str中查找与pattern匹配的子串
		if(regex_search(test_str,results,r))	//如果有匹配子串
			cout<<results.str()<<endl;	//打印匹配的单词
我们首先定义了一个string来保存希望查找的正则表达式。正则表达式[^c]表明我们希望匹配任意不是'c'的
字符，而[^c]ei指出我们想要匹配这种字符后接ei的字符串。此模式描述的字符串恰好包含三个字符。我们想
要包含此模式的单词的完整内容。为了与整个单词匹配，我们还需要一个正则表达式与这个三字母模式之前和之
后的字母匹配。
	这个正则表达式包含零个或多个字母后接我们的三字母的模式，然后再接零个或多个额外的字母。默认情
况下，regex使用的正则表达式语言是ECMAScript。在ECMAScript中，模式[[:alpha:]]匹配任意字母，
符号+和*分别表示我们希望"一个或多个"或"零个或多个"匹配。因此[[:alpha:]]*将匹配零个或多个字母。
	将正则表达式存入pattern后，我们用它来初始化一个名为r的regex对象。接下来我们定义了一个string，
用来测试正则表达式。我们将test_str初始化为与模式匹配的单词(如"freind"和"thief")和不匹配的单
词(如"recepit"和"receive")。我们还定义了一个名为results的smatch对象，它将被传递给regex_search。
如果找到匹配子串，results将会保存匹配位置的细节信息。
	接下来我们调用了regex_search。如果它找到匹配子串，就返回true。我们用results的str成员来打印
test_str中与模式匹配的部分。函数regex_search在输入序列中只要找到一个匹配子串就会停止查找。因此，
程序的输出将是:
			freind
17.3.2节中将会介绍如何查找输入序列中所有的匹配子串。

指定regex对象的选项
	当我们定义一个regex或是对一个regex调用assign为其赋予新值时，可以指定一些标志来影响regex
如何操作。这些标志控制regex对象的处理过程。表17.6列出的最后6个标志指出编写正则表达式所用的语言。
对这个6个标志，我们必须设置其中之一，且只能设置一个。默认情况下，ECMASCripte标志被设置，从而
regex会使用ECMA-262规范，这也是很多浏览器所使用的正则表达式语言:
			表17.6:		regex(和wregex)选项
								re表示一个正则表达式，它可以是一个string、一个表示字符
								范围的迭代器对、一个指向空字符结尾的字符数组的指针、一个
		regex r(re)				字符指针和一个计数器或一个花括号包围的字符列表。f是指出
		regex r(re,f)			对象如何处理的标志。f通过下面列出的值来设置。如果未指定
								f，其默认值为ECMAScipt

								将r1中的正则表达式替换为re。re表示一个正则表达式，它可以
		r1 = re					是另一个regex对象、一个string、一个指向空字符结尾的字符
								数组的指针或是一个花括号包围的字符列表
		r1.assign(re,f)			与使用赋值运算符(=)效果相同：可选的标志f业与regex的构造
								函数中对应的参数含义相同
		r.mark_count()			r中子表达式的数目，
		r.flags()				返回r的标志集
注:构造函数和赋值操作可能抛出类型为regex_error的异常
					定义regex时指定的标志
定义在regex和regex_constants::syntax_option_type中
		icase			在匹配过程中忽略大小写
		nosubs			不保存匹配的子表达式
		optimize		执行速度优于构造速度
		ECMAScript		使用ECMA-262指定的语法
		basic			使用POSIX基本的正则表达式语法
		extended		使用POSIX扩展的正则表达式语法
		awk				使用POSIX版本的awk语言的语法
		grep			使用POSIX版本的grep的语法
		egrep			使用POSIX版本的egrep的语法
其他3个标志允许我们指定正则表达式处理过程中与语言无关的方面。例如，我们可以指出希望正则表达式以
大小写无关的方式进行匹配。
	作为一个例子，我们可以用icase标志查找具有特定扩展名的文件名。大多数操作系统都是按大小写无
关的方式来识别扩展名的---可以将一个C++程序保存在.cc结尾的文件中，也可以保存在.Cc、.cＣ或是.CC
结尾的文件中、效果是一样的。如下所示，我们可以编写一个正则表达式来识别上述任何一种扩展名以及其他
普通文件扩展名:
		//一个或多个字母或数字字符后接一个'.'再接"cpp"或"cxx"或"cc"
		regex r("[[:alpha:]]+\\.(cpp|cxx|cc)$",regex::icase);
		smatch results;
		string filename;
		while(cin>>filename){
			if(regex_search(filename,results,r))
				cout<<results.str()<<endl;
		}
此表达式将匹配这样的字符串:一个或多个字母或数字后接一个句点再接三个文件扩展名之一。这样，此正则表
达式将会匹配指定的文件扩展名而不理会大小写。
	就像C++语言中有特殊字符一样，正则表达式语言也通常有特殊字符。例如，字符点(.)通常匹配任意字
符。与C++一样，我们可以在字符之前放置一个反斜线来去掉其特殊含义。由于反斜线也是C++中的一个特殊
字符，我们在字符串字面常量中必须连续使用两个反斜线来告诉C++我们相要一个普通反斜线字符。因此，为了
表示与句点符匹配的正则表达式，必须写成\\.(第一个反斜线去掉C++语言中反斜线的特殊含义，即，正则
表达式字符串为\.，第二个反斜线则表示在正则表达式中去掉.的特殊含义)。

指定或使用正则表达式时的错误
	我们可以将正则表达式本身看作用一种简单程序设计语言编写的"程序"。这种语言不是由C++编译器解释
的。正则表达式是在运行时，当一个regex对象被初始化或被赋予一个新模式时，才被"编译"的。与任何其他
程序设计语言一样，我们用这种语言编写的正则表达式也可能有错误。
注意:
	需要意识到的非常重要的一点是，一个正则表达式的语法是否正确是在运行时解析的。
如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为regex_error的异常。类似标准异
常类型，regex_error有一个what操作来描述发生了什么错误。regex_error还有一个名为code的成员，
用来返回某个错误类型对应的数值编码。code返回的值是由具体实现定义的，RE库能抛出的标准错误如表17.7
所示。
	例如，我们可能在模式中意外遇到一个方括号:
		try{
			//错误:alnum漏掉了右括号，构造函数会抛出异常
			regex r("[[:alnum:]+\\.(cpp|cxx|cc)",regex::icase);
		}catch(regex_error e){
			cout<< e.what()<<"\ncode"<<e.code()<<endl;
		}
当这段程序在我们的系统上运行时，程序会生成:
		regex_error(error_brack):
		The expression contained mismatched [ and ]
		code: 4
				表17.7:	正则表达式错误类型
	定义在regex和regex_constants::error_type中
		error_collate		无效的元素校对请求
		error_ctype			无效的字符类
		error_escape		无效的转义字符或无效的尾置转义
		error_backref		无效的向后引用
		error_brack			不匹配的方括号([或])
		error_paren			不匹配的小括号((或))
		error_brace			不匹配的花括号({或})
		error_badbrace		{}中无效的范围
		error_range			无效的字符范围(如[z-a])
		error_space			内存不足，无法处理此正则表达式
		error_badrepeat		重复字符(*、?、+或{)之前没有有效的正则表达式
		error_compleity		要求的匹配过去复杂
		error_stack			栈空间不足，无法处理匹配
我们编译器定义了code成员，返回表17.7列出错误类型的编号，与往常一样，编号从0开始。
建议:避免创建不必要的正则表达式
	如我们所见，一个正则表达式所表示的"程序"是在运行时而非编译时编译的。正则表达式的编译是一个非常
慢的操作，特别是在你使用了扩展的正则表达式语法或是复杂的正则表达式时。因此，构造一个regex对象以及向
一个已存在的regex赋予一个新的正则表
达式可能是非常耗时的。为了最小化这种开销，你应该努力避免创建很多不必要的regex。特别是，如果你在一个
循环中使用正则表达式，应该在循环外创建它，而不是在每步迭代时都编译它。

正则表达式类和输入序列类型
	我们可以在搜索多种类型的输入序列。输入可以是普通的char数据或wchar_t数据，字符可以保存在标准库
string中或是char数组中(或是宽字符版本，wstring或wchar_t数组中)。RE为这些不同的输入序列类型都定
义了对应的类型。
	例如，regex类保存类型char的正则表达式。。标准库还定义了一个wregex类保存类型wchar_t，其操作与
regex完全相同。两者唯一的差别是wregex的初始值必须使用wchar_t而不是char。
	匹配和迭代器类型(我们将在下面小节中介绍)更为特殊。这些类型的差异不仅在于字符类型，还在于序列是在
标准库string中还是在数组中:smatch表示string类型的输入序列；cmatch表示字符数组序列；wsmacth表示
宽字符串(wstring)输入；而wcmatch表示宽字符数组。
	重点在于我们使用的RE库类型必须与输入序列类型匹配。表17.8指出了RE库类型与输入序列类型的对应关系。
例如:
		regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$",regex::icase);
		smatch results;	//将匹配string输入序列，而不是char *
		if(regex_search("myfile.cc",results,r))//错误:输入为char *
			cout<<results.str()<<endl;
这段代码会编译失败，因为match参数的类型与输入序列的类型不匹配。如果我们希望搜索一个字符数组，就必须
使用cmatch对象:
		cmatch results;	//将匹配字符数组输入序列；
		if(regex_search("myfile.cc",results,r))
			cout<<results.str()<<endl;	//打印当匹配
			表17.8		正则表达式库类
	如果输入序列类型			则使用正则表达式类
		string				regex,smatch,ssub_match和sregex_iterator
		const char*			regex,cmatch,csub_match和cregex_iterator
		wstring				wregex,wsmatch,wssub_match和wsregex_iterator
		const wchar_t*		wregex,wcmatch,wcsub_match和wcregex_iterator

17.3.2	匹配与Regex迭代器类型
	第646页中的程序查找违反"i在e之前，除非在c之后"规则的单词，它只打印输入序列中第一个匹配的单词。
我们可以使用sregex_iterator来获得所有匹配。regex迭代器是一种迭代器适配器，被绑定到一个输入序列和
一个regex对象上。如表17.8所述，每种不同输入序列类型都有对应的特殊regex迭代器类型。迭代器操作如表17.9
所述:
		表17.9:	sregex_iterator操作
这些操作也适用于cregex_iterator、wsregex_iterator和wcregex_iterator
									一个sregex_iterator，遍历迭代器b和e表示的string。
	sregex_iterator　it(b,e,r)		它调用sregex_search(b,e,r)将it定位到输入中第一个
									匹配的位置。
	sregex_iterator end;			sregex_iterator的尾后迭代器

	*it					根据最后一个调用regex_search的结果，返回一个smatch对象的引用或
	it->				一个指向smatch对象的指针。
	++it				从输入序列当前匹配位置开始调用regex_search。前置版本返回递增后
	it++				迭代器；后置版本返回旧址
	it1 == it2			如果两个sregex_iterator都是尾后迭代器，则它们相等;两个非尾后迭代
	it1 != it2			器是从相同的输入序列和regex对象构造，则他们相等
当我们将一个sregex_iterator绑定到一个string和一个regex对象时，迭代器自动定位到给定string中第一个
匹配位置。即，sregex_iterator构造函数对给定string和regex调用regex_search。当我们解引用迭代器时，
会得到一个对应最近一次搜索结果的smatch对象。

使用sregex_iterator
	作为一个例子，我们将扩招之前的程序，在一个文本文件中查找所有违反"i在e之前，除非在c之后"规则的单
词。我们假定名为file的string保存了我们要搜索的输入文件的全部内容。这个版本的程序将使用与前一个版本
一样的pattern，但会使用一个sregex_iterator来进行搜索:
		//查找前一个字符不是c的字符串ei
		string pattern("[^c]ei");
		//我们想要包含pattern的单词的全部内容
		pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
		regex r(pattern,regex:icase);	//在进行匹配时忽略大小写
		//它将反复调用regex_search来寻找文件的中的所有匹配
		for(sregex_iterator it(file.begin(),file.end(),r),end_it;it != end_it;++it)
			cout<<it->str()<<endl;		//打印匹配的单词
for循环遍历file中每个与r匹配的子串。for语句中的初始值定义了it和end_it。当我们定义it时，sregex_iterator
的构造函数调用regex_search将it定位到file中第一个与r匹配的位置。而end_it是一个空sregex_iterator，
起到尾后迭代器的作用。for语句中的递增运算符通过regex_search来"推进"迭代器。当我们解引用迭代器时，会
得到一个表示当前匹配结果的smatch对象。我们调用它的str成员来打印匹配的单词。
	我们可以将此循环想象为不断从一个匹配位置跳到下一个匹配位置。如图17.1所示:
		sregex_iterator it(file.begin(),file.end(),r)
		将it初始化为第一个匹配位置			最后一个匹配
		| ||match1|| ||match2||...||matchi||...||matchn|| |
		 |												 |
     file.begin()									 file.end()

使用匹配数据
	如果我们对最初版本程序中的test_str运行此循环，则输出将是
		freind
		theif
但是，仅获得与我们的正则表达式匹配的单词还不是那么有用。如果我们在一个更大的输入序列---例如，在本章英文
版的文本上运行此程序---可能希望看到匹配单词出现的上下文，如:
		hey read or write according to the type
			>>> being <<<
		handled The input operators ignore whi
除了允许打印输入字符串中匹配的部分之外，匹配结果类还提供了有关匹配结果的更多细节信息。表17.10和表17.11
列出了这些类型支持的操作。
	我们将在下一节中介绍更多有关smatch和ssub_match类型的内容。目前，我们只需知道它们允许我们获得
匹配的上下文即可。匹配类型有两个名为prefix和suffix的成员，分别返回表示输入序列中当前匹配之前和之后
部分的ssub_match对象。一个ssub_match对象有两个名为str和length的成员，分别返回匹配的string和
该string的大小。我们可以用这些操作重写语法程序的循环:
		//循环头与之前一样
		for(sregex_iterator it(file.begin(),file.end(),r),end_it;it != end_it;++it)
		{
			auto pos = it->prefix().length();	//前缀的大小
			pos = pos > 40 ? pos-40 : 0;	//我们想要最多40个字符
			cout<<it->prefix().str().substr(pos)
				<<"\n\t\t>>>" <<it->str()<<" <<<\n"
				<<it->suffix().str().substr(0,40)
				<<endl;
		}
循环本身的工作方式与前一个程序相同。改变的是循环内部。如果17.2所示:
	当it指向第i个smatch对象时			it->str()
	|it->prefix().str()||xxxeixxx||it->suffix().set()|
我们调用prefix，返回一个ssub_match对象，表示file中当前匹配之前的部分。我们对此ssub_match对象调用
length，获得前缀部分的字符数目。接下来调整pos，使之指向前缀部分末尾向前40个字符的位置。如果前缀部分长
度小于40个字符，我们将pos置为0，表示要打印整个前缀部分。我们用substr来打印指定位置到前缀部分末尾的内容。
	打印了当前匹配之前的字符之后，我们接下来用特殊格式打印匹配的单词本身，使得它在输出中能突出显示出来。
打印匹配单词之后，我们打印file中匹配部分之后的前(最多)40个字符:
		表17.10	:		smatch操作
这些操作也适用于cmatch、wsmatch、wcmatch和对应的csub_match、wssub_match和wcsub_match
		m.ready()			如果已经通过调用regex_search或regex_match设置了m，则
							对m进行操作是未定义的。
		m.size()			如果匹配失败，则返回0；否则返回最近一次匹配的正则表达式中子表达式的数目
		m.empty()			若m.size()为0，则返回true
		m.prefix()			一个ssub_match对象，表示当前匹配之前的序列
		m.suffix()			一个ssub_match对象，表示当前匹配之后的部分
		m.format(...)		见表17.12
	在接受一个索引的操作中，n的默认值为0且必须小于m.size()。第一个子匹配(索引为0)表示整个匹配。
		m.length(n)			第n个匹配的子表达式的大小
		m.position(n)		第n个子表达式距序列开始的距离
		m.str(n)			第n个子表达式匹配的string
		m[n]				对应第n个子表达式的ssub_match对象
		m.begin(),m.end()	表示m中sub_match元素范围的迭代器。与往常一样，cbegin和cend
		m.cbegin(),m.cend()	返回const_iterator
		
17.3.3	使用子表达式
	正则表达式中的模式通常包含一个或多个子表达式。一个子表达式是模式的一部分，本身也具有意义。正则表
达式语法通常用括号表示子表达式。
	例如，我们用来匹配C++文件的模式就是用括号来分组可能的文件扩展名。每当我们用括号分组多个可行
选项时，同时也就声明了这些选项形成子表达式。我们可以重写扩展名表达式，以使得模式中点之前表示文件名
的部分也形成子表达式，如下所示:
		//r有两个子表达式:第一个是点之前表示文件名的部分，第二个表示文件扩展名
		regex r("([[:alnum:]]+)\\.(cpp|cxx|cc)$",regex::icase);
现在我们的模式包含两个括号括起来的子表达式:
		>>>	([[:alnum:]]+)，匹配一个或多个字符的序列
		>>>	(cpp|cxx|cc)，匹配文件扩展名
我们还可以重写17.3.1中的程序，通过修改输出语句使之只打印文件名。
		if(regex_search(filename,results,r))
			cout<<results.str(1)<<endl;	//打印第一个子表达式
与最初的程序一样，我们还是调用regex_search在名为filename的string中查找模式r，并且传递smatch
对象results来保存匹配结果。如果调用成功，我们打印结果。但是，在此版本中，我们打印的是str(1)，即，
与第一个子表达式匹配的部分。
	匹配对象除了提供匹配整体的相关信息外，还提供访问模式中每个子表达式的能力。子匹配是按位置来访问
的。第一个子匹配位置为0。表示整个模式对应的匹配，随后是每个子表达式对应的匹配。因此，本例模式中第一
个子表达式，即表示文件名的子表达式，其位置为1，而文件扩展名对应的子表达式位置为2。
	例如，如果文件名为foo.cpp，则results.str(0)将保存foo.cpp；results.str(1)将保存foo；
而results.str(2)将保存cpp。在此程序中，我们想要点之前的部分名字，即第一个子表达式，因此我们打印
results.str(1)。

子表达式用于数据验证
	子表达式的一个常见用途是验证必须匹配特定格式的数据。例如，美国的电话号码有十位数，包含一个区
号和一个七位本地号码。区号通常放在括号里，但这并不是必需的。剩余七位数字可以用一个短横线、一个点或
是一个空格分割。但也可以完全不用分割符。我们可能希望接受任何这种格式的数据而拒绝任何其他格式的数。我
们将分两步来实现这一目标：首先，我们将用一个正则表达式找到可能是电话号码的序列，然后再调用一个函数来
完成数据验证。
	在编写电话号码模式之前，我们需要介绍一下ECMAScript正则表达式语言的一些特性:
		>>>	\{d}表示单个数字而\{d}{n}表示一个n个数字的序列。(如，\{d}{3}匹配三个数字的序列。)
		>>>	在方括号中的字符集合表示匹配这些字符中任意一个。如[-.]匹配一个短横线或一个点或一个空格，
注意，点在括号中没有特殊含义。！！
		>>>	后接'?'的组件是可选的。(如，\{d}{3}[-.]?\{d}{4}匹配这样的序列:开始是三个数字，后
接一个可选的短横线或点或空格，然后是四个数字。此模式可以匹配555-0132或555.0132或555 0132或
5550132(也就是[-.]是可选的)
		>>>	类似C++,ECMAScript使用反斜线表示一个字符本身而不是其特殊含义。由于我们的模式包含括号，
而括号是ECMAScript中特殊的字符，因此我们必须用\(和\)来标识括号是我们的模式的一部分而不是特殊字符。
由于反斜线是C++中特殊字符，在模式中每次出现\的地方，我们必须用一个额外的反斜线来告知C++我们需要一
个反斜线字符而不是一个特殊符号。因此，我们用\\{d}{3}来表示正则表达式\{d}{3}。
	为了验证电话号码，我们需要访问模式的组成部分。例如，我们希望验证区号部分的数字如果用了左括号，
那么他是否也在区括号后面用了右括号。即，我们不希望出现(908.555.1800这样的号码。
	为了获得匹配的组成部分，我们需要在定义正则表达式时使用子表达式。每个子表达式用一对括号包围:
		//整个正则表达式包含7个子表达式:(ddd)分割符ddd分隔符dddd
		//子表达式1、3、4和6是可选的；2、5和7保存号码
		"(\\()?(\\d{3})(\\))?([-.])?(\\d{3})([-.]?)(\\d{4})";
由于我们的模式使用了括号，而且必须去除反斜线的特殊含义，因此这个模式很难读(也很难写!)。理解此模式的
最简单的方法是逐个剥离(括号包围的)子表达式:
		1.(\\()?表示区号部分可选的左括号
		2.(\\d{3})表示区号
		3.(\\))?表示区号部分可选的右括号
		4.([-.])?表示区号部分可选的分割符
		5.(\\d{3})表示号码的下三位数字
		6.([-.])?表示可选的分隔符
		7.(\\d{4})表示号码的最后四位数字
下面的代码读取一个文件，并用此模式查找与完整的电话号码模式匹配的数据。它会调用一个名为valid的函数
来检查号码格式是否合法:
		string phone = "(\\()?(\\d{3})(\\))?([-.])?(\\d{3})([-.]?)(\\d{4})";
		regex r(phone);//regex对象，用于查找我们的模式
		smatch m;
		string s;
		//从输入文件中读取每条记录
		while(getline(cin,s)){
			//对每个匹配的电话号码
			for(sregex_iterator it(s.begin(),s.end(),r),end_it;it != end_it;++it){
				if(valid(*it))
					cout<<"valid: "<<it->str()<<endl;
				else
					cout<<"not valid: "<<it->str()<<endl;
			}
		}

使用子匹配操作
	我们将使用表17.11中描述的子匹配操作来编写valid函数。需要记住的重要一点是，我们的pattern有
七个子表达式。与往常一样，每个smatch对象会包含八个ssub_match元素。位置[0]的元素表示整个匹配:元
素[1]...[7]表示每个对应的子表达式。
	当调用valid时，我们知道已经有一个完整的匹配，但不知道每个可选的子表达式是否是匹配的一部分。如
果一个子表达式是完整匹配的一部分，则其对应的ssub_match对象的matched成员为true。
		表17.11:		子匹配操作
注意:这些操作适用于ssub_match、csub_match、wssub_match、wcsub_match。
		matched		一个public bool数据成员，指出此ssub_match是都匹配了
		first		public数据成员，指向匹配序列首元素和尾后位置的迭代器。如果未匹配
		second		则first和second是相等的，
		length		匹配的大小，如果matched为false，则返回0
		str()		返回一个包含输入中匹配部分的string，如果matched为false，则返回
					空string
		s = ssub	将ssub_match对象ssub转换为string对象s。等价于s=ssub.str()
					转换运算符不是explicit的。
在一个合法的电话号码中，区号要么是完整括号包围的，要么完全没有括号。因此，valid要做什么工作依赖于
号码是否以一个括号开始:
		bool valid(const smatch &m)
		{
			//如果区号前有一个左括号
			if(m[1].matched)
				//则区号后必须有一个右括号，之后紧跟剩余号码或一个空格
				return m3.matched && (m[4].matched == 0 || m[4].str() == " ");
			else
				//否则，区号后不能有右括号
				//另两个组成部分见的分隔符必须匹配
				return !m[3].matched && m[4].str() == m[6].str();
		}
我们首先检查第一个子表达式(即，左括号)是否匹配了。这个子表达式在m[1]中。如果匹配了，则号码是以
左括号开始的。在此情况下，如果区号后的字表达式也匹配了(意味着区号后有右括号)则整个号码是合法的。
而且，如果号码正确使用了括号，则下一个字符必须是一个空格或下一部分的第一个数字。
	如果m[1]未匹配，(即，没有左括号)，则区号后面的子表达式也不应该匹配。如果它为空，则整个号
码是合法的。

17.3.4	使用regex_replace
	正则表达式不仅用在我们希望查找一个给定序列的时候，还用在当我们想将找到的序列替换为另一个序
列的时候。例如，我们可能希望将美国的电话号码转换为"ddd.ddd.dddd"的形式，即，区号和后面
三位数字用一个点分隔。
	当我们希望在输入序列中查找并替换一个正则表达式时，可以调用regex_replace。表17.12描述了
regex_replace。类似搜索函数，它接受一个输入字符序列和一个regex对象，不同的是，它还接受一
个描述我们想要的输出形式的字符串。
			表17.12:		正则表达式替换操作
									使用格式字符串fmt生成格式化输出，匹配在m中，可选的
									match_flag_type标志在mft中。第一个版本写入迭代
	m.format(dest,fmt,mft)			器dest指向的目的位置并接受fmt参数，可以是一个string
									也可以是表示字符数组中范围的一对指针。第二个版本返
	m.format(fmt,mft)				回一个string，保存输出，并接受fmt参数，可以是一个
									string，也可以是指向空字符结尾的字符数组的指针。mft
									的默认值为format_default

									遍历seq，用regex_search查找与regex对象r
									匹配的子串，使用格式字符串fmt和可选的match_flag_type
									标志来生出输出。第一个版本将输出写入到迭代器dest指定
regex__replace(dest,seq,r,fmt,mft)	的位置，并接受一对迭代器seq表示范围。第二个版本返回
regex__replace(seq,r,fmt,mft)		一个string，保存输出，且seq既可以是一个string也可
									以是一个指向空字符结尾的字符数组的指针。在所有情况下
									fmt既可以是一个string也可以是一个指向空字符结尾
									的字符数组的指针，且mft的默认值为match_default

	替换字符串由我们想要的字符组合与匹配的子串对应的子表达式而组成，在本例中，我们希望在替换字符串
中使用第二个、第五个和第七个子表达式。而忽略第一个、第三个、第四个和第六个子表达式，因为这些子表达式
用来形成号码的原格式而非新格式中一部分。我们用一个符号$后跟子表达式的索引号来表示一个特定的子表达式:
		string fmt = "$2.$5.$7";	//将号码格式改为ddd.dddd.ddd
可以像下面这样使用我们的正则表达式模式和替换字符串:
		regex r(phone);		//用来寻找模式的regex对象
		string number = "(098) 555-1800";
		cout<<regex_replace(number,r,fmt)<<endl;
此程序的输出为:
		908.555.1080
只替换输入序列的一部分
	正则表达式更有意思的一个用处是替换一个大文件中的电话号码。例如，我们有一个保存人名及其电话号码
的文件:
		morgan (201) 555-2368 862-555-0123
		drew (962)555.0130
		lee (609) 555-0132 2015550175 800.555-0000
我们希望将数据转换为下面这样：
		morgan 201.555.2368 862.555.0123
		drew 962.555.0130
		lee 609.555.0132 201.555.0175 800.555.0000
可以用下面的程序完成这种转换:
		int main(){
			string phone = "(\\()?(\\d{3})(\\))?([-.])?(\\d{3})([-.]?)(\\d{4})";
			regex r(phone);	//寻找模式所用的regex对象
			smatch m;
			string s;
			string fmt = "$2.$5.$7";		//将号码格式改为ddd.ddd.dddd
			//从输入文件中读取每条记录
			while(getline(cin,s))
				cout<<regex_replace(s,r,fmt)<<endl;
			return 0;
		}
我们读取每条记录，保存到s中，并将其传递给regex_replace。此函数在输入序列中查找并转换所有匹配子串。

用来控制匹配和格式的标志
	就像标准库定义标志来指导如何处理正则表达式一样，标准库还定义了用来在替换过程中控制匹配或格式的
标志。表17.13列出了这些值。这些标志可以传递给函数regex_search或regex_match或是smatch的
format成员。
	匹配和格式化标志的类型为match_flag_type。这些值都定义在名为regex_constants的命名空间中。
类似用于bind的placeholders，regex_constants也是定义在命名空间std中的命名空间。为了使用
regex_constants中的名字，我们必须在名字前同时加上两个命名空间的限定符:
		using std::regex_constants::format_no_copy;
此声明指出，如果代码中使用了format_no_copy，则表示我们想要使用命名空间std::constants中的这
个名字。如下所示，我们也可以用另一种形式的using来替代上面的代码，我们将在18.2.2节中介绍这种形式:
		using namespace std::regex_constants;
			表17.13		匹配标志
定义在regex_constants::match_flag_type中
		match_default			等价于format_default
		match_not_bol			不将首字符作为行首处理
		match_not_eol			不将尾元素作为行尾处理
		match_not_bow			不将首字符作为单词首处理
		match_any				如果存在多于一个匹配，则可返回任意一个匹配
		match_not_null			不匹配任何空序列
		match_continuous		匹配必须从输入的首字符开始
		match_prev_avail		输入序列包含第一个匹配之前的内容
		format_default			用ECMAScript规则替换字符串
		format_sed				用POSIX sed规则替换字符串
		format_no_copy			不输出输入序列中未匹配的部分
		format_first_only		只替换子表达式的第一次出现

使用格式标志
	默认情况下，regex_replace输出整个输入序列。未与正则表达式匹配的部分会原样输出:匹配的部分按格式
字符串指定的格式输出。我们可以通过在regex_replace调用中指定format_no_copy来改变这种默认行为:
		//只生成垫还号码：使用新的格式字符串
		string fmt2 = "$2.$5.$7";	//在最后一部分号码后放置空格作为分隔符
		//通知regex_replace只拷贝它替换的文本
		cout<<regex_replace(s,r,fmt2,format_no_copy)<<endl;
给定相同的输入，此版本的程序生成
		201.555.2368 862.555.0123
		962.555.0130
		609.555.0132 201.555.0175 800.555.0000

17.4	随机数
	程序通常需要一个数源。在新标准出现之前，C和C++都依赖于一个简单的C库函数rand来生成随机数。
此函数生成均匀分布的伪随机整数，每个是随机数的范围在0和一个系统相关的最大值(至少为32767)之间。
	rand函数有一些问题:即使不是大多数，也有很多程序需要不同范围的随机数。一些应用需要随机浮
点数。一些程序需要非均匀分布的数。而程序员为了解决这些问题试图转换rand生成的随机数的范围、类型
或分布时，常常会引入非随机性。
	定义在头文件random中的随机数库通过一组协作的类来解决这些问题问题:随机数引擎类和随机数分
布类。表17.14描述了这些类，一个引擎类可以生成unsigned随机数序列。一个分不累使用一个引擎类生成
指定类型的、在给定范围内的、服从特定概率分布的随机数。
		表17.14			随机数库的组成
			引擎				类型，生成随机unsigned整数序列
			分布				类型，使用引擎返回服从特定概率分布的随机数
注意:
	C++程序不应该使用库函数rand，而应该使用default_random_engine类和恰当的分布类对象。

17.4.1	随机数引擎和分布
	随机数引擎是函数对象类，他们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned
整数。我们可以通过调用一个随机数引擎对象来生成原始随机数:
		default_random__engine e;	//生成随机无符号数
		for(size_t i = 0; i < 10;++i)
			//e()"调用"对象来生成下一个随机数
			cout<<e()<<" ";
在我们的系统中，此程序生成:
16807 282475249 1622650073 984943658 1144108930 470211272 ...
在本例中，我们定义了一个名为e的default_random_engin对象。在for循环内，我们调用对象e来获得下
一个随机数。
	标准库定义了多个随机数引擎类，区别在于性能和随机质量不同。每个编译器都会指定其中一个作为
default_random_engine类型。此类型一般具有最常用的特性。表17.15列出了随机数引擎操作，标准
库定义的引擎类型列在附录A3.2中:
			表17.15		随机数引擎操作
		Engine e;			默认构造函数，使用该引擎类型默认的种子
		Engine e(s);		使用类型值s作为种子
		e.seed(s)			使用种子s重置引擎状态
		e.min()				此引擎可生成的最小值和最大值
		e.max()				此引擎可生成的最大值
		Engine::result_type	此引擎生成的unsigned整型类型
		e.discard(u)		将引擎推进u步；u的类型为unsigned long long
	对于大多数场合、随机数引擎的输出是不能直接使用的，这也是为什么早先我们称之为原始随机数。问题出在
生成的随机数的值范围通常与我们需要的不符，而正确转换随机数的范围是极其困难的。

分布类型和引擎
	为了得到在一个指定范围内的数，我们使用一个分布类型的对象:
		//生成0到9之间(包含)均匀分布的随机数
		uniform_int_distribution<unsigned> u(0,9);
		default_random_engine e;	//生成无符号是随机整数
		for(size_t i = 0;i != 10;++i){
			//将u作为随机数源
			//每个调用返回在指定范围内并服从均匀分布的值
			cout<<u(e)<<" ";
		}
在此代码生成下面的这样输出:
		0 1 7 4 5 2 0 6 6 9
此处我们将u定义为uniform_int_distribution<unsigned>。此类型生成均匀分布的unsigned值。当我们
定义一个这种类型的对象时，可以提供想要的最小值和最大值。在此程序中，u(0,9)表示我们希望得到0到9之间(包
含)的数。随机数分布类会使用包含的范围，从而我们可以得到给定完整类型的每个可能值。
	类似引擎类型，分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。
分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。注意，我们传递给分布对象的是引擎对象本身，
即u(e)。如果我们将调用写成u(e())，含义将变为将e生成的下一个值传递给u，会导致一个编译错误。我们传递
的是引擎本身，而不是它生成的下一个值，原因是某些分布可能需要调用引擎多次才能得到一个值。
注意:
	当我们说随机数发生器时，是指分布对象和引擎对象的组合。

比较随机数引擎和rand函数
	对熟悉C库函数rand的读者，值得注意的是:调用一个default_random_engine对象的输出类似rand的
输出。随机数引擎生成的unsigned整数在一个系统定义的范围内，而rand生成的数的范围在0到RAND_MAX之间。
一个引擎类型的范围可以通过调用该类型对象的min和max成员来获得:
		cout<<" min: "<<e.min()<<" max: "<<e.max()<<endl;
在我们的系统中，此程序生成下面的输出:
		min:1 max: 2147483646

引擎生成一个数值序列
	随机数发生器有一个特性经常会使新生迷惑：即使生成的看起来是随机的，但对一个给定的发生器，每次运行
程序它都会返回相同的数值序列。序列不变这一事实在调试时非常有用。但另一方面，使用随机数发生器的程序也必
须考虑这一特性。
	作为一个例子，假定我们需要一个函数生成一个vector。包含100个均匀分布在0到9之间的随机数。我们可能
认为应该这样编写此函数:
		//几乎肯定的是生成随机整数vector的错误方法
		//每次调用这个函数都会生成相同的100个数!
		vector<unsigned> bad_randVec()
		{
			default_random_engine e;
			uniform_int_distribution<unsigned> u(0,9);
			vector<unsigned> ret;
			for(size_t i = 0; i != 100;++i)
				ret.push(u(e));
			return ret;
		}
但是，每次调用这个函数都会返回相同的vector:
		vector<unsigned> v1(bad_randVec());
		vector<unsigned> v2(bad_randVec());
		//将打印"equal"
		cout<<((v1==v2) ? "equal" : "not equal")<<endl;
此代码会打印equal，因为vector v1和v2具有相同的值。
	编写此函数的正确方法是将引擎和关联的的分布对象定义为static的:
		//返回一个vector，包含100个均匀分布的随机数
		vector<unsigned> good_randVec(){
			//由于我们希望引擎和分布对象保持状态，因此应该将它定义为static的，
			//从而每次调用都生成新的数
			static default_random_engine e;
			uniform_int_distribution<unsigned> u(0,9);
			vector<unsigned> ret;
			for(size_t i = 0; i != 100;++i)
				ret.push(u(e));
			return ret;
		}
由于e和u是static的，因此他们在函数调用之间会保持住状态。第一次调用会使用u(e)生成的序列中的前
100个随机数，第二次调用会获得接下来100个，依次类推。
注意:
	一个给定的随机数发生器会一直生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，
应该将其(包括引擎和分布对象)定义为static的。否则，每次调用函数都会生成相同的序列。其实，也就
是说如果你的引擎和分布对象每次都是重新开始的话，生成的随机数也是一样的，但是如果，是接着上一次
生成的话，则不会，其实就是一个数学公式来生成的随机数。

设置随机数发生器种子
	随机数发生器会生成相同的随机数序列这一特性在调试中很有用。但是，一旦我们的程序调试完毕，
我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个种子(seed)来达到这一目的。种
子就是有一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。
	为引擎设置种子有两种方式:在创建引擎对象时提供种子，或者调用引擎的seed成员:
		default_random_engine e1;	//使用默认种子
		default_random_engine e2(2147483646);	//使用给定的种子值
		//e3和e4将生成相同的序列，因为它们使用了相同的种子
		default_random_engine e3;		//使用默认种子值
		e3.seed(32767);		//调用seed设置一个新种子值
		default_random_engine e4(32767);	//将种子值设置为32767
		for(size_t i = 0;i != 100; ++i){
			if(e1() == e2())
				cout<<"unseeded match at iteration: "<<i<<endl;
			if(e3() != e4())
				cout<<"seeded differs at iteration: "<<i<<endl;
		}
本例中我们定义了四个引擎。前两个引擎e1和e2的种子不同，因此应该生成不同的序列。后两个引擎e3和e4
有相同的种子，它们将生成相同的序列。
	选择一个好的种子，与生成好的随机数所涉及的其他大多数事情相同，是极其困难的。可能最常用的方
法是调用系统函数time。这个函数定义在头文件ctime中，它返回从一个特定时刻到当前经历了多少秒。函数
time接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间:
		default_random_engine e1(time(0));	//稍微随机些的种子
由于time返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。
注意:
	如果程序作为一个自动过程的一部分反复运行，将time的返回值作为种子的方式就无效了；它可能多次使
用的都是相同的种子(在一秒之内多次使用该种子，就是重复的了)

17.4.2	其他随机数分布
	随机数引擎生成unsigned数，范围内的每个数被生成的概率都是相同的。而应用程序常常需要不同类型或
不同分布的随机数。标准库通过定义不同随机数分布对象来满足这两方面的要求。分布对象和引擎对象协同工作，
生成要求的结果。表17.16列出了分布类型所支持的操作。

生成随机实数
	程序需要一个随机浮点数的源。特别是，程序经常需要0和1之间的随机数。最常用但不正确的从rand获得
一个随机浮点数的方法是用rand()的结果除以RAND_MAX，即，系统定义的rand可以生成的最大随机数的上界。
这种方法法不正确的原因是随机整数的精度通常低于随机浮点数。这样，有一些浮点数就永远不会被生成了。
	使用新标准库设施，可以很容易地获得随机浮点数。我们可以定义一个uniform_real_distribution类
型的对象，并让标准库来处理从随机整数到对随机浮点数的映射。与处理uniform_int_distribution一样，
在定义对象时，我们指定最小值和最大值:
		default_random_engine　e;
		//0到1(包含)的均匀分布
		uniform_real_distribution<double> u(0,1);
		for(size_t i = 0; i != 10;++i)
			cout<<u(e)<<" ";
这段代码与之前生成unsigned值的程序几乎相同。但是，由于我们使用了一个不同分布类型，此版本会生成
不同的结果:
		0.131538 0.45865 0.218959 0.678865 0.934693 0.519416 ....
			表17.16:		分布类型的操作
		Dist d;				默认构造函数:使d准备好被使用。其他构造函数依赖于Dist
							的类型；分布类型的构造函数是explicit的
		d(e);				用相同的e连续调用d的话，会根据d的分布式类型生成一个随
							机数序列；e是一个随机数引擎对象
		d.min()				返回d(e)能生成的最小值和最大值
		d.max()
		d.reset()			重建d的状态，使得随后对d的使用不依赖于d已经生成的值。

使用分布的默认结果类型
	分布类型都是模板，具有单一的模板类型参数，表示分布生成的随机数的类型，对此有一个例外，我们将在
17.4.2节中进行介绍。这些分布类型要么生成浮点数类型，要么生成整数类型。
	每个分布模板都有一个默认模板实参。生成浮点值的分布类型默认生成double值，而生成整型值的分布默
认生成int值。由于分布类型只有一个模板参数，因此当我们希望使用默认随机数类型时要记得在模板名之后使
用空间括号。
		//空<>表示我们希望使用默认结果类型
		uniform_real_distribution<> u(0,1);	//默认生成double值

生成非均匀分布的随机数
	除了正确生成在指定范围内的数之前，新标准库的另一个优势是生成非均匀分布的随机数。实际上，新标准
库定义了20种分布类型。这些类型列在附录A3中。
	作为一个例子。我们将生成一个正态分布的值的序列，并画出值的分布。由于normal_distribution生
成浮点值，我们的程序使用头文件cmatch
中的lround函数将每个随机数舍入到最接近的整数。我们将生成200个数，它们以均值4为中心，标准差为1.5。
由于使用的是正态分布，我们期望生成的数中大约99%都在0到8之间(包含)。我们的程序会对这个范围内的每个
整数统计有多少个生成的数映射到它:
		default_random_engine e;		//生成随机整数
		normal_distribution<> n(4,1.5);	//均值为4，标准差为1.5
		vector<unsigned> vals(9);	//9个元素均为0
		for(size_t i = 0; i != 200;++i){
			unsigned v = lround(n(e));	//舍入到最接近的整数
			if(v < vals.size())		//如果结果在范围内
				++vals[v];		//统计每个数出现了多少次
		}
		for(size_t j = 0; j != vals.size(); ++j)
			cout<< j << ": "<<string(vals[j],"*")<<endl;
我们首先定义了随机数发生器对象和一个名为vals的vector。我们用vals来统计范围0-8中的每个数出现
了多少次。与我们使用vector的大多数程序不同，此程序按需求大小为vals分配空间，每个元素都被初始
化为0。
	在for循环中，我们调用lround(n(e))来将n(e)返回的值舍入到最接近的整数。获得浮点随机数对
应的整数后，我们将它作为计数器vector的下标。由于n(e)可能生成范围0到8之外的数，所以我们首先检
查生成的数是否在范围内，然后再将其作为vals的下标。如果结果确实在范围内，我们递增对应的计数器。
	当循环结束时，我们打印vals的内容，可能会打印出像下面这样的结果:
		0: ***
		1: ********
		2: *******************
		3: ********************************
		4: ********************************************
		5: ************************************
		6: ************************
		7: *******
		8: *
本例中我们打印一个由星号组成的string，有多少随机数等于此下标我们就打印多少个尾号。注意，此图并
不是完全对称的。如果打印出的图是完整对称的，我们反倒有理由怀疑随机数发生器的质量了。

bernouli_distribution类
	我们注意到有一个分布不接受模板参数，即bernoulli_distribution，因为它是一个普通类，而非模
板。此分布总是返回一个bool值。它返回true的概率是一个常数，此概率的默认值是0.5。
	作为一个这种分布的例子，我们可以编写一个程序，这个程序与用户玩一个游戏。为了进行这个游戏，其中一个
游戏者－－－用户或是程序－－必须先行。我们可以用一个值范围是0到1的uniform_int_distribution来选择
先行的游戏者，但也可以用伯努利分布来完成这个选择。假定已有一个名为play的函数来进行游戏，我们可以编写像
下面这样的循环来与用户交往:
		string resp;
		default_random_engine e;	//e应保持状态，所以必须在循环外定义。
		bernoulli_distribution b;	//默认是50/50的机会
		do {
				bool first = b(e);	//如果为true，则程序先行
				cout<<(first ? "We go frist" : "You　get to go first")<<endl;
				//传递谁先行的指示，进行游戏
				cout<<((play(first) ? "sorry,you lost":"congrats,you won")<<endl;
				cout<<"play again? Enter 'yes' or 'no'"<<endl;
			}
			while(cin >> resp && resp[0] = 'y');
我们用一个do while循环来反复提示用户进行游戏。
注意:
	由于引擎返回相同的随机序列。所以我们必须在循环外声明引擎对象。否在每步循环都会创建一个新引擎，
从而每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此，也应该在循环外定义！！！

17.5	IO库再探
	在第8章中我们介绍了IO库的基本结构及其最常用的部分。在本节中，我们将介绍三个更特殊的IO库特性：
格式控制、未格式化IO和随机访问。

17.5.1	格式化输入与输出
	除了条件状态外，每个iostream对象还维护一个格式状态来控制IO如何格式化的细节。格式状态控制化的
某些方面，如整型值是几进制，浮点值的精度、一个输出元素的宽度等。
	标准库定义了一组操纵符来修改流的格式状态，如表17.7和表17.8所示。一个操纵符是一个函数或一个
对象，会影响流的状态，并能用作输入或输出运算符的运算对象。类似输入和输出运算符，操纵符也返回它所处理
的流对象，因此我们可以在一条语句中组合操纵符和数据。
	我们已经在程序中使用过一个操纵符－－－endl，我们将它"写"到输出流，就像它是一个值一样。但
endl不是一个普通值，而是一个操作:它输出一个换行符并刷新缓冲区。

很多操纵符改变格式状态
	操纵符用于两大类输出控制:控制数值的输出形式以及控制补白的数量和位置。大多数改变格式状态的操纵符
都是设置/复原成对的:一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格
式。
注意:
	当操纵符改变流的格式状态时，通常改变后的状态对是所有后续IO都生效
当我们有一组IO操作希望使用相同的格式时，操纵符对格式状态的改变是持久的这一特性很有用。实际上，一些程
序会利用操纵符的这一特性对其所有输入或输出重置一个或多个格式规则的行为。在这种情况下，操纵符会改变流
这一特性就是满足要求的了。
	但是，很多程序(而且更重要的是，很多程序员)期望流的状态复合标准库正常的默认设置。在这些情况下，
将流的状态置于一个非标准状态可能会导致错误。因此，通常最好在不需要特殊格式时尽快将流恢复到默认状态。

控制布尔值的格式
	操纵符改变对象的格式状态的一个例子是boolalpha操纵符。默认情况下，bool值打印为1或0。一个true
值输出为整数1，而false输出为0。我们可以通过对流使用boolalpha操纵符来覆盖这种格式:
		cout<<"default bool values: "<< true <<" " <<false
			<<"\nalpha bool values: " <<boolalpha<<true<<" " <<false<<endl;
执行这段程序会得到下面的结果:
		default bool values: 1 0
		alpha bool values: true false
一旦向cout"写入"了boolalpha，我们就改变了cout打印bool值的方式。后续打印bool值的操作都会打印
true或false而不会打印1或0。
	为了取消cout格式状态的改变，我们使用noboolalpha:
		bool bool_val = get_status();
		cout << boolalpha<<bool_val<<noboolalpha;//将内部状态恢复为默认格式
本例中我们改变了bool值的格式，但只对bool_val的输出有效。一旦完成此值的打印，我们立即将流恢复到
初始状态。

指定整型值的进制
	默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符hex、oct和dec将其改为十六进制、八
进制或是改回十进制:
		cout<<"default: "<<20<<" "<<1024<<endl;
		cout<<"octal: "<<oct<<20<<" "<<1024<<endl;
		cout<<"hex: "<<hex<<20<<" " <<1024<<endl;
		cout<<"decimal: "<<dec<<20<<" "<<1024<<endl;
当编译执行这段程序时，会得到如下输出:
		default:20 1024
		octal: 24 2000
		hex: 14 400
		decimal: 20 1024
注意，类似boolalpha，这些操纵符也会改变格式状态。它们会影响下一个和随后所有的整型输出。直至另一个
操纵符又改变了格式为止。
注意:
	操纵符hex、oct和decc只应县整型运算对象，浮点值的表示形式不受影响。

在输出中指出进制
	默认情况下，当我们打印出数值时，没有可见的线索指出使用的是几进制。例如，20是十进制的20还是16的
八进制表示？当我们按十进制打印数值时，打印结果会复合我们的期望。如果需要打印八进制或十六进制，应该
使用showbase操纵符。当对流应用showbase操纵符时，会在输出结果中显示进制，它遵循与整型常量中指定进
制相同的规范。
		>>>	前导0x表示十六进制。
		>>>	前导0表示八进制
		>>>	无前导字符串表示十进制
我们可以使用showbase修改前一个程序:
		cout<<	showbase;		//当打印整型值时显示进制
		cout<<"default: "<<20<<" "<<1024<<endl;
		cout<<"in octal: "<<oct<<20<<" "<<1024<<endl;
		cout<<"in hex: "<<hex<<20<<" "<<1024<<endl;
		cout<<"in decimal: "<<dec<<20<<" "<<1024>>endl;
		cout<<noshowbase;//恢复流状态
修改后的程序的输出会更清楚地表明底层值到底是什么:
		default: 20 1024
		in octal: 024 02000
		in hex: 0x14 0x400
		in decimal: 20 1024
操纵符noshowbase恢复cout的状态，从而不显示整型值的进制。
	默认情况下，十六进制会以小写打印，前导字符也是小写的x。我们可以通过使用uppercase操纵符来输出
大写的X并将十六进制数字a-f以大写输出:
		cout<<uppercase<<showbase<<hex
			<<"printed in hexadcimal: "<<20<<" "<<1024
			<<noupperacase<<noshowbase<<dec<<endl;
这句话生成如下的输出:
		printed in hexadcimal:0X14 0X400
我们使用了操纵符nouppercase、noshowbase和dec来重置流的状态。

控制浮点数格式
	我们可以控制浮点数输出三个格式:
		>>>	以多高精度(多少个数字)打印浮点值
		>>>	数值是打印为十六进制、定点十进制还是科学计数法形式
		>>>	对于没有小数部分的浮点值是否打印小数点
默认情况下，浮点值按六位数字精度打印；如果浮点值没有小数部分，则不打印小数点；根据浮点数的值选
择打印成成定点十进制或科学计数法形式。标准库会选择一种可读性更好的格式:非常大和非常小的值打印
为科学计数法形式，其他值打印为定点十进制形式。

指定打印精度
	默认情况下，精度会控制打印的数字总数。当打印时，浮点值按当前精度舍入而非截断。因此，如果当
前精度为四位数字，则3.14159将打印为3.142；如果精度为三位数字，则打印为3.14。
	我们可以通过调用IO对象的precision成员或使用setprecision操纵符来改变精度。preccision
成员是重载的。一个版本接受一个int值，将精度设置为此值，并返回旧精度值。另一个版本不接受参数，
返回当前精度值。setprecision操纵符接受一个参数，用来设置精度。
注意:
	操纵符setprecision和其他接受从参数的操纵符都定义在头文件iomanip中
下面的程序展示了控制浮点值打印精度的不同方法:
		//cout.precision返回当前精度值
		cout<<"Precision: "<<cout.precision()
			<<", Value: "<<sqrt(2.0)<<endl;
		//cout.precision(12)将打印精度设置为12位数字
		cout.precision(12);
		cout<<"Precision: "<<cout.precision()
			<<", Value: "<<sqrt(2.0)<<endl;
		//另一种设置精度的方法是使用setprecision操纵符
		cout<<setprecision(3);
		cout<<"Precision: "<<cout.precision()
			<<",Value: "<<sqrt(2.0)<<endl;
编译并执行这段程序，会得到如下输出:
		Precision:6, Value: 1.41421
		Precision:12, Value: 1.41421356237
		Precision:3, Value: 1.41
此程序调用标准库sqrt函数，它定义在头文件cmath中。sqrt函数是重载的，不同版本分别接受一个float、
double或long double参数，返回实参的平方根。
			表17.17:		定义在iostream中的操纵符
	boolalpha				将true和false输出为字符串
	* noboolalpha			将true和false输出为1,0
	showbase				对整型值输出表示进制的前缀
	* noshowbase			不生成表示进制的前缀
	showpoint				对浮点值总是显示小数点
	* noshowpoint			只有当浮点值包含小数部分时才显示小数点
	showpos					对非负数显示+
	* noshowpos				对非负数不显示+
	uppercase				在十六进制值中打印0X，在科学计数法中打印E
	* nouppercase			在十六进制值中打印0x，在科学计数法中打印e
	* dec					整型值显示为十进制
	hex						整型值显示为十六进制
	oct						整型值显示为八进制
	left					在值的右侧添加填充字符
	right					在值的右侧添加填充字符
	internal				在符号和值之间添加填充字符
	fixed					浮点值显示为定点十进制
	scientific				浮点值显示为科学计数法
	hexfloat				浮点值显示为十六进制
	defaultfloat			重置浮点数格式为十进制
	unitbuf					每次输出操作后都刷新方式
	* nounitbuf				恢复正常的缓冲区刷新方式
	* skipws				输入运算符跳过空白符
	noskipws				输入运算符不跳过空白符
	flush					刷新ostream缓冲区
	ends					插入空字符，然后刷新ostream缓冲区
	endl					插入换行，然后刷新ostream缓冲区
*表示默认流状态

指定浮点数记数法
	除非你需要控制浮点数的表示形式(如，按列打印数据或打印表示金额或百分比的数据)，否则由标准库
选择记数法是最好的方式。
	通过使用恰当的操纵符，我们可以强制一个流使用科学记数法、定点十进制或是十六进制记数法。操纵符scientific
改变流的状态来使用科学记数法。操纵符fixed改变流的状态来使用定点十进制。
	在新标准库中，通过使用hexfloat也可以强制浮点数使用十六进制格式。新标准库还提供另一个名为
defaulfloat的操纵符。它将流恢复到默认状态－－－根据要打印的值选择记数法。
	这些操纵符也会改变流的精度的默认含义。在指定scientific
fixed或hexfloat后，精度值控制
的是小数点后面的数字位数，而默认情况下精度值指定的是数字的总位数－－既包括小数点之后的数字也包
括小数点之前的数字。使用fixed或scientific令我们可以按列打印数值，因为小数点距小数部分的距离
是固定的:
		cout<<"default format: "<<100 * sqrt(2.0)<<'\n'
			<<"scientific: "<<scientific<<100*sqrt(2.0)<<'\n'
			<<"fixed decimal: "<<fixed<<100*sqrt(2.0)<<'\n'
			<<"hexadcimal: "<<hexfloat<<100 * sqrt(2.0)<<'\n'
			<<"use default: "<<defaultfloat<<100 * sqrt(2.0)<<"\n\n";
默认情况下，十六进制数字和科学记数法中的e都打印成小写形式，我们可以用uppercase操纵复方打印
这些字母的写形式。

打印小数点
	默认情况下，当一个浮点值的小数部分为0时，不显示小数点。showpoint操纵符强制打印小数点:
		cout<<10.0<<endl;		//打印10
		cout<<showpoint<<10.0
			<<noshowpoint<<endl;	//恢复小数点的默认格式
操纵符noshowpoint恢复默认行为。下一个输出表达式将有默认行为。即，当浮点值的小数部分为0时
不输出小数点。

输出补白
	当按列打印数据时，我们常常需要非常精细的控制数据格式。标准库提供了一些操纵符帮助我们完成所
需的控制:
		>>>	setw指定下一个数字或字符串值的最小空间
		>>>	left表示左对齐输出。
		>>>	right表示右对齐输出，右对齐是默认格式
		>>>	internal控制负数的符号的位置，它左对齐符号、右对齐值，用空格填满所有中间空间
		>>>	setfill允许指定一个字符代替默认的空格来补白输出。
注意:
	setw类似endl，不改变输出流的内部状态，它只决定下一个输出的大小。
下面的程序展示了如何使用这些操纵符
		int i = -16;
		double d = 3.14159
		//补白第一列，使用输出中最小12个位置
		cout<<"i: "<<setw(12)<<i<<"next col"<<'\n'
			<<"d: "<<setw(12)<<d<<"next col"<<'\n';
		//补白第一列，左对齐所有列
		cout<<left<<"i: "<<setw(12)<<i<<"next col"<<'\n'
			<<"d: "<<setw(12)<<d<<"next col"<<'\n'
			<<right;//恢复正常
		//补白第一列，右对齐所有列
		cout<<right<<"i: "<<setw(12)<<i<<"next col"<<'\n'
			<<"d: "<<setw(12)<<d<<"next col"<<'\n';
		//补白第一列，但补在域的内部
		cout<<internal<<"i: "<<setw(12)<<i<<"next col"<<'\n'
			<<"d: "<<setw(12)<<d<<"next col"<<'\n';
		//补白第一列，用#作为补白字符
		cout<<setfill('#')<<"i: "<<setw(12)<<i<<"next col"<<'\n'
			<<"d: "<<setw(12)<<d<<"next col"<<'\n'
			<<setfill(' ');
			表17.18		定义在iomanip中的操纵符
		setfill(ch)			用ch填充空白
		setprecision(n)		将浮点精度设置为n
		setw(w)				读或写值的宽度为w个字符
		setbase(b)			将整数输出为b进制

控制输入格式
	默认情况下，输入运算符会忽略空白符(空格符、制表符、换行符、换纸符和回车符)。下面的循环:
		char ch;
		while(cin>>ch)
			cout<<ch;
当给定下面输入序列时
		a b  c
		d
循环会执行4次，读取字符a到d，跳过中间的空格以及可能的制表符和换行符。此程序的输出是
		abcd
操纵符noskipws会令输入运算符读取空白符，而不是跳过它们。为了恢复默认行为，我们可以使用skipws
操纵符:
		cin >> noskipws;	//设置cin读取空白符
		while(cin>>ch)
			cout<<ch;
		cin >> skipws;	//将cin恢复到默认状态，从而丢弃空白字符
给定与前一个程序的相同输入，从循环会执行7次，从输入中既读取普通字符又读取空白符。此循环的输出为:
		a b  c
	//其实遇到换行符就会输出，所以不会输出d

17.5.2	未格式化的输入/输出操作
	到目前为止，我们的程序只使用过格式化IO操作。输入和输出运算符(<<和>>)根据读取或写入的数
据类型来格式化他们。输入运算符忽略空白字符。输出运算符应用补白、精度等规则。
	标准库还提供了一组低层操作，支持未格式化IO。这些操作允许我们将一个流当做一个无解释的字节
序列来处理。

单字节操作
	有几个未格式化操作每次一个字节地处理流。这些操作列在表17.19中，它们会读取而不是忽略空白
符。例如，我们可以使用未格式化IO操作get和put来读取和写入一个字符:
		char ch;
		while(cin.get(ch))
			cout.put(ch);
此程序保留输入中的空白字符，其输出与输入完全相同。它的执行过程与前一个使用noskipws的程序完全相同。
			表17.19:		单字节低层IO操作
	is.get(ch)			从istream is读取下一个字节存入字符ch中，返回is
	os.put(ch)			将字符ch输出到ostream os。返回os
	is.get()			将is的下一个字节作为int返回
	is.putback(ch)		将字符ch放回is。返回is
	is.unget()			将is向后移动一个字节。返回is
	is.peek()			将下一个字节作为int返回，但不从流中删除它。

将字符放回输入流
	有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将字符放回流中。标准库
提供了三种方法退回字符，它们有着细微的差别:
		>>>	peek返回输入流中下一个字符的副本，但不会将它从流中删除，peek返回的值仍然留在流中。
		>>>	unget使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取
什么值，仍然可以调用unget。
		>>>	putback是更特殊版本的unget:它退回从流中读取的最后一个值，但它接受一个参数，此参数
必须与最后读取的值相同。
一般情况下，在读取一个值之前，标准库保证我们可以退回最多一个值。即，标准库不保证在中间不进行读取
操作的情况下能连续调用putback或unget。

从输入操作返回的int值
	函数peek和无参的get版本都以int类型从输入流返回一个字符。这有些令人吃惊，可能这些函数返回
一个char看起来更自然。
	这些函数返回一个int的原因是:可以返回文件尾标记。我们使用char范围中的每个值来表示一个真实字符，
因此，取值范围中没有额外的值可以用来表示文件尾。返回int的函数将它们要返回的字符先转换为unsigned
char。然后在将结果提升到int。因此，即使字符集中有字符映射到负值，这些操作返回的int也是正值。而标
准库使用负值表示文件尾，这样就可以保证与任何合法字符的值都不同。头文件cstdio定义了一个名为EOF
的const，我们可以用它来检测从get返回的值是否是文件尾，而不必记忆表示文件尾的实际数值。对我们来说
重要的是，用一个int来保存这些函数返回的值:
		int ch;		//使用以一个int，而不是一个char来保存get()的返回值
		//循环读取并输出输入中的所有数据
		while(ch=cin.get() != EOF)
			cout.put(ch);
此程序与第673页中的程序完成相同的工作，唯一不同的是用来读取输入的get版本不同。

多字节操作
	一些未格式化IO操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，但类
似其他低层操作，这些操作也容易出错。特别是，这些操作要求我们自己分配并管理用来保存和提取数据的字符
数组列出了多字节操作。
			表17.20:	多字节低层IO操作
		is.get(sink,size,delim)
	从is中读取最多size个字节，并保存在字符数组中，字符数组的起始地址由sink给出。读取过程直至遇到字
符delim或遇到文件尾时停止。如果遇到了delim，则将其留在输入流中，不读取出来存入sink
		is.getline(sink,size,delim)
	与接受三个参数的get版本类似，但会读取并丢弃delim
		is.read(sink,size)
	读取最多size个字节，存入字符数组sink中。返回is
		is.gcount()
	返回上一个未格式化读取操作从is读取的字节数
		os.write(source,size)
	将字符数组source中size个字节写入os，返回os
		is.ignore(size,delim)
	读取并忽略最多size个字符，包括delim。与其他未格式化函数不同，ignore有默认参数:size的默认值
为1，delim的默认值为文件尾。
get和geline函数接受相同的参数，他们的行为类似但不相同。在这两个函数中，sink都是一个char数组，用
来保存数据。两个函数都是一致读取数据，直至下面条件之一发生:
		>>>	已读取了size-1个字符
		>>>	遇到了文件尾
		>>>	遇到了分隔符
两个函数的差别是处理分隔符的方式:get将分隔符留作istream中的下一个字符，而getline则读取并丢弃
分割符。无论哪个函数都不会将分隔符保存在sink中。　
注意:
	一个常见的错误是本想从流中删除分割符，但却忘了做。

确定读取了多少个字符
	某些操作从输入读取未知个数的字节。我们可以调用gcount来确定最后一个未格式化输入操作读取了
多少个字符。应该在任何后续未格式化输入操作之前调用gcount。特别是，将字符退回流的单字符操作也
属于未格式化输入操作。如果在调用gcount之前调用了peek、unget或putback，则gcount的返回值为0。
小心:低层函数容易出错
	一般情况下，我们主张使用标准库提供的高层抽象。返回int的IO操作很好地解释了原因。
	一个常见的编程错误是将get或peek的返回值赋予一个char而不是int。这样做是错误的，但编译器却
不能发现这个错误。最终会发生什么依赖于程序运行哪台机器以及输入的数据是什么。例如，在一台char被
实现为unsigned char的机器上，下面的循环就永远不会停止:
		char ch;	//此处使用char就是引入灾难
		//从cin.get返回的值被转换为char，然后与一个int比较
		while(ch = cin.get() != EOF)
			cout.put(ch);
问题出在当get返回EOF时，此值会被转换为一个unsigned char。转换得到的值与EOF的int值不再相等。
因此循环永远也不会停止。这种错误很可能在调试时发现。
	在一台char被实现为signed char的机器上，我们不能确定循环的行为。当一个越界的值被赋予一个
signed变量时会发生什么完全取决于编译器。在很多机器上，这个循环可以正常工作，除非输入序列中有一
个字符与EOF值匹配。虽然在普通数据中这种字符不太可能出现，但低层IO通常用于读取二进制值的场合，而
这些二进制值不能直接映射到普通字符和数值。例如，在我们的机器上，将-1转换为一个signed为\377的
字符,则循环会提前终止。因为在我们的机器上，将-1转换为signed char，就会得到\377。如果
输入中有这个值，则它会被(过早)当做文件尾指示符。
	当我们读写有类型的值时，这种错误就不会发生。如果你可以使用标准库的类型更加安全、更高层的操作，
就应该使用他们。

17.5.3	流随机访问
	各种流类型通常都支持对流中数据的随机访问，我们可以重定位流，使之跳过一些数据。首先读取最后
一行，然后读取第一行，依次类推。标准库提供了一对函数，来定位到流中给定的位置。以及告诉我们当前位
置。
注意:
	随机IO本质上是依赖于系统的。为了理解如何使用这些特性，你必须查询系统文档。
虽然标准库为所有流类型都定义了seek和tell函数，但他们是否会做有意义的事情依赖于流绑定到哪个设备。
在大多数系统中，绑定到cin、cout、cerr和clog的流不支持随机访问－－毕竟，当我们向cout直接输出数
据时，类似向回跳十个位置这种操作是没有意义的。对这些流我们可以调用seek和tell函数，但在运行时会
出错，将流置于一个无效状态。
注意:
	由于istream和ostream类型通常不支持随机访问，所以本节剩余内容只适用于fstream和sstrean类型。

seek和tell函数
	为了支持随机访问，IO类型维护一个标记来确定下一个读写操作要在哪里进行。它们还提供了两个函数:一
个函数：一个函数通过将标记seek到一个给定位置来重定位它；另一个函数tell我们标记的当前位置。标准库实
际上定义了两对seek和tell函数，如表17.21所示。一对用于输入流，另一对用于输出流。输入和输出版本的
差别在于名字的后缀是g还是p。g版本表示我们正在"获得"(读取)数据，而p版本表示我们正在"放置"(写入)数据。
			表17.21		seek和tell函数
	tellg()				返回一个输入流中(tellg)或输出流中(tellp)标记的当前位置
	tellp()
	seekg(pos)			在一个输入流或输出流中将标记重定位到给定的绝对地址。pos通
	seekp(pos)				常是前一个tellg或tellp返回的值
	seekp(off,from)		在一个输入流或输出流中将标记定位到from之前或之后off个字
	seekg(off,from)		符，from可以是下列之一
		>>>	beg,偏移量相对于流开始位置
		>>> cur,偏移量相对于流当前位置
		>>> end,偏移量相对于流结尾位置
从逻辑上将，我们只能对istream和派生自istream的类型ifstream和istringstream使用g版本，同样
只能对ostream和派生自ostream的类型ofstream和ostringstream使用p版本。一个iostream、
fstream或stringstream既能读又能写关联的流，因此，对这些类型的对象既能使用g版本又能使用p版本。

只有一个标记
	标准库区分seek和tell函数的"放置"和"获得"版本这一特性可能会导致误解。即使标准库进行了区分，
但它在一个流中只维护单一的标记－－并不存在独立的读标记和写标记。
	当我们处理一个只读或只写的流时，两种版本的区别甚至是不明显的。我们可以对这些流只使用g或只使
用p版本。如果我们试图对一个ifstream流调用tellp，编译器会报告错误，类似的，编译器也不会允许我们
对一个ostringstream使用seekg。
	fstream和stringstream类型可以读写同一个流。在这些类型中，有单一的缓冲区用于保存读写的数据，
同样，标记也只有一个，表示缓冲区中的当前位置。标准库将g和p版本的读写位置都映射到这个单一的标记。
注意:
	由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行seek操作来重定位标记。

重定位标记
	seek函数有两个版本:一个移动到文件中的"绝对"地址；另一个移动到一个给定位置的指定偏移量:
		//将标记移动到一个固定位置
		seekg(new_position);	//将读标记移动到指定的pos_type类型的位置
		seekp(new_position);	//将写标记移动到指定的pos_type类型的位置
		//移动到给定起始点之前或之后指定的偏移位置
		seekg(offset,from);		//将读标记移动到距from偏移量为offset的位置
		seekp(offset,from);		//将写标记移动到距from偏移量为offset的位置
from的可能值如表17.21所示。
	参数new_postion和offset的类型分别是pos_type和off_type，这两个类型都是机器相关
的，他们定义在头文件istream和ostream中。pos_type表示一个文件位置，而off_type表示距当前位
置的一个偏移量。一个off_type类型的值可以是正的也可以是负的，即，我们可以在文件中向前移动或向后
移动。

访问标记
	参数tellg和tellp返回一个pos_type值，表示流的当前位置。tell函数通常用来记住一个位置，
以便稍后再定位回来:
		//记住当前写位置
		ostringstream writeStr;	//输出stringstream
		ostringstream::pos_type mark = writeStr.tellp();
		//...
		if(cancelEntry)
			//回到刚才记住的位置
			writeStr.seekp(mark);

读写同一个文件
	我们来考察一个编程实例。假定已经给定义了一个要读取的文件，我们要在此文件的末尾写入新的一行，
这一行包含文件中每行的相对起始的位置。例如，给定下面文件:
		abcd
		efg
		hi
		j
程序应该生成如下修改过的文件:
		abcd
		efg
		hi
		j
		5 9 12 14
注意，我们的程序不必输出第一行的偏移－－它总是从位置0开始。还要注意，统计偏移量时必须包含每行末
尾不可见的换行符。最后，注意输出的最后一个数是我们的输出开始那行的偏移量。在输出中包含了在这些偏
移量后，我们的输出就与文件的原始内容区分开来了。我们可以读取结果文件中最后一个数，定位到对应的偏
移量，即可得到我们的输出的起始地址。
	我们的程序将逐行读取文件，对每一行，我们将递增计数器，将刚刚读取的一行的长度加到计数器上，则
此计数器即为下一行的起始地址:
		int main(){
			//以读写的方式打开文件，并定位到文件尾
			//文件模式参数见8.2.2节
			fstream inOut("copyOut",fstream::ate | fstream::in | fstream::out);
			if(!inOut){
				cerr<<"Unable to open file!"<<endl;
				return EXIT_FAILURE;
			}
			//inOut以ate模式打开，因此一开始就定义到其文件尾
			auto end_mark = inOut.tellg();	//记住原文件尾位置
			inOut.seekg(0,fstream::beg);	//重定位到文件开始
			size_t cnt = 0;		//字节累加器
			string line;
			//继续读取的条件:还未遇到错误且还在读取原数据
			while(inOut && inOut.tellg() != end_mark && getline(inOut,line)){//且还可获取一行输入
				cnt += line.size()+1;
				auto mark = inOut.tellg();		//记住读取的位置
				inOut.seekp(0,fstream::end);	//将写标记移动到文件尾
				inOut<<cnt;
				//如果不是最后一行，打印一个分割符
				if(mark != end_mark)inOut<<" ";
				inOut.seekg(mark);		//恢复读位置
			}
			inOut.seekp(0,fstream::end);		//定位到哦文件尾
			inOut<<"\n";
			return 0;
		}
我们的程序用in、out和ate模式打开fstream。前两个模式指出我们想读写同一个文件。指定ate会将读写标记
定位到文件尾。与往常一样，我们检查文件是否成功打开，如果失败就退出。
	由于我们的程序向输入文件写入数据，因此，不能通过文件尾来判断是否停止读取，而是应该在达到原数据的
末尾时停止。因此，我们必须首先记住原文文件尾的位置。由于我们是以ate模式打开文件的，因此，inOut已经
定义到文件尾了。我们将当前位置(即，原文件尾)保存在end_mark中。记住文件尾位置之后，我们seek到距
文件起始位置偏移量为0的地方，即，将读标记重定位到文件起始位置。
	while循环的条件由三部分组成:首先检查流是否合法；如果流合法，通过比较当前读位置(由tellg返回)和
记录在end_mark中的位置来检查是否读完了原数据；最后假定前两个检查都已成功，我们调用getline读取输入
的下一行，如果getline成功，则执行while循环体。
	循环体首先将当前位置记录在mark中。我们保存当前位置是为了在输出下一个偏移量后再退回来。接下来调
用seekp将写标记重定位到文件尾。我们输出计数器的值，然后调用seekg回到记录在mak中的位置。回退到原
位置后，我们就准备好继续检查循环条件了。
	每步循环都会输出下一行的偏移量。因此此次，最后一步循环负责输出最后一行的偏移量。但是，我们还要在
文件末尾输出一个换行符。与其他写操作一样，在输出换行符之前我们调用seekp来定位到文件尾。
