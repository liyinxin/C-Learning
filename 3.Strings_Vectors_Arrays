									第三章	字符串、向量和数组
内容
--------------------
	3.1	命名空间的using声明
	3.2	标准库类型string
	3.3	标准库类型vector
	3.4	迭代器介绍
	3.5	数组
	3.6	多维数组

3.1	命名空间的using声明
	到目前为止，我们用到的函数库基本上都属于命名空间std。而程序也是显示的将这一点标示了出来。
例如，std::cin表示从标准输入中读取内容。此处使用作用域操作符（：：）的含义是：编译器应该从
操作符左侧的名字所示的作用域中寻找右侧那个名字。（也就好比是从命名空间中调用cin这个函数一样）
	上面的写法显得比较繁琐，然而幸运的是，通过更简单的途径也可以使用到命名空间中的成员。本
节学习其中一种最安全的方法，也就是使用using声明(using declaration）。有了using声明就无须
专门的前缀（形如命名空间::）也能使用所需的名字了。using声明具有如下的形式：
				using namespace::name
一旦声明了上述语句，就可以直接访问命名空间中的名字：
				using std::cin;//这样就可以使用std空间中的cin函数了。


每个名字都需要独立的using声明
	按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using
声明引入命名空间中的一个成员。
		using std::endl;using std::cout;//等等

头文件不应该包含using声明
	位于头文件的代码，一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中
去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明，对于某些程序来说，由
于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。（所以这里尽量别使用using namespce::name)

3.2	标准库类型string（定义在std空间）
	标准库类型string表示 可变长 的 字符序列 ，使用string类型必须首先包含string头文件。作为标准库
库的一部分，string定义在命名空间std中。接下来的示例都假定包含了下述代码
			#include <string>   //包含string头文件
			using std::string;	//使用std空间中的string
C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出了一些性能上的需求。因此，标准
库类型对于一般应用场合来说有足够的效率。
3.2.1	定义和初始化string 对象
	如何初始化类的对象是由类的本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有
所区别：或者是初始值的数量不同，或者是初始值的类型不同。表3-1列出了初始化string对象最常用的一些方式：
				表3.1	初始化string对象的方式
		string s1					默认初始化，s1是一个空字符串
		string s2(s1)				s2是s1的副本//注意，其实这是一个类的对象而已，也就是构造对象
									的时候用的是构造函数，所以得用()来传入参数
		string s2 = s1;				等价于s2(s1)，s2是s1的副本
		string s3("value")			s3是字面值"value"的副本，s3是字面值"value"的副本
		string s3 = "value"			等价于s3("value")，s3是字面值"value"的副本
		string s4(n,'c')			把s4初始化为由连续n个字符c组成的串
例如：
		string s1;					//默认初始化，s1是一个空字符
		string s2=s1;				//s2是s1的副本
		string s3="hiya";			//s3是该字符串字面值的副本
		string s4(10,'c');			//s4是内容是cccccccccc
		
直接初始化和拷贝初始化
	C++语言有几种不同的初始化方式，通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。
如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初
始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化（direct initiaonlization）
	当初始值只有一个时，使用直接初始化或拷贝初始化都行；如果像上面的s4那样初始化要用到多种值，一般来说只能
使用直接初始化（例外有可能是：使用{}来进行初始化，注意{}初始化的时候，如果精度丢失的话，就会造成错误）。
					string s5 = "hiya";//拷贝初始化
					string s6("hiya");//直接初始化
					string s7(10,'c');//直接初始化，这个表示，s7是由10个c组成的字符串
对于用多个值进行初始化的情况，非要用拷贝初始化的方式来处理也不是不可以，不过需要显示的创建一个（临时）对象
用于拷贝。
					string s8 = string(10,'c');//拷贝初始化，其实就是建立一个对象然后赋值给新的对象
s8的初始值是string(10,'c')，它实际上是用数字10和字符c两个参数创建出来的一个string对象，然后这个string对
象又拷贝给了s8（等于号的意思不就是拷贝的意思嘛，所以就叫做拷贝初始化）。

3.2.2	string对象上的操作
	一个类除了要规定初始化其对象的方式，还要定义对象上所能执行的操作。其中，类既能定义通过函数调用的操作，就像
Sales_item类的isbn函数那样，也能定义<<.+等各种运算符在该类对象上新的含义。表3.2列举了string的大多数操作
						表3.2		string的操作
			os<<s						将s写到输出流os当中，并返回os
			is>>s						从is中读取字符串赋给s，字符串以空白分割，返回is
			getline(is,s)				从is中读取一行赋给s，并返回is
			s.empty()					s为空返回true，否则返回false
			s.size()					返回s中字符的个数
			s[n]						返回s中第n个字符的 引用 ，位置n从0开始
			s1+s2						返回s1和s2连接后的结果
			s1=s2						用s2的副本代替s1中原来的字符
			s1==s2						如果s1和s2中所含的字符完全一样，则它们相等；string对象的想等性
										对大小写字母敏感
			s1!=s2						等性判断对字母的大小写敏感
			<,<=,>,>=					利用字符在字典中的顺序进行比较，且对字母的大小写敏感

读写string对象
	第一章中曾经介绍过，使用标准库中的iostream来读写int、double等内置类型的值。同样，也可以使用IO操作符读写
string对象。
			#include <string>
			using namespace std;
			int main()
			{
				string s;
				cin >> s;
				cout<<s<<endl;
				return 0;
			}
string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇到下一处空白为止。
和内置类型的输入和输出操作一样，string对象的此类操作也是返回运算符 左侧的运算 对象 作为其结果。因此多个输入或者
多个输出可以连写在一起。
			string s1,s2;
			cin>>s1>>s2;
			cout<<s1<<s2<<endl;
读取未知变量的string对象
			int main()
			{
				string word;
				while(cin >> word)
					cout<< word<<endl;
				return 0;
			}
在该程序中，读取的对象是string而非int，但是while语句的条件部分和之前版本的程序是一样的。该条件负责在读取时检测流
的情况，如果流有效，也就是说没有遇到文件结束标记或非法输入，那么执行while语句的内部操作。此时，循环体将输出刚刚从标
准读取的内容。重复若干次之后，一旦遇到文件结束标记或非法输入循环也就结束了。

使用getline读取一整行
	有时我们希望能在最终得到的字符串中保留输入时的空白字符。这时应该使用getline函数代替原来的>>运算符。getline
函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读取进来了）
然后把所读取的内容存放到那个string对象中去（注意不存在换行符）。getline函数一遇到换行符就结束读取操作并返回结果，
哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果就是个空的string。		
但是注意：
		getline的返回是basic_istream,也就是说即使是空的string，返回的结果也是basic_istream类型的东西，所以
你要是用其作为判断条件的话，就注意了。任何输入的返回都是1，所以使用
			while(getline(cin,line))
				cout<<line;
这样的话，会跳不出while循环的！

string的empty和size操作
	顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值。和Sales_item类的isbn成员一样，empty也是
string对象的一个成员函数。调用该函数的方法就是普通对象调用成员函数一样。使用的是点操作符。
		while(getline(cin,line))
		{
			if(!line.empty())
				cout<<line;
		}
这样就可以通过判断输入的数据是否为空，从而可以进行相应的判断，然后就可以跳出while循环。
	size函数返回string对象的长度（即string对象中字符的个数），可以使用size函数只输出长度超过80个字符的行：
			string line;
			while(getline(cin,line))
			{
				if(line.size()>80)
					cout<<line;
			}

string::size_type类型
	对于size函数来说，返回一个int或者如前面所述的那样返回一个unsigned似乎都是合情合理的。但是其实size函数返回的是
一个string::size_type类型的值。
注意：其实这个类型就是string类的一个成员变量。
	string类及其它大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性，类型size_type
即是其中一种。在具体使用的时候，通过作用域操作符来表明名字size_type是在类string中定义的。尽管我们不太清楚
string::size_type类型的细节。但是有一点可以肯定的是：它是一个无符号类型的值，而且能够足够存放下任何string对象的大小。
所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的！！
	过去，string::size_type这种类型有点神秘，不太容易理解和使用。在C++11新标准中，允许编译器通过auto或者decltype
来推断变量的类型：
				auto len = line.size();//auto是靠右边的值的类型来自动推断类型的，所以这个len的类型就是size_type
注意：
	由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如
，假设n是一个具有负值的int，则表达式s.size()<n的判断结果几乎肯定是true。这是因为负值n会自动转换成一个比较大的无符号值！
所以一定要注意这个无符号和有符号混在一块，有符号的会自动转换成无符号的值！！

比较string对象
	string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感，也就是说，在比较
时同一个字母的大写形式和小写形式是不同的。
	相等性运算符（==和!=）分别检验两个string对象相等或不相等，string对象相等意味着他们的长度相同而且所包含的字符也全相同。
关系运算符<、<=、>、>=分别检验一个string对象是否小于，小于等于，大于，大于等于。上述这些运算符都依照（大小写敏感的）字典顺序：
		>>>>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短
string对象小于较长string对象。
		>>>>如果两个string对象在某些对应位置上不一致，则string对象比较的结果其实就是string对象中第一对相异字符比较的结果

为string对象赋值
	一般来说，在设计标准库类型时都力求在易用上向内置类型看齐，因此  大多数库类型都支持赋值操作！！  对于string类而言，允许
把一个对象赋值给另外一个对象：
		string st1(10,'c'),str2;
		st1 = str2;//st1变成一个空字符串了
两个string对象相加：
	两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。也就是说，对string对象使用
加法运算符（+）的结果是一个新的string对象，它所包含的字符由两个部分组成，前半部分由第一个string对象组成，第二部分由第二个
string对象组成。也具有+=操作符。

字面值和string对象相加
	因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。利用
这一点将之前的程序改写成如下形式：
			string s1 = "hello",s2 = "world";
			string s3 = s1 + "," + s2 + '\n';//
当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string
对象：
			string s4 = s1 + ", ";
			string s5 = "hello" + ", ";//错误：两个运算对象都不是string
我个人的理解：
	因为+操作符在这里其实就是string类的一个重载运算符。所以如果你两边没有string对象，那么其实就是用的就是系统内置的+运算符，
肯定是报错的。但是如果要是有一个就是类string的重载操作符了。所以就可以使用了！！
			string s6 = s1 + ", " + "world";//正确
			string s7 = "hello" + ", " + s2;//错误：不能把字面值直接相加
其中s6中，子表达式 s1 + ", "的结果是一个string对象，同时作为第二个加法运算符的左侧运算对象，因此上述语句和下面的和语句是等
价的：
			string tmp = s1 + ", ";
			s6 = tmp + "world";

	另一个关键问题是要知道能改变某个字符的特性。在cctype头文件中定义了一组标准库函数处理这部分工作。表3.3列出了主要函数名及
其意义
						表3.3：cctype头文件中的函数
		isalnum(c)					当c是字母或数字时为真
		isalpha(c)					当c是字母是为真
		iscntrl(c)					当c是控制字符时为真
		isdigit(c)					当c是数字时为真
		isgraph(c)					当c不是空格但可以打印时为真
		islower(c)					当c是小写字母时为真
		isprint(c)					当c是可打印字符时为真（即c是空格或c具有可视形式）
		ispunct(c)					当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）
		isspace(c)					当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）
		isupper(c)					当c是是大写字母的时候为真
		isxdigit(c)					当c是十六进制数字时为真
		tolower(c)					如果c是大写字母，输出对应的小写字母；否则原样输出c
		toupper(c)					如果c是小写字母，输出对应的大写字母；否则原样输出c
		
建议：使用C++版本的C标准库头文件
	C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命为cname。也就是
去掉了.h后缀！！！！而在name之前加了一个c字母，这里的c表示这是一个属于C语言标准库的头文件。
	因此cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来来讲更符合C++语言的要求。特别的，在名为cname的头文件中
定义的名字从属于命名空间std，而定义在名为.h的头文件中则不然！！！
	一般来说，C++程序应该使用名为cname的头文件，而不是使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式
的头文件，程序员不得不时刻牢记哪些是从C语言那继承过来的，哪些又是C++语言所独有的！

处理每个字符？使用基于范围for语句
	如果想对string对象中的每个字符做点什么操作，目前最好的办法就是使用C++11新标准提供的一种语句：范围for语句。这种语句遍历给定序
列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：
							for (declaration : expression)
								statement
其中，expression部分是一个对象，用于表示一个 序列 。declaration部分负责定义一个变量，该 变量 将被用于访问 序列 中的 基础元素 。
每次迭代，declaration部分的 变量会 被初始化为expression部分的 下一个元素。
	一个string对象表示一个字符的序列，因此string对象可以作为范围for语句中的expression部分。举一个简单的例子，我们可以使用for
语句把string对象中的字符每行一个输出出来：
							string str("some string");
							for (auto c : str)
								cout<< c << endl;
for循环把变量c和str联系了起来，其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的。此例中，通过使用auto关键字让编译器来
决定变量c的类型，这里c的类型是char（之所以是char，是因为根据后面expression中的序列的单个的元素是什么类型，推断出来的）。每次迭代，
str的下一个字符被拷贝给c，因此该循环可以读作：对于字符串str中的每个字符c“，执行某某操作。此例中的”某某操作“即输出一个字符，然后换行。
	举个稍微复杂一点的例子，使用for语句和ispunct函数来统计string对象中标点符号的个数：
							string s("hello world!!!");
							//punct_cnt的类型和s.size的返回类型一样，
							decltype(s.size()) punct_cnt = 0;
							//统计s中标点符号的数量
							for(auto c : s)
							{
								if(ispunct(c))
									++punct_cnt;
							}
							cout<<punct_cnt
								<<" punctuation characters in " << s << endl;
程序的输出结果是：
							3 punctuation characters in hello world!!!

使用范围for语句改变字符串中的字符
	如果想要改变string对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量
时，这个变量实际上被依次绑定到了序列的每一个元素上。使用这个引用，我们就能改变它绑定的字符。例如下边这个改变string对象中的小写字母为大写
字母：
							string s("Hello world!!!");
							for (auto &c : s)
								c = toupper(c)
							cout<<s<<endl;
每次迭代时，变量c引用string对象s的下一个字符，赋给c也就是在改变s中对应字符的值。因此当执行下面的语句时：
							c = toupper(c);//c是一个引用，因此赋值语句将改变s中字符的值
实际上改变了c绑定的字符的值。

只处理一部分字符？
	要想访问string对象中的单个字符有两种形式：一种是使用下标；另外一种是使用迭代器。
下标运算符（[]）接受的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。string对象
的下标从0记起。如果string对象s至少包含两个字符，则s[0]表示的是第一个字符，s[1]是第二个字符，s[s.size()-1]是最后一个字符。
下标的值称作”下标“或”索引“，如果索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。
							if(!s.empty())//这一步很重要，这个习惯得有！因为string对象使用索引的时候，不能越界，
										 //所以必须得先判断是不是string对象是不是存在，如果不存在，那么s[0]就是越界了
										 //所以必须得判断！
								cout<<s[0]<<endl;
使用下标执行迭代
	另一个例子是把s的第一个词改写成大写形式：
							for(decltype(s.size()) index = 0;
								index != s.size() && !isspcae(s[index]);
								index ++)
								s[index] = toupper(s[index]));
index的类型是由decltype来决定的（注意，decltype是通过表达式来决定类型的，而auto是根据等号右侧的表达式来决定的类型的）

3.3	标准库类型vector
	标准库类型vector表示对象的集合，其中所有对象的类型都相同，集合中的每个对象都有一个与之对应的索引。索引用于访问对象。因为
vector”容纳着“其他对象，所以它也常被称作容器（container）。要想使用vector，必须得包含适当的头文件，在后续的例子中，都将
假定做了如下using声明：
							#include <vector>
							using std::vector;
C++语言既有类模板（class template），也由函数模板，其中vector是一个类模板。只有对C++有了相当深入的理解才可以写出模板。模板
本身不是类或函数；相反可以将模板看作为(四声）编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，当
使用模板时，需要指出编译器应该把类或函数实例化成何种类型！！！
	对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么类，需要提供哪些信息由模板决定。提供信息的方式总是这样的：即在
模板名字后面跟一对尖括号，在括号内放上信息。以vector为例，提供的额外信息是vector内所存放对象的类型：
						vector<int> ivec;//ivec存放int类型的对象
						vector<Sales_item>	Sales_vec;//保存Sales_item类型的对象
						vector< vector<string>>	file;//该向量的元素是vector对象。
vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。除此之外，其他大多数内置类型和类类型都可以
构成vector对象，甚至组成vector的元素也可以是vector。需要指出的是，在早期版本的C++标准中如果vector的元素还是vector（或者其他模板
类型），则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间加一个空格，如
						vector<vector<int> >

定义和初始化vector对象
	和任何一种类类型一样，vector模板控制着定义和初始化向量的方法。表3.4列出了定义vector对象的常用方法：
				vector<T>	v1						v1是一个空vector，它潜在的元素是T类型的，执行的是默认初始化！
				vector<T>	v2(v1)					v2中包含v1所有元素的副本//拷贝初始化
				vector<T>	v2 = v1					等价于v2(v1),v2中包含v1所有元素的副本//直接初始化
				vector<T>	v3(n,val)				v3包含了n个重复的元素，而且每个元素都是val;//其实这个就是string
				vector<T>	v4(n)					v4包含了n个重复地执行了值初始化的对象
				vector<T>	v5{a,b,c...}			v5包含了初始值个数的元素，每个元素都被赋予相应的初始值
				vector<T>	v5={a,b,c...}			等价于v5{a,b,c...}
其实上述的初始化操作和以往的初始化是一样的，无须特意记住，但是一定要记住最基础的那些初始化方式。
				vector<string>	svec;//默认初始化，sevc不含任何元素
看起来vector好像没什么用，但是很快我们就会知道程序在运行时可以很高效的往vector对象中添加元素。事实上，最常见的方式就是先
定义一个空vector，然后当运行时获取到元素的值后再逐一添加。当然也可以在vector对象时指定元素的初始值。例如，允许把一个vector对象
的元素拷贝给另外一个vector对象。此时，新vector对象的元素就是原vector对象对应元素的副本。注意两个vector对象的类型必须相同：
				vector<int>	ivec;					//初始状态为空
				vector<int>	ivec2(ivec);			//把ivec的元素拷贝给ivec2
				vector<int>	ivec3 = ivec2;			//把ivec的元素拷贝给ivec3
				vector<string>	svec(ivec2);		//错误:svec的元素是string对象，不是int

列表初始化vector对象
	C++11新标准还提供了另外一种vector对象的元素赋初值的方法，即列表初始化。此时，用花括号括起来的0个或多个初始值元素值被赋给vector
对象：
					vector<string>	articles = {"a","an","the"};
上述vector对象包含三个元素：第一个是字符串"a",第二个是字符串"an",第三个是字符串“the“。目前已经介绍过的两种例外情况是：
			>>>>其一，使用拷贝初始化时（即使用=时）只能提供一个初始值；
			>>>>其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。
			>>>>第三种特殊的要求是，如果提供的是初始值元素值的列表。则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里

				vector<string>	v1{"an","an","the"};		 //列表初始化
				vector<string>	v2("an","an","the");		//错误
创建指定数量的元素
	还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：
				vector<int>	ivec(10,-1);		//10个int类型的元素，每个元素的值是-1
				vector<string>	svec(10,"hi");	//10个string类型的元素，每个元素的值是hi
值初始化：
	通常情况下，可以只提供vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的（value-initialized）元素初值，并
把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。如果vector对象的元素是内置类型，比如int，则元素初始值自动设为0。如
果元素是某种类类型，比如string，则元素由类默认初始化。
				vector<int>	ivec(10);		//10个元素，每个元素的值是0
				vector<string>	svec(10);	//10个元素，每个元素的值是空的string对象
对这种初始化的方式有两个特殊限制：
		>>>>>其一，有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种
类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
		>>>>>其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

列表初始值还是元素数量？
	在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。例如，用一个整数来初始化vector<int>时，整数的含义可能
是vector对象的容量也可能是元素的值。类似的，用两个整数来初始胡vector<int>时，这两个整数可能一个是vector对象的容量，另一个是元素
的初始值，也可能一个是vector对象的容量，另一个是元素的初值，也可能他们是容量为2的vector对象中两个元素的初始值。通过使用花括号或圆
括号可以区分上述这些含义：
				vector<int>	v1(10);			//v1有10个元素，每个元素的值都是0
				vector<int>	v1{10};			//v1有一个元素，该元素是10
				vector<int>	v3(10,1);		//v3有10个元素，每个元素的值都是1
				vector<int>	v4{10,1};		//v4有两个元素，值分别是10和1
如果使用的是圆括号，可以说提供的值是用来构造vector对象的。例如，v1的初始值说明了vector对象的容量。

