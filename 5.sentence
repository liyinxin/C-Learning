											第五章		语句
内容
-------------------------------
	5.1	简单语句
	5.2	语句作用域
    5.3 条件语句
	5.4	迭代语句
	5.5	跳转语句
	5.6	try语句块和异常处理
-------------------------------
5.2	语句块作用域
	可以在if、switch、while和for语句的控制结构定义类变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：
					while(int i = get_num() )
							cout<<i<<endl;
					i = 0;//错误：在循环外部无法访问i
switch 内部的变量定义
	如前所述，switch的执行流程有可能会跨过某些case标签。如果程序跳转到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉。这种忽略掉一部分代码的行为引出了一个有趣的问题：如果被忽略过的代码中含有变量的定义该怎么办？
	答案是：如果在某一处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为！
注意：
			别在case语句中定义变量就好了！！！

for语句头中的多重定义
	和其他的声明一样，init-statement也可以定义多个多谢。但是init-statement只能有一条声明语句。因此所有变量的基础类型必须相同！举个例子，我们用下面的循环把vector的元素拷贝一份添加到原来的元素后面：
				for(decltype(v.size()) i = 0,sz = v.size(); i != sz;++i)
						v.push_back(v[i]);
5.4.3	范围for语句
	C++11 新标准引入了一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。范围for语句的语法形式是：
			for(declaration : expression)
					statement;
expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者vector或string等类型的对象！这些类型的共同特点是拥有能返回迭代器的begin和end成员。
	declaration定义一个变量，序列中的每个元素都可以转换成该变量的类型。确保类型相容最简单的方法就是使用auto类型说明符。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。	
	学习了范围for语句的原理之后，我们也就不难理解为什么强调不能通过范围for语句增加vector对象的元素了。在范围for语句中，预存了end()的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了！	
5.5.2	continue语句
	continue语句终止最近的循环中的当前迭代并立即开始下一次迭代！continue语句只能出现在for、while和do while循环的内部中，或者嵌套在此类循环里的语句或块的内部。和break语句类似的是，出现在嵌套循环中的continue语句也仅作用于离它最近的循环。和break语句不同的是，只有当switch语句嵌套在迭代语句内部时，才能在switch里使用continue。
	continue语句中断当前的迭代，但是仍然继续执行循环。对于while或者do while语句来说，继续判断条件的值；对于传统的for循环来说，继续执行for语句头的express；而对于范围for语句来说，则是用序列中的下一个元素初始化循环控制变量！例如：
				string buf;
				while(cin>>buf && !buf.empty())
				{
					if(buf[0] != '_')
						continue;
				}
5.6	try语句块和异常处理
	异常是指存在于运行时的反常行为，这些行为超出了函数的正常功能的范围。典型的异常包括失去数据库的连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难办的一部分。
	当程序的某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了。而且信号发出方无需知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分就完成了任务。
	如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库的连接，会发出警报信息。
	异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：
			>>>throw表达式（throw expression)，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise)了异常。
			>>>ｔry语句块(try block)，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句处理异常，所以他们被称为异常处理代码。
			>>>一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。
5.6.1	throw表达式
	程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。
	举个简单的例子，把两个Sales_item对象相加的程序。这个程序检查它读入的记录是否关于同一种书籍的，如果不是，输出一条信息后退出。
			Sales_item item1,item2;
			cin >> item1 >> item2;
			if(item1.isbn() == item2.isbn())
			{
				cout<< item1 + item2;
				return 0;
			}
			else
			{
				cerr<< " Data must refer to same ISBN"<<endl;
				return -1;
			}
在真实的程序中，应当把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完后不再直接输出一条信息，而是抛出一个异常。
				if(item1.isbn() != item2.isbn())
					throw runtime_error("Data must refer to same ISBN");
				cout<<item1 + item2<<endl;
在这段代码中，如果ISBN不一样就抛出一个异常，该异常类型是runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。
	类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件当中。关于标准异常类型更多的知识将在后面介绍。我们必须初始化runtime_error的对象。方式是给它提供一个string对象或者一个C风格的字符串，这个字符串中有一些关于异常的辅助信息。
5.6.2	try语句块
	try语句块的通用语法形式是
				try
				{
					program-statements
				}
				catch(excepetion-declaration)
				{
					handler-statements
				}
				catch(excepetion-declaration)
				{
					handler-statements
				}// ...
try语句块的一开始是一个关键字try，随后紧跟着一个快，这个快就像大多数时候那样是花括号括起来的语句序列。
	跟在try语句块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作异常声明，exception declaration)以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。
	try语句块中的program-statements组成程序的正常逻辑，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常，try语句块内声明的变量在块外无法访问，特别是子啊catch子句内也无法访问。

编写处理代码
	在之前的例子里，我们使用了一个throw表达式以避免把两个代表不同书籍的Sales_item相加。我们假设执行Sales_item对象假发的代码是与用户交互的大妈部分离开来的。其中与用户交互的代码负责处理发送的异常，它的形式可能如下所示：
			while(cin　>> item1 >> item2)
			{
				try
				{
					//执行添加两个Sales_item对象的代码
					//如果添加失败，代码抛出一个runtime_error异常
				}
				catch(runtime_error_err)
				{
					//提醒用户两个ISBN必须一致，询问是否重新输入
					cout<<err.what()
						<<"\n Try Again?Enter y or n"<<endl;
					char c;
					cin>>c;
					if(!cin || c == 'n')
						break;
				}
			}
程序本来要执行的任务出现在try语句块中，这是因为这段代码中可能会抛出一个runtime_error类型的异常。
	try语句块对应一个catch子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。在我们书写的catch子句中，输出一段提示信息要求用户指定程序是否继续。如果用户输入'n'执行break语句并退出while循环。否则继续。
	给用户的提示信息中输出了err.what()的返回值，我们知道err的类型是runtime_error，因此能推断what是runtime_error类的一个成员函数。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串（即const char*)。其中,runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。如果上一届编写的代码抛出异常，则本节的catch子句输出：
			Data must refer to same ISBN
			Try Again? Enter y or n

函数在寻找处理代码的过程中退出
	在复杂的系统中，程序在遇到抛出异常的代码前，其执行路径可能已经过了多个try语句块。例如，一个tru语句块可能调用了包含另外一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推：
	寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有找到匹配的catch子句，终止该函数，并在调用该函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。依次类推，沿着程序执行的路径逐层回退，直到找到适当类型的catch子句为止。
	如果最终还是没有找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出！
	对于那些没有任何try语句块定义的异常，也按照类似的方式处理，毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发送了异常。系统会调用terminate函数并终止当前程序的执行。

5.6.3	标准异常
	C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用：
		>>exception头文件定义了最常用的异常类exception。它只报告异常的发生，不提供任何额外信息。
		>>stdexcept头文件定义了几种常用的异常类，
		>>new头文件定义了bad_alloc异常类型，‘
		>>type_info头文件定义了bad_cast异常类型。
				<stdexcept>定义的异常类
		exception			最常见的问题
---------------------------------------------------
		runtime_error		只有在运行时才能检测出的问题
		range_error			运行时错误：生成的结果超出了有意义的值域范围
		overflow_error		运行时错误：计算上溢
		underflow_error		运行时错误：计算下溢
		logic_error			程序逻辑错误
		domain_error		逻辑错误：参数对于的结果值不存在
		invalid_argument	逻辑错误：无效参数
		length_error		逻辑错误：试图创建一个超出该类型的最大长度的对象
		out_of_range		逻辑错误：使用一个超出有效范围的值
-------------------------------------------------
标准库异常类只定义了几种运算，包括创建或拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。
	其他异常类型的行为恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象。但是不允许使用默认初始化的方式。！！当创建此类对象的时候，必须提供初始值，该初始值含有错误相关的信息。
	异常类型只定义了一个名为whar的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串的const char*，该字符串的目的是提供关于异常的一些文本信息。
	what函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串的初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定！
