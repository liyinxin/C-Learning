								第16章　模板与泛型编程
内容
--------------------------------
	16.1	定义模板
	16.2	模板实参推断
	16.3	重载与模板
	16.4	可变参数模板
	16.5	模板特例化
--------------------------------
	面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于:OOP能处理在程序运
行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。
	本书第II部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任
何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。
	例如，标准库为每个容器提供了单一的、泛型的定义，如vector。我们可以使用这个泛型定义来定义
很多类型的vector，他们的差异就在于包含的元素类型不同。
	模板是泛型编程的基础。我们不必了解模板是如何定义的就能使用它们，实际上我们已经这样用了。在本章中，
我们将学习如何定义自己的模板。
	模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的
泛型类型，或者find这样的泛型函数时，我们提供足够的信息。将蓝图转换为特定的类或函数。这种转换发生在编译
时。在本书第三章和第II部分中我们已经学习了如何使用模板。在本章中，我们将学习如何定义模板。

16.1	定义模板
	假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第二个值。在实际中，我们
可能想要定义多个函数，每个函数比较一种给定类型的值。我们的初次尝试可能定义多个重载函数:
		//如果两个值相等，返回0，如果v1小返回-1，如果v2小返回1
		int compare(const string &v1,const string &v2){
			if(v1 < v2) return -1;
			if(v2 < v1) return 1;
			return 0;
		}
		int compare(const double &v1,const double &v2){
			if(v1 < v2) return -1;
			if(v2 < v1) return 1;
			return 0;
		}
这两个函数几乎是相同的，唯一的差异是参数类型，函数体则完全一样。如果对每种希望比较的类型都不得不重复
定义完全一样的函数体，是非常繁琐而且容易出错的。更麻烦的是，在编写程序的时候，我们就要确定可能要compare
的所有类型。如果希望能在用户提供的类型上使用此函数，这种策略就失效了。

16.1.1	函数模板
	我们可以定义一个通用的函数模板，而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来
生成针对特定类型的函数版本。compare的模板版本可能像下面这样:
		template　<typename　T> int compare(const T &v1,const T &v2){
			if(v1 < v2) return -1;
			if(v2 < v1) return 1;
			return 0;
		}
模板定义以关键字template开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表。用小
于号(<)和大于号(>)包围起来。
注意:
	在模板定义中，模板参数列表不能为空。
模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化他们。
在运行时，调用者提供实参来初始化形参。
	类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们(隐式地或显示地)指定模板实参，
将其绑定到模板参数上。我们的compare函数声明了一个名为T的类型参数。在compare中，我们用名字T表示一个
类型。而T表示的实际类型则在编译时根据compare的使用情况来确定。

实例化函数模板
	当我们调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参。即，当我们调用compare时，
编译器使用实参的类型来确定绑定到模板参数T的类型。例如，在下面的调用中:
		cout << compare(1,0)<<endl;	//T为int
编译器用推断出的模板参数来为我们实例化(instantiate)一个特定版本的函数。当编译器实例化一个模板时，它
使用实际模板实参代替对应的模板参数来创建出模板的一个新的"实例"。例如，给定下面的调用:
		//实例化出int compare(const int &,const int &)
		cout << compare(1,0)<<endl;	//T为int
		//实例化出int compare(const vector<int> &,const vector<int> &)
		vector<int> vec1(1,2,3),vec2(4,5,6);
		cout<<compare(vec1,vec2)<<endl;	//T为vector<int>
编译器会实例化出两个不同版本的compare。对于第一个调用，编译器会编写并编译一个compare版本，其中T被替
换为int:
		int compare(const int &v1,const int &v2){
			if(v1 < v2) return -1;
			if(v2 < v1) return 1;
			return 0;
		}
对于第二个调用，编译器会生成另一个compare版本，其中T被替换为vector<int>。这些编译器生的版本通常
称为模板的实例(instantiation)。

模板类型参数
	我们的compare函数有一个模板类型参数。一般来说，我们可以将类型参数看作类型说明符，就像内置类型
或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于声明
变量或类型转换:
		//正确:返回类型和参数类型相同
		template <typename T> T foo(T *p)
		{
			T tmp = *p;	//tmp的类型将是指针ip指向的类型
			//...
			return tmp;
		}
类型参数前必须使用关键字class或typename:
		//错误:U之前加上class或typename
		template <typename T,U> T calc(const T &,const U&);
在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字:
		//正确:在模板参数列表中，typename和class没有什么不同
		template <typename T,class U>calc(const T&,const U&);
看起来用关键字typename来指定模板类型参数比用class更为直观。毕竟，我们可以使用内置(非类)类型作为
模板类型实参。而且，typename更清楚地指出随后的名字是一个类型名。但是，typename是在模板已经广泛
使用之后才引入C++语言的，某些程序员仍然只使用class。

非类型模板参数
	除了定义类型参数，还可以在模板中定义非类型参数。一个非类型参数表示一个值而非一个类型。我们通过
一个特定的类型名而非关键字class或typename来指定非类型参数。
	当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所替代。这些值必须是常量表达
式，从而允许编译器在编译时实例化模板。
	例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const　char的数组。由于
不能拷贝一个数组，所以我们将自己的参数定义为数组的引用。由于我们希望能比较不同长度的字符串字面常量，
因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度:
		template<unsigned N,unsigned M> int compare(const char (&p1)[N],const char (&p2)[M]){
			return strcmp(p1,p2);
		}
当我们调用这个版本的compare时:
		compare("hi","mom");
编译器会使用字面常量的大小来代替N和M，从而实例化模板。记住，编译器会在一个字符串字面常量的末尾插入一
个空字符作为终结符，因此编译器会实例化出如下版本:
		int compare(const char (&p1)[3],const char (&p2)[4])
一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或(左值)引用。绑定到非类型整型参数
的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能使用一个
普通(非static)局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一
个值为0的常量表达式来实例化。
	在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使非类型参数，例如，指定数组的大小。
注意:
	非类型模板参数的模板实参必须是常量表达式。

inline和constexpr的函数模板
	函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在
模板参数列表之后，返回类型之前:
		//正确:inline说明符跟在模板参数列表之后
		template <typename T> inline T min(const T&,const T&);
		//错误:inline说明符的位置不正确
		inline template <typename T> T min(const T&,const T&);
编写类型无关的代码
	我们最初的compare函数虽然简单，但它说明了编写泛型代码的两个重要原则:
		>>>	模板中的函数参数是const的引用
		>>>	函数体中的条件判断仅使用<比较运算符
通过将函数参数设定为const的引用，我们保证了函数可以用于不能拷贝的类型。大多数类型，包括内置类型和我
们已经用过的标准库类型(除了unique_ptr和IO类型之外)，都是允许拷贝的。但是，不允许拷贝的类类型也是
存在的。通过将参数设定为const的引用，保证了这些类型可以用我们的compare函数来处理。而且，如果compare
用于处理大对象，这种设计策略还能使函数运行得更快。
	你可能认为既使用<运算符又使用>运算符来比较操作会更为自然:
		//期望的比较操作
		if(v1 < v2)return -1;
		if(v1 > v2)return 1;
		return 0;
但是，如果编写代码时只使用<运算符，我们就降低了compare函数对要处理的类型的要求。这些类型必须支持<，
但不必同时支持>!!!(这个思想厉害啊)。
	实际上，如果我们真的关系类型无关和可移植性，可能需要用less来定义我们的函数。
		//即使用于指针也是正确的compare版本
		template <typename T>int compare(const T &v1,const T &v2)
		{
			if (less<T>(v1,v2))return -1;
			if(less<T>(v2,v1))return 1;
			return 0;
		}
原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的(
根据查阅资料，less<T>的默认实现用的就是<，所以这其实并未起到让这种比较有一个良好定义的作用)
注意:
	模板程序应该尽量减少对实参类型的要求。

模板编译
	当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生
成代码。当我们使用(而不是定义)模板时，编译器才生成代码。这一特性影响了我们如何组织代码以及错误何时被检
测到。
	通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类
定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中。而普通函数和
类成员函数定义放在源文件中。
	与模板不同，为了生成一个实例化版本，编译器需要掌握函数或类模板成员函数的定义。因此，与非模板代码
不同，模板的头文件通常既包括声明也包括定义。
注意:
	函数模板和类模板成员函数的定义通常放在头文件中。

关键概念:模板和头文件
	模板包含两种名字:
		>>>	那些不依赖于模板参数的名字
		>>>	那些依赖于模板参数的名字
当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而且模板提供者必须
保证，当模板被实例化时，模板的定义、包括类模板的成员的定义，也必须是可见的。用来实例化模板的所有函数、
类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。
	通过组织良好的程序结构，恰当使用头文件。这些要求都很容易满足。模板的设计者应该提供一个头文件，
包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来
实例化模板的任何类型的头文件。

大多数编译错误在实例化期间报告
	模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译
器会在三个阶段报告错误。
	第一个阶段是在编译模板本身时，在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误。
例如忘记分号或变量名拼错等，但也就这么多了。
	第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编
译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供
了正确数目的模板实参，但也仅限于此。
	第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这
类错误可能在链接时才报告。
	当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设。例如，
我们最初的compare函数中的代码就假定了实参类型定义了<运算符。
		if(v1 < v2)return -1;	//要求类型T的对象支持<操作
		if(v2 < v1)return 1;	//要求类型T的对象支持<操作
		return 0;	//返回int;不依赖于T
当编译器处理此模板时，它不能验证if语句中的条件是否合法，如果传递给compare的实参定义了<运算符，则
代码就是正确的，否则就是错误的。例如:
		Sales_data data1,data2;
		cout << compare(data1,data2)<<endl;	///错误，Sales_data没有定义<
此调用实例化了compare的一个版本，将T替换为Sales_data。if条件试图对Sales_data对象使用<运算符，
但Sales_data并未定义此运算符。此实例化生成了一个无法编译通过的函数版本。但是，这样的错误直至编译器
在类型Sales_data上实例化compare时才会被发现。
注意:
	保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

16.1.2类模板
	类模板(class template)是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断
参数类型。如我们已经多次看到的，为了使用类模板，我们必须在模板名的尖括号中提供额外信息－－用来替代模
板参数的模板实参列表。

定义类模板
	作为一个例子，我们将实现StrBlob的模板版本。我们将此模板命名为Blob，意指它不再针对string。类
似StrBlob，我们的模板会提供对元素共享(且核查过得)访问能力。与类不同，我们的模板可以用于更多类型的
元素。与标准库容器相同，当使用Blob时，用户需要指出元素的类型。
	类似函数模板，类模板以关键字template开始，后跟模板参数列表，在类模板(及其成员)的定义中，我们
将模板参数当作替身，代替使用模板时用户需要提供的类型或值:
		template <typename T> class Blob{
		public:
			typedef T value_type;
			typedef typename std::vector<T>::size_type size_type;
			//构造函数
			Blob();
			Blob(std::initializer_list<T> il);
			//Blob中的元素数目
			size_type size()const {return data->size();}
			bool_empty() const {return data->empty();}
			//添加和删除元素
			void push_back(const T &t){data->push_back(t);}
			//移动版本，
			void push_back(T &&t){data->push_back(std::move(t));}
			void pop_back();
			//元素访问
			T &back();
			T &operator[](size_type i);
		private:
			std::shared_ptr<std::vector<T>>data;
			//若data[i]无效，则抛出msg
			void check(size_type i,const std::string &msg)const;
		};
我们的Blob模板有一个名为T的模板类型参数，用来表示Bloob保存的元素的类型。例如，我们将元素访问操作的返回
类型定义为&T。当用户实例化Blob时，T就会被替换为特定的模板实参类型。
	除了模板参数列表和使用T代替string之外，此类模板的定义与12.1节中定义的类模板及12.1.6和第13章、第
14章中更新的版本是一样的。

实例化类模板
	我们已经多次见到，当使用一个类模板时，我们必须提供额外的信息。我们现在知道这些额外的信息是显式模板
参数(explicit template argument)列表，它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的
类。
	例如，为了用我们的Blob模板定义一个类型，必须提供元素类型:
		Blob<int> ia;	//空Blob<int>
		Blob<int> ia2 = {0,1,2,3,4};	//有5个元素的Blob<int>
ia和ia2使用相同的特定类型版本的Blob(即Blob<int>)。从这两个定义，编译器会实例化出一个与下面定义等价
的类:
		template<> class Blob<int>{
			typedef typename std::vector<int>::size_type size_type;
			Blob();
			Blob(std::inintilizer_list<int> il);
			//....
			int &operator[](size_type i);
		private:
			std::shared_ptr<std::vector<int>> data;
			void check(size_type i,const std::string &msg)const;
		};
当编译器从我们的Blob模板实例化出一个类时，它会重写Blob模板，模板参数T的每个实例替换为给定的模板实
参，在本例中都是int。
	对我们指定的每一种元素类型，编译器都生成一个不同的类。
		//下面的定义实例化出两个不同的Blob类型
		Blob<string> names;	//保存string的Blob
		Blob<string> prices;//不同的元素类型
这两个定义会实例化出两个不同的类。names的定义创建一个Blob类，每个T都被替换为string。prices的
定义生成了另一个Blob类，T被替换为double。
注意:
	一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类都没有关联，
也不会对任何其他Blob类型的成员有特殊的访问权限。

在模板作用域中引用模板类型
	为了阅读模板类代码，应该记住类模板的名字不是一个类型名。类模板用来实例化类型，而一个实例化的类型总
是包含模板参数的。
	可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型(或值)的名字用作其
模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的data成员使用了两个模板，
vector和shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是
Blob的模板参数。因此，data的定义如下:
		shared_ptr<std::vector<T>> data;
它使用了Blob的类型参数来声明data是一个shared_ptr的实例。此shared_ptr指向一个保存类型为T的对象的
vector实例。当我们实例化一个特定类型的Blob，例如Blob<string>时，data会成为:
		shared_ptr<std::vector<string>>
如果我们实例化Blob<int>，则data会称为shared_ptr<vector>>，依次类推。

类模板的成员函数
	与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的
成员函数被隐式声明为内联函数。
	类模板的成员函数本身是一个普通函数，但是，类模板的每个实例都有自己版本的成员函数。因此，类模板的
成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字template开始，后接该
类模板参数列表。
	与往常一样，当我们在类外部定义一个成员时，必须说明成员属于哪个类。而且，从一个模板生成的类的名字
中必须包含其模板实参。当我们定义一个成员函数时，模板实参与模板形参相同。即，对于StrBlob的一个给定的成
员函数:
		ret-type StrBlob::member-name(parm-list)
对应的Blob的成员应该是这样的:
		template <typename T> ret-type Blob<T>::member-name(parm-list)

check和元素访问成员
	我们首先定义check成员，它检查一个给定的索引:
		template<typename T> void Blob<T>::check(size_type i,
						const std::string &msg)const
		{
			if(i >= data->size())
				throw std::out_of_range(msg):
		}
除了类名中的不同之处外以及使用了模板参数列表外，此函数与原StrBlob类的check成员完全一样。
	下标运算符和back函数用模板参数指出返回类型，其他未变:
		template <typename T> T &Blob<T>::back(){
			check(0,"back on empty Blob");
			return data->back();
		}
		template <typename T> T &Blob<T>::operator[](size_type i){
			//如果i太大，check会抛出异常，阻止访问一个不存在的元素
			check(i,"subscript out of range");
			return (*data)[i];
		}
在原版StrBlob类中，这些运算符返回string &，而模板则返回一个引用，指向用来实例化Blob的类型。
	pop_back函数与原StrBlob的成员几乎相同:
		template <typename T> void Blob<T>::pop_back()
		{
			check(0,"pop_back on empty Blob");
			data->pop_back();
		}
在原StrBlob类中，下标运算符和back成员都对const对象进行了重载。我们将这些成员及front成员的定义
留作练习。

Blob构造函数
	与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始:
		template <typename T> Blob<T>::Blob() 
					data(std::make_shared<std::vector<T>>()){}
这段代码在作用域Blob<T>中定义了名为Blob的成员函数，类似StrBlob的默认构造函数，此构造函数分配
一个空vector，并将指向vector的指针保存在data中。如前所述，我们将类模板自己的类型参数作为vector
的模板实参来分配vector。
	类似的，接受一个initializer_list参数的构造函数将其类型参数T作为initializer_list参数的
元素类型:
		template <typename T> Blob<T>::Blob(std::initializer_list<T> il)
							:data(std::make_shared<std::vector<T>>()){}
类似默认构造函数，此构造函数分配一个新的vector。在本例中，我们用参数il来初始化此vector。
	为了使用这个构造函数，我们必须传递给它一个initializer_list，其中的元素必须与Blob
的元素类型兼容:
		Blob<string> article = {"a","an","the"};
这条语句中，构造函数的参数类型为initializer_list<string>。列表中的每个字符串字面
常量隐式地转换为一个string。

类模板成员函数的实例化
	默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。例如，下面代码:
		//实例化Blob<int>和接受initializer_list<int>的构造函数
		Blob<int> square = {0,1,2,3,4,5};
		//实例化Blob<int>::size()const
		for(size_t i = 0;i != square.size(); ++i)
			square[i] = i*i;	//实例化Blob<int>::operator[](size_t)
实例化了Blob<int>类和它的三个成员函数:operator[]、size和接受initializer_list<int>的构造函数。
	如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一特性使得即
使某种类型不能完全符合模板操作的要求，我们仍然使用该类型实例化类。
注意:
	默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

在类代码内简化模板类名的使用
	当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可
以直接使用模板名而不提供实参:
		//若试图访问一个不存在的元素，BlobPtr则抛出一个异常
		template <typename T> class BlobPtr{
		public:
			BlobPtr() : curr(0){}
			BlobPtr(Blob<T> &a,size_t sz = 0):wptr(a.data),curr(sz){}
			T &operator*()const{
				auto p = check(curr,"dereference past end");
				return (*p)[curr];	//(*p)为本对象指向的vector
			}
			//递增和递减
			BlobPtr &operator++();//前置运算符
			BlobPtr &operator--();
		private:
			//若检查成功，check返回一个指向vector的shared_ptr;
			std::shared_ptr<std::vector<T>> check(std::size_t,const std::string &)const;
			std::size_t curr;	//数组中的当前位置
		};
细心的读者可能已经注意到，BlobPtr的前置递增和递减成员返回BlobPtr&,而不是BlobPtr<T>&。当我们
处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样，即，
就好像我们这样编写代码一样:
		BlobPtr<T> &operator++();
		BlobPtr<T> &operator--();

在类模板外使用类模板名
	当我们在类模板外定义其成员时，必须记住，我们并不在类的作用中，直到遇到类名才表示进入类的作用域:
		//后置:递增/递减对象但返回原值
		template <typename T> BlobPtr<T> BlobPt<T>::operator++(int){
			//此处无须检查:调用前置递增会进行检查
			BlobPtr ret = *this;//保存当前值
			++*this;
			return ret;
		}
由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的BlobPtr，它所用类型与类实例化所用
类型一致。在函数体内，我们已经进入类的作用域。因此在定义ret时无须重复模板实参。如果不提供模板实参，
则编译器将假定我们使用的类型与成员实例化所用类型一致。因此，ret的定义与如下代码等价:
		BlobPtr<T> ret = *this;
注意:
	在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

类模板和友元
	当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友
元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权
给特定实例。

一对一友好关系
	类模板与另一个(类或函数)模版间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，
我们的Blob类应该将BlobPtr类和一个模板本的Blob相等运算符(练习中的StrBlob定义的)定义为友元。为
了引用(类或函数)模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表:
		//前置声明，在Blob中声明友元所需要的
		template <typename> class BlobPtr;
		template <typename> class Blob;	//运算符==中的参数所需的
		template <typename T> bool operator==(const Blob<T>&,const Blob<T> &);
		template <typename T> class Blob{
			//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符
			friend class BlobPtr<T>;
			friend bool operator==<T>const(
				const Blob<T> &,const Blob<T> &);
			//其他成员定义，与12.1.1相同
		};
我们首先将Blob、BlobPtr和operator==声明为模板。这些声明是operator==函数的参数声明以及Blob中
的友元声明所需要的。
	友元的声明用Blob的模板形参作为他们自己的模板实参。因此，友好关系被限定在用相同类型实例化的Blob
与BlobPtr相等运算符之间:
		Blob<char>ca;		//BlobPtr<char>和operator==<char>都是本对象的友元
		Blob<int> ia;		//BlobPtr<int>和operatpr==<int>都是本对象的友元
BlobPtr<char>的成员可以访问ca(或任何其他Blob<char>对象)的非public部分，但ca对ia(或其他任何
Blob<int>对象)或Blob的任何其他实例都没有特殊访问权限。

通用和特定的模板友好关系
	一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元:
		//前置声明，在模板的一个特定实例声明为友元时要用到
		template <typename T>class Pal;
		class C{	//C是一个普通的非模板类
			friend class　Pal<C>;	//用类C实例化的Pal是C的一个友元
			//Pal2的所有实例都是C的友元，这种情况无须前置声明
			template <typename T> friend class Pal2;
		};
		template <typename T>class C2{//C2本身是一个类模板
			//C2的每个实例将相同实例化的Pal声明为友元
			friend class Pal<T>;	//Pal的模板声明必须在作用域之内
			//Pal2所有实例都是C2的每个实例的友元，不需要前置声明
			template <typename X> friend class Pal2;
			//Pal3是一个非模板类，它是C2所有实例的友元
			friend class Pal3;
		};
注意一点:
	如果一个类是所有实例的友元的话，那么就不需要前置声明
为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数！也就是让友元不能是一个特定模板
实参的友元。

令模板自己的类型参数成为友元
	在新标准中，我们可以将模板类型参数声明为友元:
		template <typename Type>class Bar{
		friend Type;	//将访问权限授予用来实例化Bar的类型
			//....
		};
此处我们将用来实例化Bar的类型声明为友元。因此，对于某个类型名Foo,Foo将成为Bar<Foo>的友元，Sales_data
将成为Bar<Sales_data>的友元，依次类推。
	值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一个内置类型来实例化Bar。
这种与内置类型的友好关系是允许的，以便我们能用内置类型来实例化Bar这样的类。

模板类型别名
	类模板的一个实例定义了一个类类型，与任何其他类型一样，我们可以定义一个typedef来引用实例化的类:
		typedef Blob<string> StrBlob;
这条typedef语句允许我们运行在12.1.1节中编写的代码，而使用的却是string实例化的模板版本的Blob。由
于模板不是一个类型，我们不能定义一个typedef引用一个模板。即，无法定义一个typedef引用Blob<T>。
	但是新标准允许我们为类模板定义一个类型别名:
		template<typename T> using twin = pair<T,T> ;
		twin<string> authors;	//authors是一个pair<string,string>
在这段代码中，我们将twin定义为成员类型相同的pair别名。这样，twin的用户只需要指定一次类型。
	一个模板类型别名是一族类的别名:
		twin<int> win_loss;	//win_loss是一个pair<int,int>
		twin<double> area;	//area是一个pair<double,double>
就像使用类模板一样，当我们使用twin时，需要指出希望使用过哪种特定类型的twin。当我们定义一个模板类型
别名时，可以固定一个或多个模板参数:
		template<typename T>using partNo = pair<T,unsigned>;
		partNo<string> books;	//books是一个pair<string,unsigned>
		partNo<Vehicle> cars;	//cars是一个pair<Vehicle,unsigned>
		partNo<student>kids;	//kids是一个pair<Student,unsigned>
这段代码中，我们将PartNo定义为一族类型的别名，这族类型是second成员为unsigned的pair。partNo的
用户需要指出pair的first成员的类型，但不能指定second成员的类型。

类模板的static成员
	与任何其他类相同，类模板可以声明static成员:
		template <typename T> class Foo{
		public:
			static std::size_t count(){return ctr;}
			//其他接口成员
		private:
			static std::size_t ctr;
			//其他实现成员
		};
在这段代码中，Foo是一个类模板，它有一个名为count的public　static成员函数和一个名为ctr的private
static ctr数据成员。每个Foo的实例都有自己的static成员实例。即，对任意给定的类型X，都有一个Foo<X>::ctr
和一个Foo<X>::count成员，所有Foo<X>类型的对象共享相同的ctr对象和count函数，例如:
		//实例化static成员Foo<string>::ctr和Foo<string>::count
		Foo<string> fs;
		//所有三个对象共享相同的Foo<int>::ctr和Foo<int>::count成员
		Foo<int> f1,f2,f3;
与任何其他static数据成员相同，模板类的每个static数据成员必须有且仅有一个定义，但是，类模板的每个
实例都有一个独有的static对象。因此，与定义模板的成员函数类似，我们将static数据成员也定义为模板:
		template<typename T> size_t Foo<T>::ctr = 0;	//定义并初始化ctr
与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员的类型和名字。与往常
一样，成员名包括成员的类名。对于从模板生成的类来说，类名包括模板实参。因此，当使用一个特定的模板实
参类型实例化Foo时，将会为该类型实例化一个独立的ctr，并将其初始化为0。
	与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的static成员，也可以使用作用
域运算符直接访问成员。当然，为了通过类来直接访问static成员，我们必须引用一个特定的实例:
		Foo<int> fi;
		auto ct = Foo<int>::count();	//实例化Foo<int>::count
		ct = fi.count();		//使用Foo<int>::count
		ct = Foo.count();		//错误:使用哪个模板实例的count?
类似任何其他成员函数，一个static成员函数只有在使用时才会实例化。
注意:
	这里回顾下类的静态成员。首先类的静态数据成员只能是在类内声明，然后在类外定义并初始化。初始化的时候
要使用类名::静态数据成员的名字来进行定义并初始化。类的静态成员函数，只能使用静态数据成员！！！然后就是，
类的非静态函数，可以访问静态成员。
	然后就是类的模板的静态数据成员，也必须得在类外部定义，然后定义的时候要写上template <typename T>
进行告知模板实参，然后就是数据成员的初始化类名<T>::静态数据成员进行初始化。

16.1.3	模板参数
	类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为T。但实际上我
们可以使用任何名字:
		template <typename Foo> Foo calc(const Foo &,const Foo &b){
			Foo tmp = a;	//tmp的类型与参数和返回类型一样
			//.....
			return tmp;	//返回类型和参数类型一样
		}

模板参数与作用域
	模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与
任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重
用模板参数名:
		typedef double A;
		template <typename A,typename B> void f(A a,B b)
		{
			A tmp = a;	//tmp的类型为模板参数A的类型，而非double
			double B;	//错误:重声明模板参数B
		}
正常的名字隐藏规则决定了A的typedef被类型参数A隐藏。因此，tmp不是一个double，其类型是使用了f时绑定
到类型参数A的类型。由于我们不能重用模板参数名，声明名字为B的变量是错的。
	由于参数名不能重用，所以一个模板实参名在一个特定的模板参数列表中只能出现一次:
		//错误:非法重用模板参数名V
		template <typename V,typename V>	//.....

模板声明
	模板声明必须包含模板参数:
		//声明但不定义compare和Blob
		template <typename T>int compare(const T&,const T&);
		template <typename T>class Blob;
与函数参数相同，声明中的模板参数的名字不必与定义中相同:
		//3个calc都指向相同的函数模板
		template <typename T> T calc(const T&,const T&);	//声明
		template <typename U> U calc(const U&,const U&);
		//模板的定义
		template <typename Type> Type calc(const Type &a,Type &b){/*....*/}
当然，一个给定模板的每个声明和定义必须有相同数量和种类(即，类型或非类型)的参数。

注意:
	一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前，
原因我们将在16.3节中解释。

使用类的类型成员
	回忆一下，我们用作用域运算符(::)来访问static成员。在普通(非模板)代码中，编译器掌握类的定义。因
此，它知道通过作用域运算符访问的名字是类型还是static成员。例如，如果我们写下string::size_type，编
译器有string的定义，从而知道size_type是一个类型。
	但对于模板代码就存在困难。例如，假定T是一个模板类型参数，当编译器遇到类似T::mem这样代码的时候，就
不会知道mem是一个类型成员还是一个static数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须
知道名字是否表示一个类型。例如，假定T是一个类型参数的名字，当编译器遇到如下形式的语句时:
		T::size_type *p;
它需要知道我们正在定义一个名为p的变量还是一个名为size_type的static数据成员与名为p的变量相乘。主要是因
为模板参数只有在实例化的时候才能发现具体的实现。
	默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数
的类型成员，就必须显示告诉编译器该名字是一个类型。我们通过关键字typename来实现这一点:
		template <typename T> typename T::value_type top(const T& c){
			if(!c.empty())
				return c.back();
			else
				return typename T::value_type();
		}
我们的top函数期待一个容器类型的实参，它使用typename指明其返回类型并在c中没有元素的时候生成一个值初始化
的元素返回给给给调用者。
注意:
	当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。

默认模板实参
	就像我们能为函数提供默认实参一样，我们也可以提供默认模板实参。在新标准中，我们可以为函数和类模板
提供默认实参。而更早的C++标准只允许为类模板提供默认实参。
	例如，我们重写compare，默认使用标准库less函数对象模板:
		//compare有一个默认模板实参less<T>和一个默认实参F()
		template <typename T,typename F = less<T>> 
		int compare(const T &v1,const T &v2,F f=F()){
			if(f(v1,v2))return -1;
			if(f(v2,v1))return 1;
			return 0;
		}
在这段代码中，我们为模板添加了第二个类型参数，名为F，表示可调用对象的类型；并定义了一个新的函数参数f，
绑定到一个可调用对象上。
	我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默认实参。默认模板实参指出compare将
使用标准库的less函数对象类，它是使用与compare一样的类型参数实例化的。默认函数实参指出f将是类型F的
一个默认初始化的对象。
	当用户调用这个版本的compare时，可以提供自己的比较操作，但这并不是必需的:
		bool i = compare(0,42);	//使用less
		//结果依赖于item1和item2中的isbn
		Sales_data item1(cin),item2(cin);
		bool j = compare(item1,item2,compareIsbn);
第一个调用使用默认实参，即，类型less<T>
的一个默认初始化的对象。在此调用中，T为int，因此可调用对象的类型为less<int>。compare的这个实例化版
本将使用less<int>进行比较操作。
	在第二个调用中，我们传递给compare三个参:compareIsbn，和两个Sales_data类型的对象。当传递给compare
三个实参时，第三个实参的类型必须是一个可调用对象，该可调用对象的返回类型必须能转换为bool值，且接受的实
参类型必须与compare的前两个实参的类型兼容。与往常一样，模板参数的类型从它们对应的函数实参推断而来。在此
调用中，T的类型被推断为Sales_data，F被推断为compareIsbn的类型。
	与默认函数实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

模板默认实参与类模板
	无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。
特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后
跟一个空尖括号对:
		template <class T = int> class Numbers{//T默认为int
		public:
			Numbers(T v=0):value(v){}
			//对数值的各种操作
		private:
			T val;
		};
		Numbers<long double>lots_of_precision;
		Numbers<> average_precision;	//空<>表示我们希望使用默认类型
此例中我们实例化了两个Numbers版本:average_precision是用int代替T实例化得到的:lots_of_precision
是用long double代替T实例化得到的。

16.1.4成员模板
	一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是
虚函数。

普通(非模板)类的成员模板
	作为普通类包含成员模板的例子，我们定义一个类，类似unique_ptr所使用默认删除器类型。类似默认
删除器，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行delete。与默认删除器不同。我
们的类还将在删除器被执行时打印一条信息。由于希望删除器适用于任何类型，所以我们将调用运算符定义一个模板:
		//函数对象类，对给定指针执行delete
		class DebugDelete{
		public:
			DebugDelete(std::ostream &s = std::cerr):os(s){}
			//与任何函数模板相同，T的类型由编译器推断
			template <typename T> void operator()(T *p)const{
				os<<"deleting unique_ptr"<<std::endl; 
				delete p;
			}
		private:
			std::ostream &os;
		};
与任何其他模板相同，成员模板也是以模板参数列表开始的。每个DebugDelete对象都有一个ostream成员，用于
写入数据；还包含一个自身是模板的成员函数。我们可以用这个类代替delete:
		double *p = new double;
		DebugDelete d;	//可像delete表达式一样使用的对象
		d(p);	//调用DebugDelete::operator()(double *),释放p
		int *p = new int;
		//在一个临时DebugDelete对象上调用operator()(int *)
		DebugDelete()(ip);
由于调用一个DebugDelete对象会delete其给定的指针，我们也可以将DebugDelete用作unique_ptr的删除器。
为了重载unique_ptr的删除器，我们在尖括号内给出删除器类型，并提供一个这种类型的对象给unique_ptr的构造
函数:
		//销毁p指向的对象
		//实例化DebugDelete::operator()<int>(int *)
		unique_ptr<int,DebugDelete> p(new int,DebugDelete());
		//销毁sp指向的对象
		//实例化DebugDelete::operator()<string>(string *)
		unique_ptr<string,DebugDelete>sp(new string,DebugDelete());
在本例中，我们声明p的删除器的类型为DebugDelete，并在p的构造函数中提供了该类型的一个命名对象。
	unique_ptr的析构函数会调用DebugDelete的调用运算符。因此，无论何时unique_ptr的析构函数实例化时，
DebugDelete的调用运算符都会实例化：因此上述定义会这样实例化:
		//DebugDelete的成员模板实例样例
		void DebugDelete::operator()(int *p)const{
			delete p;
		}
		void DebugDelete::operator()(string *p)const {
			delete p;
		}

类模板的成员模板
	对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各有自己的、独立的模板参数。例如，我们将
为Blob定义一个构造函数，它接受两个迭代器，表示要拷贝的元素范围。由于我们希望支持不同类型序列的迭代器，因
此将构造函数定义为模板:
		typename <typename T> class Blob{
			template <typename It>Blob(It b,It e);
			//.....
		}
此构造函数有自己的模板类型参数It，作为它的两个函数参数类型。与类模板的普通函数成员不同，成员模板是函数
模板。当我们在类模板外定义一个成员模板时候，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表
在前，后跟成员自己的模板参数列表:
		template <typename T> //类的类型参数
		template <typename It> 
		Blob<T>::Blob(It b,It e):data(std::make_shared<std::vector<T>>(b,e)){}
在此例中，我们定义了一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常一样，我们在哪个对象
上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参:
		int ia[] = {0,1,2,3,4,5,6,7,8,9};
		vector<long> v1 = {0,1,2,3,4,5};
		list<const char *>w = {"now","is","the","time"};
		//实例化Blob<int>类及其接受两个int *参数的构造函数
		Blob<int> a(begin(ia),end(ia));
		//实例化Blob<int>类的接受两个vector<long>::iterato的构造函数
		Blob<int> a2(v1.begin(),v1.end());
		//实例化Blob<string>及其接受两个list<const char *>::iterator参数的构造函数
		Blob<string> a3(w.begin(),w.end());
当我们定义a1时，显示地指出编译器应该实例化一个int版本的Blob。构造函数自己的类型参数则通过begin(ia)
和end(ia)的类型来推断，结果为int *。因此，a1的定义实例化了如下版本:
		Blob<int>::Blob(int *,int *);
a2的定义使用了已经实例化了的Blob<int>类，并用vector<short>::iterator替换It来实例化
构造函数，a3的定义(显示地)实例化了一个string版本的Blob并(隐式地)实例化了该类的成员模板构造函数，其
模板参数被绑定到list<const char *>

16.1.5控制实例化
	当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立
编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。
	在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显示实例化
来避免这种开销。一个显示实例化有如下形式:
		extern template declaration;	//实例化声明
		template declaration;		//实例化定义
declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如:
		//实例化声明与定义
		extern template class Blob<string>;//声明
		template int compare(const int &,const int&);	//定义
当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在
程序其他位置有该实例化的一个非extern声明(定义)，对于一个给定的实例化版本，可能有多个extern声明，但必
须只有一个定义。
	由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用此实例化版本的代码之前；
要不然就会出现被实例化了。
		//Application.cc
		//这些模板类型必须在程序其他位置进行实例化
		extern template class Blob<string>;
		extern template int compare(const int &,const int&);
		Blob<string>sa1,sa2;	//实例化会出现在其他位置
		//Blob<int>及其接受intitializer_list的构造函数在本文件中实例化
		Blob<int> a1 = {0,1,2,3,4,5,6};
		Blob<int> a2(a1);
		int i = compare(a1[0],a2[0]);
文件Application.o将包含Blob<int>的实例及其接受initializer_list参数的构造函数和拷贝构造
函数的实例。而compare<int>函数和Blob<string>类将不在本文件中进行实例化。这些模板的定义必须出现在
程序的其他文件中:
		//templateBuild.cc
		//实例化文件必须为每个在其他文件中声明为extern的类型和函数提供一个(非extern)的定义
		template int compare(const int &,const int &);
		template class Blob<string>;
当编译器遇到一个实例化定义时，它为其生成代码。因此，文件templateBuild.o将会包含compare的int
实例化版本的定义和Blob<string>类的定义。当我们编译此应用程序时，必须将templateBuild.o和Appliaction.o
链接到一起。

注意:
	对每个实例化声明，在程序中某个位置必须有其显示的实例化定义

实例化定义会实例化所有成员:
	一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，
它不了解程序使用哪些成员函数。因此，与处理类模板的普通化。因此，我们用来显示实例化一个类模板的类型，必
须能用于模板的所有成员。
注意:
	在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

16.1.6　效率与灵活性
	对模板设计者所面对的设计选择，标准库智能指针类型给出了一个很好的展示。
	shared_ptr和unique_ptr之间的明显不同是它们管理所保存的指针的策略---前者给予我们共享指针所有
权的能力；后者则独占指针。这一差异对两个类的功能来说是至关重要的。
	这两个类的另一差异是它们允许用户重载默认删除器的方式。我们可以很容易地重载一个shared_ptr的删除
器，只要在创建或reset指针时传递给他一个可调用对象即可。与之相反，删除器的类型是一个unique_ptr对象的
类型一部分。用户必须在定义unique_ptr时以显示模板实参的形式提供删除器的类型。因此，对于unique_ptr的
用户来说，提供自己的删除器更为复杂。
	如何处理删除器的差异实际上就是这两个类功能的差异。但是，如我们将要看到的，这一实现策略上的差异可
能对性能有重要影响。

在运行时绑定删除器
	虽然我们不知道标准库类型是如何实现的，但是可以推断出，shared_ptr必须能直接访问其删除器。即，
删除器必须保存为一个指针或一个封装了指针的类(如function)。
	我们可以确定shared_ptr不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道。实
际上，在一个shared_ptr的生存期中，我们可以随时改变其删除器的类型。我们可以使用一种类型的删除器构造
一个shared_ptr，随后使用reset赋予此shared_ptr另一种类型的删除器。通常，类成员的类型在运行时是
不能改变的。因此，不能直接保存删除器。
	为了考察删除器是如何正确工作的，让我们假定shared_ptr将它管理的指针保存在一个成员p中，且删除
器是通过一个名为del的成员来访问的。则shared_ptr的析构函数必须包含类似下面这样的语句:
		//del的值只有在运行时才知道：通过一个指针来调用它
		del ? del(p) : delete p;	//del(p)需要运行时跳转到del的地址
由于删除器是间接保存的，调用del(p)需要一次运行时的跳转操作，转到del中保存的地址来执行对应的代码。

在类编译时绑定删除器
	现在，让我们来考察unique_ptr可能的工作方式，在这个类中，删除器的类型是类类型的一部分。即，
unique_ptr有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型。由于删除器的类型是unique_ptr
类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在unique_ptr对象中。
	unique_ptr的析构函数与shared_ptr的析构函数类似，也是对其保存的指针调用用户提供的删除器或执
行delete:
		//del　在编译时绑定：直接调用实例化的删除器
		del(p);	//无运行时额外开销
del的类型或者是默认删除器类型，或者是用户提供的类型。到底是哪种情况并没有关系，应该执行的代码在编译
时肯定会知道。实际上，如果删除器是类似DebugDelete之类的东西，这个调用甚至可能被编译为内联形式。
通过在编译时绑定到删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，
shared_ptr使用户重载删除器更为方便。

16.2	模板实参推断
	我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从函数实参来确定模板
实参的过程被称为模板实参推断。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，
用这些模板实参生成的函数版本与给定的函数调用最为匹配。

16.2.1	类型转换与模板类型参数
	与非模板函数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形参。如果一个函数形
参类型使用了模板类型参数，那么它采用特殊的初始化规则。只有很有限的几种类型转换会自动地应用于这些实
参。编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。
	与往常一样，顶层const无论是在形参中还是实参中，都会被忽略。在其他类型转换中，能在调用中应用
于函数模板的包括如下两项。
		>>>	const转换:可以将一个非const对象的引用(指针)传递给一个const的引用(或指针)形参
		>>>	数组或函数指针转换:如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的
指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数
类型的指针。
其他类型转换，如算术转换，派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。！！
	作为一个例子，考虑对函数fobj和fref的调用。fobj函数拷贝它的参数，而fref的参数是引用类型:
		template <typename T> T fobj(T,T);	//实参被拷贝
		template <typename T> T fref(const T&,const T&);	//引用
		string s1("a value");
		const string s2("another value");
		fobj(s1,s2);	//调用fobj(string,string);const被忽略
		fref(s1,s2);	//调用fref(const string &,const string &)，将s1转换为const是允许的
		int a[10],b[42];
		fobj(a,b);	//调用f(int *,int *);
		fref(a,b);	//错误，数组类型不匹配
在第一对调用中，我们传递了一个string和const string。虽然这些类型不严格匹配。但两个调用都是合法的。
在fobj调用中，实参被拷贝，因此原对象是否是const没有关系。在fref调用中，参数类型是const的引用。对
于一个引用参数来说，转换为const是允许的，因此这个调用也是合法的。
	在下一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在fobj调用中，数组大小不
同无关紧要。两个数组都被转换为指针。fobj中的模板类型为int *。但是ftef调用不是合法的。如果形参是
一个引用，则数组不会转换为指针。a和b的类型是不匹配的，因此调用是错误的。
注意:
	将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换！！！

使用相同模板参数类型的函数形参
	一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换。因此传递给这些形参的实
参必须具有相同的类型。如果推断出类型不匹配，则调用就是错误的。例如，我们的compare函数接受两个const T&
参数，其实参必须是相同类型:
		long lng;
		compare(lng,1024);//错误:不能实例化compare(long,int);
此调用是错误的，因为传递给compare的实参类型不同。从第一个函数实参推断出的模板实参为long，从第二个函数
实参推断出的模板实参为int。这些类型不匹配，因此模板实参推断失败。
	如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数:
		//实参类型可以不同，但必须兼容
		template <typename A,typename B> int flexibleCompare(const A &v1,const B &v2){
			if(v1 < v2) return -1;
			if(v2 < v1) return 1;
			return 0;
		}
现在用户可以提供不同类型的实参了:
		long lng;
		flexibleCompare(lng,1024);	//正确:调用flexibleCompare(long,int)
当然，必须定义了能比较这些类型的值的<运算符

正常类型转换应用于普通函数实参
	函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理:它
们正常转换为对应形参的类型。例如，考虑下面的模板:
		template <typename T> ostream &print(ostream &os,const T &obj){
			return os<<obj;
		}
第一个函数参数是一个已知类型ostream &。第二个参数obj则是模板参数类型。由于os的类型是固定的，因此
调用print时，传递给它的实参会进行正常的类型转换:
		print(cout,42);		//实例化print(ostream&,int)
		ofstream f("output");
		print(f,10);	//使用print(ostream&,int);将if转换为ostream &
在第一个调用中，第一个实参类型严格匹配第一个参数的类型。此调用会实例化接受一个ostream&和一个int的
print版本，在第二个调用中，第一个实参是一个ofstream，它可以转换为ofstream&。由于此参数的类型不
依赖于模板参数，因此编译器会将f隐式转换为ostream&。
注意:
	如果函数参数类型不是模板参数，则对实参进行正常的类型转换。

16.2.2函数模板显示实参
	在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。当
函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。

指定显示模板实参
	作为一个允许用户指定使用类型的例子，我们将定义一个名为sum的函数模板，它接受两个不同类型的参数。我
们希望允许用户指定结果的类型。这样，用户就可以选择合适的精度。我们可以定义表示返回类型的第三个模板参数，
从而允许用户控制返回类型:
		//编译器无法推断T1。它未出现在参数列表中
		template <typename T1,typename T2,typename T3> T1 sum(T2,T3);
在本例中，没有任何函数实参的类型可用来推断T1的类型。每次调用sum时调用者都必须为T1提供一个显示模板
实参。
	我们提供给显示模板实参的方式与定义模板实例的方式相同。显示模板实参在尖括号中给出，位于函数名之后，
实参列表之前:
		//T1是显示指定的，T2和T3是从函数实参类型推断而来的
		auto val3 = sum<long long>(i,lng);//long long sum(int,long)
此调用显示指定T1的类型。而T2和T3的类型则由编译器从i和lng的类型推断出来。
	显示模板实参按由左至右的顺序与对应的模板参数匹配；第一个模板实参与第一个模板参数匹配，第二个实参
与第二个参数匹配，以此类推。只有尾部参数是显示模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。
如果我们的sum函数按照如下形式编写:
		//糟糕的设计:用户必须指定所有三个模板参数
		template <typename T1,typename T2,typename T3> T3 alternative_sum(T2,T1);
则我们总是必须为所有三个形参指定实参:
		//错误:不能推断前几个模板参数
		auto val3 = alternative_sum<long long>(i,lng);
		//正确:显示指定了所有三个参数
		auto val2 = alternative_sum<long long,int,long>(i,lng);
注意:
	这里的显示列表中的类型对应的是你的模板类型参数。也就是显示列表中的第一个类型对应的是T1，第二个
类型对应的是T2，依次类推。

正常类型转换应用于显示指定的实参
	对于用普通类型定义的函数参数，允许进行正常的类型转换，出于同样的原因，对于模板类型参数已经显示
指定了函数实参，也进行正常的类型转换:
		long lng;
		compare(lng,1024);	//错误：模板参数不匹配
		compare<long>(lng,1024);	//正确:实例化compare(long,long)
		compare<int>(lng,1024);	//正确，实例化compare(int,int)
如我们所见，第一个调用是错误的，因为传递给compare的实参必须具有相同的类型。如果我们显示指定模板类型
参数，就可以进行正常类型转换了。因此，调用compare<long>等价于调用一个接受两个const long&参数的
函数。int类型的参数被自动转化为long。在第三个调用中，T被显示指定为int，因此lng被转换为int。
也就是说，如果没有显示指定类型的话，那么调用的两个实参的类型必须一致。但是如果你显示指定了的话，那么
实参可以根据形参进行相应的转换。！！如果没有显示指定的话，那么只有const，指针或函数才可以进行转换。

16.2.3尾置返回类型与类型转换
	当我们希望用户确定返回类型时，用显示模板函数的返回类型是很有效的。但是在其他情况下，要求显示指
定模板实参会给用户添加额外负担，而且不会带来什么好处。例如，我们可能希望编写一个函数，接受表示序列的
一对迭代器和返回序列中一个元素的引用:
		template <typename It> ??? &fcn(It beg,It end){
			//处理序列
			return *beg;//返回序列中一个元素的引用
		}
我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型:
		vector<int> vi = {1,2,3,4,5};
		Blob<string> ca = {"hi","bye"};
		auto &i = fcn(vi.begin(),vi.end());	//fcn应该返回int &
		auto &s = fcn(ca.begin(),ca.end());	//fcn应该返回string &
此例中，我们知道函数应该返回*beg，而且知道我们可以用decltype(*beg)来获取此表达式的类型。
但是在编译器遇到函数的参数列表之前，beg是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于
尾置返回出现在参数列表之后，它可以使用函数的参数:
		//尾置返回允许我们在参数列表之后声明返回类型
		template <typename It> auto fcn(It beg,It end) -> decltype(*beg)
		{
			//处理序列
			return *beg;//返回序列中一个元素的引用
		}
此例中我们通知编译器fcn的返回类型与解引用beg参数的结果类型相同。解引用运算符返回一个左值，因此通过
decltype推断的类型为beg表示的元素的类型的引用。因此，如果对一个string序列调用fcn，返回类型将是
string &。如果是int序列，则返回类型是int &。

进行类型转换的标准库模板类
	有时我们无法直接获得所需要的类型，例如，我们可能希望编写一个类似fcn的函数，但返回一个元素的值
而非引用。
	在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一无所知。在此函数中，
我们知道唯一可以使用的操作是迭代器操作，而所有迭代器都不会生成元素，只能生成元素的引用。
	为了获得元素类型，我们可以使用标准库的类型转换模板。这些模板定义在头文件type_traits中。这个
头文件中的类通常用于所谓的模板元程序设计，这一主题已超出本书的范围。但是，类型转换模板在普通编程中也
很有用。表16.1列出了这些模板，我们将在16.5节中看到它们是如何实现的。
	在本例中，我们可以使用remove_reference来获得元素类型。remove_reference模板有一个模板
类型参数和一个名为type的(public)类型成员。如果我们用一个引用类型实例化remove_reference，则
type将表示被引用的类型。例如，如果我们实例化remove_reference<int &>，则type成员将是int。
类似的，如果我们实例化remove_reference<string &>，则type成员将是string，以此类推。更一般的，
给定一个迭代器beg:
		remove_reference<decltype(*beg)>::type
将获得beg引用的元素的类型;decltype(*beg)返回元素类型的引用类型。remove_reference::type脱去
引用，剩下元素类型本身。
	组合使用remove_reference、尾置返回及decltype，我们就可以在函数中返回元素值的拷贝:
		//为了使用模板参数的成员，必须使用过typename
		template <typename It> auto fcn2 (It beg,It end)
				->typename remove_reference<decltype(*beg)>::type
		{
			//处理序列
			return *beg;//返回序列中一个元素的拷贝
		}
注意，type是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用typename来
告知编译器，type表示一个类型:
							表16.1:标准类型转换模板
				对Mod<T>,其中Mod为		若T为		则Mod<T>::type为
				remove_reference		X&或X&&			X
										　否则			T
				add_const			X&,const X或函数		T
										　否则		  const T
										  X&			T
				add_lvalue_reference	  X&&			X&
										  否则			T&
				add_rvalue_reference	  X&或X&&		T
										  否则			T&&
				remove_pointer			  X*			X
										  否则			T
				add_pointer				  X&或X&&		X*
										　 否则			T*
				make_signed			   unsigned X		X
										  否则			T
				make_unsigned			带符号类型	unsigned X
										  否则			T
				remove_extent			  X[n]			X
										  否则			T
				remove_all_extents		X[n1][n2]...	X
										  否则			T
表16.1中描述的每个类型转换模板的工作方式都与remove_reference类似。每个模板都有一个名为
type的public成员，表示一个类型。此类型与模板自身的模板类型参数相关，其关系如模板名所示。
如果不可能(或者不必要)转换模板参数，则type成员就是模板参数类型本身。例如，如果T是一个
指针类型，则remove_pointer<T>::type是T指向的类型。如果T不是一个指针，则无须进行
任何转换，从而type具有与T相同的类型。
注意:
	cv是指const 和volatile
    在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定
    在声明为引用或者指针时，auto会保留等号右边的引用和cv属性
还有就是decltype(*beg+0)的时候，如果是vector<int>的话，那么返回类型是int，如果是double等内置
表示数字的话也是相应的类型，但是string的话，就不是string类型的了，它还是int类型的，因为是+0了。

16.2.4	函数指针和实参推断
	当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。
	例如，假定我们有一个函数指针，它指向的函数返回int，接受两个参数，每个参数都是指向const int的引
用，我们可以使用该指针指向compare的一个实例:
		template <typename T>int compare(const T&,const T&);
		//pf1指向实例int compare(const int &,const int&);
		int (*pf1)(const int&,const int&)=compare;
pf1中参数的类型决定了T的模板实参的类型。在本例中，T的模板实参类型为int。指针pf1指向compare的int
版本实例。如果不能从函数指针类型确定模板实参，则产生错误:
		//func的重载版本:每个版本接受一个不同的函数指针类型
		void func(int(*)(const string&,const string &));
		void func(int(*)(const string &,const string &));
		func(compare);	//错误:使用compare的哪个实例?
这段代码的问题在于，通过func的参数类型无法确定模板实参的唯一类型。对func的调用既可以实例化接受int的
compare版本，也可以实例化接受string的版本。由于不能确定func的实参的唯一实例化版本，此调用将编译
失败:
		//正确:显示指出实例化哪个compare版本
		func(compare<int>);	//传递compare(const int &,const int &);
此表达式调用的func版本接受一个函数指针，该指针指向的函数接受来两个const int&参数。
注意:
	当参数是一个函数模板实例的地址时，程序上下文必须满足:对每个模板参数，能唯一确定其类型或值。

16.2.5	模板实参推断和引用
	为了理解如何从函数调用进行类型推断，考虑下面的例子:
		template <typename T> void f(T &p);
其中函数参数p是一个模板类型参数T的引用，非常重要的是记住两点:编译器应会应用正常的引用绑定规则:
const是底层的，不是顶层的。

从左值引用函数参数推断类型
	当一个函数参数是模板类型参数的一个普通(左值)引用时(即，形如T&)，绑定规则告诉我们，只能传递
给它一个左值(如，一个变量或一个返回引用类型的表达式)。实参可以是const类型，也可以不是。如果实参
是const的，则T将被推断为const类型:
		template<typename T> void f1(T &);	//实参必须是一个左值
		//对f1的调用使用实参所引用的类型作为模板参数类型
		f1(i);	//i是一个int；模板参数类型T是int
		f1(ci);	//ci是一个const int;模板参数类型是const int
		f1(5);	//错误:传递给一个&参数的实参必须是一个左值
如果一个函数参数的类型是const T&,正常的绑定规则告诉我们可以传递给他让任何类型的实参---一个对象(
const或非const)、一个临时对象或是一个字面常量值。当函数参数本身是const时，T的类型推断的结果不
会是一个const类型。const已经是函数参数类型的一部分:因此，它不会也是模板参数类型的一部分。
		template <typename T>void f2(const T&);	//可以接受一个右值
		//f2中的参数是const &;实参中的const是无关的
		//在每个调用中，f2的函数参数都被推断为const int &
		f2(i);	//i是一个int,模板参数T是int
		f2(ci);	//ci是一个const int,但模板参数T为int
		f2(5);	//一个const &参数可以绑定到一个右值；T是int

从右值引用函数参数推断类型
	当一个函数参数是一个右值引用(即，形如T&&)时，正常绑定规则告诉我们可以传递给它一个右值。当我们
这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的T是类型是该右值实参的类型:
		template <typename T>void f3(T &&);
		f3(42);	//实参是一个int类的右值；模板参数T是int

引用折叠和右值引用参数
	假定i是一个int对象，我们可能认为像f3(i)这样的调用是不合法的。毕竟,i是一个左值，而通常我们不
能将一个右值引用绑定到一个左值上。但是C++语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。
这两个例外规则是move这种标准库设施正确工作的基础。
	第一个例外规则影响右值引用参数的推断如何进行。当我们将一个左值(如i)传递给函数的右值引用参数，
且此右值引用指向模板类型参数(如T &&)时，编译器推断模板类型参数为实参的左值引用类型。因此，当我们
调用f3(i)时，编译器推断T的类型为int &，而非int。T被推断为int &看起来好像意味着f3的函数参数应
该是一个类型int &的右值引用。通常，我们不能(直接)定义一个引用的引用。但是通过类型别名或通过模板
类型参数间接定义是可以的。
	在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个引用，则这些引用形成了"折叠"。
在所有情况下(除了一个例外)，引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则则扩展到右值引
用。只有一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定的类型X:
		X& &, X& &&和X&&　&都折叠成类型X&
		类型X&& &&折叠成X&&
注意:
	引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。
如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以对一个左值调用f3。当我们
将一个左值传递给f3的(右值引用)函数参数时，编译器推断T为一个左值引用类型:
		f3(i);	//实参是一个左值；模板参数T是int &
		f3(ci);	//实参是一个左值；模板参数T是一个const int &
当一个模板参数T被推断为引用类型时，折叠规则告诉我们函数参数T &&折叠为一个左值引用类型。例如，f3(i)
的实例化结果可能像下面这样:
		//无效代码，只是用来演示目的
		void f3<int &>(int & &&);//当T是int &是，函数参数为int & &&
f3的函数参数是T &&且T是int &，因此T &&是int & &&，会折叠成int &。因此，即使f3的函数参数形式
是一个右值引用(即，T &&)，此调用也会用一个左值引用类型(即，int &)实例化f3:
		void f3<int &>(int &);	//当T是int &时，函数参数折叠为int &
这两个规则导致了两个重要结果:
		如果一个函数参数是一个指向模板类型参数的右值引用(如,T&&)，则它可以被绑定到一个左值；且
如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个(普通)左值引用
参数(T &)
另外值得注意的是，这两个规则暗示，我们可以将任意类型的实参传递给T &&类型的函数参数。对于这种类型的参
数，显示可以传递给它右值，而如我们刚刚看到的，也可以传递给它左值。
注意:
		如果一个函数参数是指向模板参数类型的右值引用(如,T&&)，则可以传递给它任意类型的实参。
如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(T&)。

编写接受右值引用参数的模板函数
	模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响:
		template <typename T> void f3(T && val)
		{
			T t = val; //拷贝还是绑定一个引用
			t = fcn(t);	//赋值只改变t还是既改变t又改变val?
			if(val == t){/*.......*/}//若T是引用类型，则一直为true
		}
当我们对一个右值调用f3时，例如字面常量42，T为int。在此情况下，局部变量t的类型为int，且通过拷贝参数
val的值被初始化。当我们对t赋值时，参数val保持不变。
