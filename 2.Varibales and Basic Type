							第二章	变量和基本类型
内容
-----------------------------------------
	2.1	基本内置类型
	2.2	变量
	2.3	复合类型
	2.4	const限定符
	2.5	处理类型
	2.6	自定义数据结构
2.1	基本内置类型
					{算术类型：字符、整型数、布尔值和浮点数
				----{  
					{空类型：不对应具体的值
					
	C++定义了一套 算术类型 和 空类型 在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。

2.1.1	算术类型{整形，和浮点型）
	算术类型分为两类：整型和浮点类型。
	算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。表2.1列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。
			表2.1:	C++:算术类型
		类型					含义					最小尺寸
		bool				布尔类型				未定义
		char				字符					8位
		wchar_t				宽字符				16位
		char16_t			Unicode字符			16位
		char32_t			Unicode字符			32位
		short				短整型				16位
		int					整型					16位
		long				长整型				32位
		long long			长整型				64位
		float				单精度浮点型			32位，6位有效数字
		double				双精度浮点型			64位，10位有效数字
		long double			扩展精度浮点数			96/128位，10位有效数字
		
C++提供了几种字符类型，其中多数支持国际化。基本的字符类型是char，一个char的空间应确保可以存放机器的基本字符集中任意字符对应的数字值。也就说，一个char的大小和      一个机器字节一样。
	其他的字符类型用于扩展字符集，如wchar_t,char16_t,char32_t。wchar_t类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型char16_t和char32_t则位Unicode字符集服务(Unicode是用于表示所有自然语言中字符的标准）。
	C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。

内置类型的机器实现
	大多数计算机以2的整数次幂个比特作为块处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元是称为“字（word）”。大多数机器的字节由8比特组成，字则由32比特或64比特组成，也就是4个字节或者8个字节。

带符号类型和无符号类型
	除去布尔型和扩展的字符类型之外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）两种，带符号类型表示正数、负数或0，无符号类型则表示仅能表示大于等于0的值。
	类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型。
	与其他类型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signed  char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪一种由编译器决定（所以要是想确定的使用相应的类型的char，就带上相应的unsigned或signed吧，毕竟char是由编译器决定的）。
	
建议：如何选择类型
	>>>>当明确知晓数值不可能为负数的时候，选择unsigned
	>>>>使用int执行整数运算。在实际应用中，short常常显得太小，而long 一般和 int有一样的尺寸。如果你的数值超过了int的表示范围，选用long long。
	>>>>在算术表达式中不要使用char或bool，只有在存放字符或布尔值式才使用他们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是signed char或者unsigned  char。
	>>>>执行浮点数运算选用double，因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。
	
2.1.2	类型转换
	>>>>当我们赋值给一个无符号类型一个超出它的表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的unsigned char可以表示0---255区间的值，如果我们赋了一个区间意外的值，则实际结果是对256取模以后所得的余数。因次，把-1赋给8比特的unsigned char所得结果是255。
	>>>>当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的！！！！！
	
含有无符号类型的表达式
	当一个算术表达式中既有无符号数又有int值时，那个int值就会变成无符号数，把int转换成无符号数的过程和把int直接赋给无符号变量一样（求模取余）。也就是说：当进行算术运算的时候，都会转换成相同类型的数进行计算，而是是低阶类型，这里的无符号比有符号低阶，所以是转换成无符号的！！！！！
切记：
	不要混用带符号类型和无符号类型，因为这样的话，会导致有符号类型转换成无符号类型。当有符号出现负数的时候，就会出现错误！！
	
2.1.3	字面值常量（何为常量，其实就是与变量相对应的，常量是不可以改变数值）
	一个形如42的值被称为字面值常量(literal)，这样的值一望而知。
整型和浮点字面值
	整型字面值 具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面既可能是带符号的，也可能是不带符号的。十进制字面值的类型是int,long和long long中尺寸最小的那个（当然前提是这种类型要能容纳下当前的值）。尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数的。如果我们使用了一个形如-42的负十进制字面值，那个符号并不在字面值之内，它的作用仅仅是对字面值取负值而已。
	默认的浮点字面值是double类型。

字符和字符串字面值
	由单引号括起来的一个字符称为char类型字面值，双引号括起来的两个或多个字符则构成字符串型字面值。
		'a'		//字符字面值
		"Hello World!"	//字符串字面值
编译器在每个字符串的结尾处添加一个空字符（'\0'）。因此字符串字面值实际要比它的内容多1。例如，字面值'A'表示的就是单独的字符A，而字符串"A"则表示了一个字符的数组，该数组包含两个字符：一个是字母A，一个是空字符\0。
	如果两个字符串字面值位置紧邻且仅由空格、缩进、和换行符分割，则他们实际上是一个整体。当书写的字符串字面值比较长，写在一行不太合适时，就可以采用分开书写的方式：
			std::cout<<"a really,really long string literal "
						"that spans two lines"<<std::endl;

转义序列
	有两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，因为他们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号，双引号，问号和反斜杠——。在这种情况下，需要用到转义序列，转义序列均以反斜线为开始，C++规定的转义序列包括：
			换行符		\n	横向制表符	\t	报警符	\a
			纵向制表符	\v	退格符		\b	双引号	\"
			反斜线		\\	问号			\?	单引号	\'
			回车符		\r	进纸符		\f	
注意这里边的问号，需要转义（具体的原因我不太清楚到底是为什么，但是不转义也是可以输出问号的，如果以后遇到问题了，实在找不到问题，可以看看是不是问号没有进行转义造成的）

指定字面值的类型
	正如前面的整型字面值一样，43表示的是一个整型字面值，它的数据类型是有符号的，而且是int,long,long long中最小的一个。所以为了能够改变这种由系统自动给配置的类型，可以指定字面值的类型。
	L'a'		//宽字符型字面值，类型是wchar_t
	u8"hi!"		//utf-8字符串字面值（uft-8用8位编码一个Unicode字符）
	42ULL		//无符号整型字面值，类型是unsigned long long
	1E-3F		//单精度浮点型字面值，类型是float
	3.14159L	//扩展精度浮点型字面值，类型是long double
注意，上面的这些指定的字面值类型，有个特点是：字符的指定类型都在左边；数字的都是在右边。
				表2.2：	指定字面值的类型
					字符和字符串字面值
		前缀		含义							类型
		u		Unicode16字符				char16_t
		U		Unicode32字符				char32_t
		L		宽字符						wchar_t
		u8		UTF-8(仅用于字符串字面常量）		char
			整型字面值					浮点型字面值
		后缀			最小匹配类型			后缀		类型
		u or U		unsigned	 		f或F		float
		l or L		long				l或L		long double
		ll or LL	long long
		
对于一个整型字面值来说，我们能分别指定它是否带符号以及占用多少空间。如果后缀中有U，则该字面值属于无符号类型。也就说，以U为后缀的十进制数，八进制数或十六进制数都将从unsigned int、unsigned long、unsigned long long中选择能够匹配的空间中的最小的一个作为其数据类型。如果后缀中有L，则字面值的类型至少是long;如果后缀中有LL，则字面值的类型将是long long和unsigned long long中的一种。显然我们可以将U与L或LL合在一起使用。
指针字面值
	nullptr是指针字面值

2.2	变量
	变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型。数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。对C++程序员来说，“变量（variable）和”对象（object）“一般可以互换使用。
2.2.1	变量定义
	变量的定义的基本形式是：首先是 类型说明符（type specifier），随货紧跟一个或个多个变量名组成的列表，其中 变量名 以 逗号 分割，最后由 分号 结束。列表中每个变量名的类型都由类型说明符指定，定义时还可以为一个或多个变量赋初值。
术语：何为对象？
	C++程序员们在很多场合都会使用对象（object）这个名字，通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

初始值：
	当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialed）了。注意：这里说的初始化，指的是当你在创建一个对象的时候并且给它了一个特定的值，才叫做初始化！！
	用于初始化变量的值可以是任意复杂的表达式。当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此，在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量！

初始化不是赋值，初始化的含义是创建变量时候，赋予其一个初始值；而赋值的含义是把对象的原先的值擦除，然后以一个新的值去替代。

列表初始化：
	C++语言定义了初始化的好几种不同的形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：
	>>>>> int units_sold = 0;
	>>>>> int units_sold = {0};
	>>>>> int units_sold{0};
	>>>>> int units_sold(0);
	
	当用于内置类型的变量时，这种初始化形式有一个重要的特点：如果我们使用列表初始胡且初始值存在  丢失信息  的风险，则编译器将报错！！！
			long double ld = 3.1415926;
			int a{ld},b={ld};//错误，转换未执行，因为存在丢失信息的危险
			int c(ld),b=ld;//正确：转换执行，且确实丢失了部分值
	
默认初始化：
	如果定义变量时没有指定初始值，则变量被默认初始化（default initialed），此时变量被赋予了”默认值“。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。
	如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0（因为该变量是全局变量，被初始化为0）。定义在函数体内部的内置类型变量将不被初始化（unintialed）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。
	每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。
note:
	定义于函数体内的内置类型的对象如果没有初始化，则其值未定义；类的对象如果没有显示的初始化，则其值由类确定。
wenhao.cpp:6:11: error: ‘b’ was not declared in this scope
     int a=b=333;
所以注意，初始化的时候，都是从左到右的，一旦遇到没有定义的变量的时候，就会报错！！

2.2.2	变量的声明和定义的关系
	为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制。该机制允许将程序分成为若干文件，每个文件可被独立编译。
	一个实际的例子，就是std::cout和std::cin可以被我们写的程序所使用。为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明。而定义（definition）负责创建与名字有关的实体。
	变量声明规定了变量的类型和名字，在这一点和定义相同；但是除此之外，定义还要申请存储空间，也有可能会为变量赋予一个初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：
				extern int i;//声明一个变量i,而非定义i
				int j;		//定义一个变量j
	任何包含了显示初始化的声明就成了定义，我们能给由extern关键字编辑的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含了初始值就不再是声明，而变成了定义了！！！在函数体内部，如果初始化一个由一个extern关键字标记的变量，将引发错误。
		注意：变量只能被定义一次，但是却可以被多次声明！
	
关键概念：
	C++是一种静态类型（statically type）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）
	我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可以执行的文件。
	程序越复杂，静态类型检查越有助于我们发现问题。然而，前提是编译器必须要知道每一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型！
	
变量命名规范：
		>>>>变量名要能体现出实际含义
		>>>>变量名一般用小写字母，如index，不要用Index或INDEX
		>>>>用户自定义的类名一般以大写字母开头，如Sales_item
		>>>>如果标识符多个单词组成，则单词之间应该有明显的区分，如：student_loan或studentLoan
		
2.2.4	名字的作用域
	作用域是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分割。同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的 声明语句，以 声明语句 所在的作用域末端为结束。


2.3	复合类型
	复合类型（compound type）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两个：引用和指针。
	一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符（declarator）列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。到目前为止，我们所接触的声明语句中，声明符其实就是变量名，此时变量的类型也就是声明的基本数据类型。其实还可能具有更复杂的声明符，它基于基本数据类型得到更多的类型，并把它指定给变量。
2.3.1	引用
	引用（reference）为对象起了另外一个名字，引用类型引用另外一种。通过将声明符写成 &d的形式，其中d是声明的变量名：
			int val = 1024;
			int &refval = ival;//refVal指向ival(是ival的另一个名字）
			int &refVal2;//报错，因为引用必须得初始化，因为引用是别的变量的别名，所以必须得只能初始化。
	一般在初始化变量的时候，初始值会被拷贝到新建的对象中。然而定义 引用 时，程序把引用和它的初值 绑定 在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象  一直  绑定在一起。因为无法令引用对象重新绑定到另外一个对象，因此必须得初始化。
注意：
	引用是别名，引用不会占有内存，它不是一个对象。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用为初始值，实际上是以与引用绑定的对象作为初始值：
		int &refVal3 = refVal;//refVal3是ival的别名了
	引用本身不是一个对象，所以不能定义一个引用的引用。
解析为什么不可以：
	int &&a=b;
首先，编译的时候，都是从左到右检查的，就好比
	int a=b=3;
这样系统就会报错，说，b没有定义。同理，int &&a = b;编译也是从左到右进行检查的，所以等第一个&的时候，系统直到这是一个引用了，然后接下来就去找相应的绑定的对象，然后又发现一个&，这个时候，系统知道了是引用的引用，但是引用绑定的时候必须得有实际的空间，绑定到引用上是没有空间的，所以是不可以的！

引用的定义：
	允许在一条语句中定义多个引用，其中每个引用标识符都必须以&开头：
	int i = 1023,i2 = 2048;
	int &r = i,&ri = i2;
	
所有的引用的类型都要和与之 绑定的对象 严格匹配（也就是在初始化的时候，必须得与初始化的对象保持一致，这也就是为什么引用不能用字面值常量进行初始化了，如果要是用字面值初常量初始化的话，那么系统就有可能对其进行一定的处理使之能够与引用的类型符合了，所以：
			<<必须类型严格保持一致
			<<不能使用字面值常量为引用赋初值）。
而且引用只能绑定到 对象 上，而不能与 字面值 或某个 表达式的计算结果 绑定到一起。
		int &refVal4 = 10;//错误，引用类型的初始值必须是一个对象
		double dval = 3.14;
		int &refVal5 = dval;//错误：此处引用类型的初始值必须是int类型对象。（也就是引用的类型必须严格一致）
		
2.3.2	指针
	指针（pointer）也实现了对其他对象的间接访问。指针与引用相比又有很多不同点：其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象。其二，指针无须在定义的时候赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
	定义指针类型的方法将声明符写成*d的形式（例如引用是&d），其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面必须有*符号：
	int *ip1,*ip2;//ip1和ip2都是指向int型对象的指针
	double dp,*dp2;//dp2是指向double型对象的指针。
获取对象的地址：
	指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）：
		int val = 42;
		int *p = &val;//p存放变量ival的地址，或者说是p指向的变量val。
因为引用不是对象，没有实际的内存空间，所以不能定义指向引用的指针。指针和引用一样，指向的类型也必须得是严格的一致。
指针值：
	指针的值（即地址）应该属于下列4种状态之一：
		>>>>指向一个对象
		>>>>指向紧邻对象所占空间的下一个位置
		>>>>空指针，意味着指针没有指向任何对象
		>>>>无效指针，也就是上述情况之外的其他值
利用指针访问对象
	如果指针指向了一个对象，则允许使用解引用（操作符*)来访问该对象。
			int val = 42;
			int *p = &val;//p存放着val的地址
			cout<<*p;//使用*解引用指针，也就是读取存放地址上的内容；或者就是说查看指针指向的对象的内容。
其实可以理解解引用就是直接使用指针指向的对象。

空指针
	空指针（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否是空的。也就是
		if(p == nullptr)
		{}
一下列出几个生成空指针的方法：
			int *ptr = nullptr;//等价于 int *ptr=0;
			int *p2 = 0;//直接将p2初始化为字面常量0
	#include <cstdlib.h>
			int *p3 = NULL;
	以上三种情况都是给指针赋初始值为0的方法。
得到空指针最直接的方法就是用字面值nullptr来初始化指针，这也是C++11新标准的刚刚引入的方法。nullptr是一种特殊类型的字面值，他可以被转换成任意   其他类型   。

赋值和指针
	指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大的区别。其中最重要的一点就是引用本身不是一个对象，一旦定义了引用，就无法令其再绑定到另外的对象中去了。之后每次使用这个引用都是访问最开始绑定的对象。
	有时候要想搞清楚一条赋值语句到底是改变了指针的值还是指针所指向对象的值不太容易，最好的办法就是记住：
				赋值永远改变的都是符号左侧的对象！
	对于两个类型相同的合法指针，可以用相等操作符（==）或不相等操作符（！=）来比较他们，比较的结果是布尔型。如果两个指针存放的地址相同，则他们相同；反之他们不相等。

void * 指针
	void * 是一种特殊的指针类型，可用于存放任意对象的地址！！！一个void*指针存放着一个地址，这一点和其他指针类似。但不同的是，我们对该地址中到底是个什么类型的对象并不了解：
				double obj = 3.14,*pd = &obj;
				void *pv = &obj;//obj可以是任意类型的对象
				pv = pd;	//pv可以存放任意类型的指针
利用void*指针能做的事比较有限，拿它和别的指针比较，作为函数的输入或输出，或者赋值给另外一个void *指针。不能直接操作void*指针所指向的对象（因为你不知到它指向的对象的类型到底是什么！所以也就无法确定能在这个对象上做什么操作。
	概况来说，以void*的视角来看内存空间也就仅仅是内存空间，没有办法访问内存空间中所存在的对象。

2.3.3	理解复合类型的声明
	如前所述，变量的定义包括一个基本数据类型（base type）和 一组声明符  。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是说，一条定义语句可能定义出不同类型的变量：
	
定义多个变量：
	经常有一种观点会误以为，在定义语句中，类型修饰符（*或&）仅仅是类型说明符的一部分唯一。例如：
			int* p;//合法但是容易产生误导
我们说这种写法可能产生误导是因为int*放在一起好像是这条语句中所有变量共同的类型一样，但是恰恰相反，基本数据类型是int 而非 int* ；*仅仅是一个类型修饰符而已，修饰的是p而已。对该声明语句中的其他变量，它并不产生任何作用！！！
		int* p,p1;//p 是一个指针，而p1是一个int类型的变量而已。
涉及指针或引用的声明，一般有两种写法。第一种写法就是把类型修饰符和变量名写在一起
				int *p;
另一种是把类型修饰符和类型写在一块：
				int* p;
我个人比较喜欢第一种方式，所以我以后所有的复合类型都是使用第一种方式了！

指向指针的指针
	一般来说，声明符中的类型修饰符的个数并没有限制，当有多个修饰符连写在一起的时候，按照其逻辑关系详加解释就好。以指针为例，指针是内存中的对象，像其他对象一样也有自己的内存空间，地址，因此允许把指针的地址再放到另一个指针当中。
	通过*的个数可以区分指针的级别。也就是说，**表示指向指针的指针（也就是该指针存放的是指针的地址！！！）***表示指向指针的指针的指针的指针。
		int ival = 1024;
		int *pi = &ival;//pi指向一个int型的指针
		int **ppi = &pi;//ppi指向一个int类型的指针。
这个可以这样理解 (int *) *p;//首先*表示的是一个指针，然后继续往左看是一个*指针而且其类型是int型的，所以表示的是一个指向int型指针的指针！
		[ ppi ]-->[ pi ]-->[1024]
解引用一个int型指针会得到一个int型的数，同样解引用一个指向指针的指针，会得到相应的指针。

指向指针的引用：
	引用本身不是一个对象，所以不存在指向引用的指针。但指针是对象，所以存在对指针的引用。
			int i = 42;
			int *p;
			int *&r = p;//r是一个对指向int类型指针的引用。
可以这样理解：
			还是从变量名开始，从右往左开始一步一步的分析，首先碰到的是一个&，也就是说这个最基本的就是一个引用，然后继续往左开始走，发现是一个*所以有可能是一个对指针的引用，继续走，发现到了基本类型符int，所以可以发现这是一个对指向int类型的指针的引用。
			
2.4	const限定符
	有时我们希望定义这样一种变量，它的值是不能被改变的。为了满足这一要求，可以用关键字const对变量的类型进行加以限定！
				const int bufSize = 512;
				int const bufSize = 512;
	以上这两种方法都是对的，表示的都是一个int型的常量。现在任何试图为bufSize赋值的行为都将引发错误：
				bufSize = 512;//试图向const对象写值，错误
因为const对象一旦创建后，其值就不能再改变，所以const对象一开始就得必须初始化。一如既往，初始值可以是任意复杂的表达式。(这一点和引用差不多，因为引用一旦被指定，那么就不能再改变了，所以一开始也必须得初始化）
				const int i = get_size();//正确，运行时初始化
				const int j = 42;//正确，编译时初始化
				const int k;//错误，k是一个没有经过初始化的常量
其实，仔细想想：常量是一个常数，不能进行改变的；所以你要是刚开始没有给它进行初始化，那么后边所有进行的有等号的方式都是赋值了，而不是初始化。因为const是常数，所以任何对其进行赋值的操作都是错误的！所以，我们使用常量的时候，必须得给其进行初始化，否则就是错误的！！
初始化和const	
	正如之前反复提到的，对象的类型决定了其上的操作。与非const类型所能参与的操作相比，const类型的对象能完成其中的大部分，但也不是所有的操作都适合。主要限制就是只能在const类型的对象上执行不改变其内容的操作。
	在不改变const对象的操作中还有一种就是初始化，如果利用一个对象去初始化另外一个对象，则他们是不是const无所谓。！！！！！也就是说，在初始化

默认状态下，const对象仅在文件内有效
	当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：
				const int bufSize = 512;
编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到的bufSize的地方，然后用512替换。
	为了执行上述的替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对他的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。
注意这一特点：
		普通的变量，只能定义一次，也就是说，我在头文件中写了一个
				int a;//也就是定义
如果此时两个.cpp文件都包含这个头文件的话，那么此时编译这两个.cpp文件的时候会报错，报的错误是重复定义。但是如果你在.h文件中定义了一个const常量（因为常量必须得初始化），那么多个.cpp文件包含这个.h文件的时候，不会报错。这个就是const对象仅在文件内有效的特点。
	某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件中共享。这种情况下，我们不希望编译器为每一个文件分别生成独立的变量。相反，我们想让这类const对象像其他非常量对象一样工作。也就是说，只在一个文件中定义const，而在其他文件中声明并使用它。
	解决的方法就是：
			对于const常量不管是声明还是定义都加上extern关键字，这样就只需定义一次就可以了。
	file_1.h头文件
		extern const int bufSize;//声明const int bufSize
	file_1.c中
		extern const int bufSize = 512;//定义并初始化const常量
这里有好几个东西要注意：
		>>>首先，const变量本身都是必须要进行初始化的；但是为了可以让所有需要使用该常量的源文件都能够使用该文件，所以必须得在外边进行相应的声明。但是因为常量必须得初始化，但现在要声明，所以不能让常量进行初始化，所以const的常量的声明不能进行初始化！所以应该和别的变量声明一样，
		>>>接下来为了能够在别的地方也可以使用，所以通常在.h文件中进行声明也就是:
				extern const int a;
但是注意extern int a;只能在函数外边进行声明，在函数内进行这样的声明就会报错！
		>>>但是定义该常量的时候，就得要注意了。因为extern int a = 10；相当于定义，所以extern const int a = 10;也是相当于定义！所以const的常量的定义也得使用这样的方式！
		
2.4.1	const引用
	可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：
			const int ci = 1024;
			const int &r1 = ci;//正确：引用及其对应的对象都是常量
	//首先引用必须得类型对应一致，所以你想要引用const的常量，就必须本身也是const的常量
			int &r2 = ci;//错误：试图让一个非常亮引用指向一个常量对象！必须严格一致。
初始化和对const的引用，
	前面提到过，引用的类型必须与其所引用的对象的类型一致，但是有两个例外。第一个例外就是：
		>>>在初始化常量引用的时候允许任意表达式作为初始值，只要该表达式的结果能够转换成引用类型即可。有其允许一个常量引用绑定到非常量的对象、字面值，甚至是一般表达式。
			int i =32;
			const int &r1 = i;
			const int &r2 = 32;//可以是一个字面值
			const int &r3 = r1 * 2//
注意：普通的引用：
		>>>必须保证引用绑定的是一个对象
		>>>绑定的不能是字面值常量
		>>>类型严格一致
要想理解这种例外情况的原因，最简单的方法就是弄清楚一个常量引用被绑定到另外一种类型上时发生了什么：
			double dval = 2.13;
			const int &ri = dval;//可以，常量引用可以使用任意类型来初始化该常量引用
	此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码改变成了如下形式：
			const int temp = dval;
			const int &ri = temp;
在这种情况下，ri绑定了一个临时量对象。所谓临时对象就是当编译器需要一个空间来暂存表达式的求值表达式结果临时创建的一个未命名的额对象。
	接下来讨论当ri不是常量时，如果执行了类似上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时变量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时变量上，C++语言就认为这种行为是非法的！所以不是常量引用的，类型严格一致；是常量引用的就可以是任意类型的值！

2.4.2	指针和const
	与引用一样，也可以令指针指向常量和非常量。类似于常量引用。指向常量的指针（pointer to const），不能用于改变其所指向的对象的值。要想存放常量的地址，只能使用指向常量的指针：
			const double pi = 3.14;
			double *ptr = &pi;//错误，ptr是一个普通的变量，
			const double *cptr = &pi;//正确：cptr可以指向一个双精度常量
			*cptr = 42;//错误，不能给*cptr赋值，因为其是指向一个常量的指针，所以不能改变该常量的值。
	和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值。而没有规定那个对象本身的值能不能通过别的途径改变。
	试试这样想，所谓指向常量的指针或者引用，其实不过就是指针或或引用”自以为是“罢了。他们觉得他们指向了常量，所以自觉的不去改变所指对象的值。
小结：
		注意，所谓的常量引用或者指向常量的指针，并没有说明所引用的对象或者所指的对象是什么类型的，或者是不是常量。因为常量引用或者指向常量的指针，本意是：不允许通过该常量去改变所绑定的对象的值，或所指向的对象的值。但是并没有规定通过别的方式去改变绑定对象的值或所指对象的值。所以也正是因为这一点，我们的const int &a;或者const int *p;对应初始化的变量的类型是任意的。但是，普通的就不得类型严格一致了。
		
const指针
	指针是对象而引用不是对象，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针（const pointer）和普通的常量一样，也必须得初始化。而且一旦初始化完成，则它的值（也即是存放在指针中的那个地址）就不能改变了。把*放在const之前用以说明指针是一个常量。这样的书写形式隐含着一层意味，即不变的指针本身的值而非指向的那个值：
				int errNumb = 0l
				int *const curErr = &errNumn;.// curErr将一直指向对象errNum
				const double pi = 3.14159;
				const double *const pip = &pi;//
从左向右看*const所以这个指针是一个常量，然后有一个const double所以指向的变量是常量（但是注意，这个指向的常量这是说明，不能通过这个指针来修改所指对象的值，但并不是说所指对象本身是一个常量！）一定要记住，常量引用和指向常量的指针只是说明不能够通过引用或指针来修改所指向的对象的值。
	但是常量指针却是不能改变本身的值，也就是不能指向别的对象了；但是却可以改变其所指向的对象的值。所以指向常量的常量指针就是既不能改变所指的对象；又不能够改变所指对象的值。
	
2.4.3	顶层const
	如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用顶层const表示指针本身是一个常量，而用名词底层const表示指针所指的对象是一个常量（艹，这个表达感觉真的好操蛋，指向常量的指针，其所指的对象本身却不一定是常量，还叫指向常量。（这个感觉可以叫做不能通过该指针来改变所指向对象的值的指针！）
	何为顶层，顶层就是本身是常量；何为底层，底层是指向常量的指针。注意：任意的常量引用都是底层的const！
	当执行对象拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响。因为执行操作并不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量并没有什么影响。
	另一方面，底层const的限制却不可以忽视。当执行对象拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量。反之则不行。
注意：
		底层的const一定要类型匹配严格一致；顶层const在赋值的时候会被忽略掉，所以看的时候一定要注意别忽略掉底层的类型严格一致。
		
2.4.4	constexpr和常量表达式
	常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值表达式属于常量表达式，用常量表达式初始化的const对象也是常量表达式，后面将会提到，C++语言中有几种情况下是要用到常量表达式的。
	一个对象（或表达式）是不是常量表达式由它的   数据类型  和  初始值  共同决定的。
		const int max_files = 20;//是常量表达式，首先数据类型是常量，20是字面值，也是常量
		const int limit = max_files + 1//和max_files一样，所以也是常量表达式
		int staff_size = 27//首先虽然27是字面值常量，但是数据类型不是常量，所以staff_size不是常量表达式
		const int sz = get_size();//虽然数据类型是常量，但是get_size()不是常量表达式，所以sz不是常量表达式。		

constexpr变量
	在一个复杂系统中，很难分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并且把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在此情况下，对象的定义和使用根本就是两回事。
	C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来  验证   变量的值是不是一个 常量表达式 。声明为constexpr的变量一定是一个   常量   ，而且必须用常量表达式初始化。（注意这句话的意思是：首先，被用常量表达式初始化的constexpr变量一定是一个常量；但是如果初始值不是常量表达式的话，那么这个定义就是错误的！）
所以：
		>>>>constexpr定义的变量一定是常量表达式
		>>>>初始值一定要是常量表达式，但是如果初始值不是常量表达式的话，那么这个定义就出错误了！
所以就可以使用constexpr来验证你想要的定义的类型是不是常量表达式了。
字面值类型
	常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把他们称为”字面值类型“。
	到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不可以被定义为constexpr。
	尽管指针和引用都能定义成constexpr，但是他们的初始值却收到严格的限制。为什么？首先：
			普通的引用和指针不能使用字面值常量为其赋初值。这里瞎猜一下为什么引用不能使用字面值赋初值的原因：
			int &r = 1;
首先，引用是对象的一个别名，你这个1既没有变量名，有没有内存空间，根本就不是一个对象，所以不可以这样进行给引用使用。但是常量引用却可以，是为什么呢？因为常量引用不会去改变其对象的值，所以尽管1不是一个对象，但是只要给常量引用赋值就好了，常量引用不会去改变值，所以只需要一个值就ok了。
	但是指针只能是指向nullptr/0/NULL才可以用字面值常量，其他的全是指向变量。
	函数体内定义的变量一般来说并非存放在固定的地址中，因此constexpr指针不能指向这样的变量。相反，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。

指针和constexpr
	必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅仅对指针有效，与指针所指的对象无关。
			const int *p = nullptr;//是一个底层const，而且p是一个指向常量的指针
			constexpr int *q = nullptr;//q是一个指向整数的常量指针。
	constexpr定义的指针，直接把它所定义的指针定义成了顶层const！！！
与其他常量指针类似，常量指针既可以指向常量也可以不指向常量（因为常量指针仅仅要求的是指针是一个常量，而不要求对象是不是常量）
小结：
	这里const只是一个限制，限制的是你的变量的操作限制；但是对其绑定的对象或者指向的对象毫无关系！所以不论是常量引用或者指向常量的指针或者是常量指针，都对其对象是不是常量去关。
	但是若其本身是普通的，那么就得对其初始值的类型严格匹配！因为不匹配的话，那么就可以通过普通的引用去通过绑定的常量来修改常量引用绑定的对象了，这就违背了规则，所以是错误的！
	>>>>常量有关的初始化（作为左值），其右边的初始化的类型任意
	>>>>普通的初始化（作为左值），其右边的初始化的类型必须严格匹配！

2.5	处理类型
2.5.1	类型别名
	类型别名（type alias）是一个名字，它是某种类型的同义词。有两种方法可以定义类型别名。传统的方法是使用关键字typedef:
				type 类型名	类型别名
			typedef double wages;//wages是double的别名
			typedef wages base,*p;//p是double * 的别名，base是double的别名
注意：
		指针和引用都是复合类型，是有(*)/(&)来实现的复合的，所以*a就是指针，而&a就是引用。
和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也可以由基本数据类型构造出复合类型。
>>>新标准规定了一种新的方法，使用  别名声明 (alias declaration）来定义类型的别名
			using SI = Sales_item;//SI是Sales_item的同义词，别名！
这种方法用关键字using作为别名声明的开始，其后紧跟 别名 和 等号 。其作用是把等号左侧的名字规定成等号右侧类型的别名。

指针、常量和类型别名
	如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char *的别名：
			typedef char * pstring;
			const pstring cstr = 0;//cstr是一个常量指针，这个指针是指向char类型的。
			const pstring *ps；//这是一个指针，它的对象是指向char类型的常量指针
注意：
	这里的理解是，基本类型变成了char *（也就是一个指针）
	>>>>const pstring(也就是说，这个变量是常量指针） == char * const
	>>>>const char *   == char const *
这里表示的意思是，首先在复合类型中要明白这个复合类型是什么。比如第一个，已经知道这个复合类型是指针了，所以const pstring就是一个常量指针。然后其等式右边，也是一个指针然后再是const
	The base type in these declarations is const pstring. As usual, a const that appears in the base type modifies the given type. The type of pstring is “pointer to char.” So, const pstring is a constant pointer to char—not a pointer to const char.
这里直接引入的是原文对于const的有关了解。const出现在base type旁边是修饰base type的，也就是在左边还是右边没有半点差别。
	所以这里我只需要找到啥是基本类型就好了。在const pstring中，基本类型是c指针，所以等价于char * const。而const char *的基本类型是char，所以等价于char const *!所以一定要找到什么是基本类型，然后再去转换！

2.5.2	auto类型说明符
	编程的时候常常需要把表达式的值赋值给变量，这就要求在声明变量的时候清楚的知道表达式的类型。然而做到这一点并非那么容易！有时根本做不到。为了解决这个问题，C++11新标准引入 auto类型说明符 ，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过 初始值 来推算 变量的类型 。显然，auto定义的变量必须有初始值。（这也就是说。auto定义的变量也必须得有初始值；引用也必须得有初始值）
		//由val1和val2相加的结果可以推断出item的类型。
		auto item = val1 + val2;//item初始化为val1 + val2相加的结果
此处编译器将根据val1和val2相加的结果来推断item的类型，如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item；如果这两个变量的类型是double，则item即使double。
	使用auto也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本类型都必须得一样：
			auto i = 0,*p = &i;//正确：i是整数，所以推出auto是int，然后*p = &i，其中i是int，所以推出的也是int。所以是对的
			auto sz = 0,pi = 2.14;//错误，sz推出的是int，而pi推出的是double。所以不对！
	auto一般会忽略掉顶层const（前面也讲过，赋值的时候会忽略顶层的const），同时底层则会保留下来，比如当初始值是一个指向常量的指针时：
			const int ci = i,&cr = ci;
			auto b = ci;//b是一个int类型的变量（忽略掉顶层的const）
			auto c = cr;//c是一个整数，（它是根据cr引用的对象的类型来判断的）
			auto d = &i;//这是一个int类型的指针
			auto e = &ci;//这是一个指向整数常量的指针（注意，对常量对象取地址是一种底层const）！！！！
	如果希望推断出的auto类型是一个顶层const，需要明确指出：
			const auto f = ci;//ci推出的类型是int，然后再加上const！
还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：
		auto &g = ci;//这是一个int型的常量引用
		auto &h = 42;//错误，不能为非常量引用绑定字面值！！
		//常量引用可以绑定任意类型的值，包括字面值
		const auto &j = 42;//正确：可以为常量引用绑定字面值。
要在一条语句中定义多个变量，切记，符号&和*只是从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一类型。

2.5.3	decltype类型指示符
	有时候会遇到这种情况，希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype。它的作用是 选择并 返回  操作数的   数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。！！
		decltype(f())	sum = x;//sum的类型就是函数f的返回类型。
编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型（也就是查看函数的返回类型是什么，根据这个来赋予数值类型。
	decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）！
		const int ci = 0,&cj = ci;
		decltype(ci) x = 0;//x的类型是const int 
		decltype(cj) y = x;//y的类型是const int &，y绑定到变量x
		//常量引用都是底层const
		decltype(cj) z;//错误，z是一个引用，必须得初始化！
需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。

decltype和引用
	如果decltype使用的表达式不是一个 变量   ，则decltype返回表达式结果对应的 类型 。有些 表达式 将向decltype返回一个引用类型，一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：
				int i = 32,*p = &i,&r = i;
				decltype(r+0) b;//因为r+0是表达式，所以返回表达式的类型，因为r+0的结果类型是int，所以返回的是int类型
				decltype(*p) c;//这个返回的是引用类型，因为*p是解引用操作，所以表达式返回的是引用类型。
	decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切有关。有一种情况需要特别注意：对于decltype所用表达式来说，如果让变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个 表达式  。变量是作为赋值语句的左值的特殊表达式，所以这样的decltype就会得到引用类型。
注意：
		也就是表达式如果加上了括号，就变成了引用。！！！
			decltype((i)) d;//错误，d是int &。必须初始化
			decltype(i) e;//正确
切记：
		decltype((variable))（注意是双层括号）的结果永远是引用！而decltype（variable）结果只有为*p或者是本身是一个引用的时候才是引用！

2.6	自定义数据结构
	从最基本的层面理解，数据结构就是把一组相关的数据元素组织起来然后使用他们的策略和方法。举一个例子，我们的Sales_item类把书本的ISBN编号、售出量及销售收入等数据组织在一起，并且提供诸如isbn函数、>>、<<、+、+=等运算在内的一系列操作，Sales_item类就是一个数据结构。
	C++语言允许用户以 类 的形式自定义数据类型，而库类型string、istream、ostream等也是以类的形式定义的。C++语言对类的支持甚多，事实上本书的第三部分和第四部分将大篇幅的介绍与类有关的知识。
	既然我们筹划的这个数据结构不带有任何运算功能，不妨把它命名为Sales_data以与Sales_item的区别。Sales_data初步定义如下：
			struct Sales_data
			{
				std::string bookNo;
				unsigned units_sold = 0;
				double revenue = 0.0;
			};
我们的类以关键字struct开始，紧跟着类名和类体（其中类体部分可以为空）。这个命名方式和我们的以前的以前，类型名 + 变量名（不过这个变量名就是类名），然后就是类的成员（用花括号来列出来）。类内部的名字必须唯一，但是可以与类外定义的名字重复。
	类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义。所以分号必不可少！（注意一般的花括号后边是不跟分号的，这里是一个很特殊的地方。之所以加分号是以为这是一个命名语句，在花括号后边可以定义类的对象，所以必须得加分号。所以即使你定义类的时候，没有定义其对象，也得有分号！
	struct Sales_data{/*...*/} accum.trans,*salesptr;//后边的都是该类的对象，再次印证了必须要加分号！分号表示声明符（通常为空）的结束。一般来说，最好不要把对像的定义和类的定义放在一起。这么做无异于把两种实体的定义混在一条语句里，一会定义类，一会定义变量。显然这是一种不被建议的行为。
注意：
		很多新手程序员经常忘了在定义的最后加入分号！一定要记住，这只是一个定义变量的过程，所以必须得有分号作为标志结束，而花括号仅仅是一个列表而已，而不是一个函数体的部分。
		
数据成员
	类体定义的成员，我们的类只有数据成员（data number）。类的数据成员定义了类的 对象 的 具体内容 ，每个 对象 有自己的一份的数据成员拷贝。修改一个对象的数据成员，不会影响其他的Sales_data的对象！！！
	定义数据成员的方法和定义普通变量一样：首先说明一个基本类型，随后紧跟一个或多个声明符。C++11新标准规定，可以为数据成员提供一个 类内初始值 。创建对象时，类内初始值将用于初始数据成员，没有初始值的成员将被默认初始化。因此当定义Sales_data的对象时，units_sold和revenue将被初始化为0，bookNo将被初始化为空字符串。

2.6.3	编写自己的头文件
	尽管可以在函数体内定义类，但是这样的类毕竟收到了一定的限制。所以，类一般不定义在函数体内。当函数体外部定义类时，在各个指定的源文件中可能只有一处该类的定义。而且，如果要在不同文件中使用同一个类，类的定义就必须保持一致。
	为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字与类的名字一样。例如，库类型string在名为string的头文件中定义。又如，我们应该把Sales_data类定义在Sales_data.h头文件中。
	头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。头文件也经常用到其他头文件的功能。例如，我们的Sales_data类包含有一个string成员，所以Sales_data.h必须包含string.h头文件。同时，使用Sales_data类的程序为了能操作bookNo成员需要再一次包含string.h文件。所以一般书写的时候都是开头写一些操作来适当处理一些东西。
	
预处理器概述
	确保头文件多次包含仍能安全工作的常用的技术是预处理器（preprocessor），它由C++语言从C语言继承而来。预处理器是在编译之前执行一段程序，可以部分地改变我们所写的程序。当预处理器看到#include标记时就会用指定的头文件的内容替代#include。
	C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真;#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
	
		#ifdef SALES_DATA_H
		#define SALES_DATA_H
		#include <string>
		struct Sales_data
		{
			std::string bookNo;
			unsigned units_sold = 0;
			double revenue = 0.0;
		};
		#endif
	
				
